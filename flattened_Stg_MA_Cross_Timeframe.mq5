
////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Stg_MA_Cross_Timeframe.mq5
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: EA.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerSqlite.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerConverter.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Serializer.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Serializer's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Enumeration for serializer enter mode. */
enum SerializerEnterMode { SerializerEnterArray, SerializerEnterObject };

/* Enumeration for serializer mode. */
enum SerializerMode { Serialize, Unserialize };

/* Enumeration for serializer flags. */
enum ENUM_SERIALIZER_FLAGS {
  _SERIALIZER_FLAGS_START = 0,
  SERIALIZER_FLAG_SKIP_HIDDEN = 1 << 0,
  SERIALIZER_FLAG_ROOT_NODE = 1 << 1,
  SERIALIZER_FLAG_SKIP_PUSH = 1 << 2,
  SERIALIZER_FLAG_SINGLE_VALUE = 1 << 3,
  SERIALIZER_FLAG_SIMULATE_SERIALIZE = 1 << 4,
  SERIALIZER_FLAG_EXCLUDE_DEFAULT = 1 << 5,
  SERIALIZER_FLAG_INCLUDE_DYNAMIC = (1 << 6) | SERIALIZER_FLAG_EXCLUDE_DEFAULT,
  SERIALIZER_FLAG_INCLUDE_FEATURE = (1 << 7) | SERIALIZER_FLAG_EXCLUDE_DEFAULT,
  SERIALIZER_FLAG_INCLUDE_DEFAULT = 1 << 8,
  SERIALIZER_FLAG_REUSE_STUB = 1 << 9,
  SERIALIZER_FLAG_REUSE_OBJECT = 1 << 10,
  _SERIALIZER_FLAGS_END,
  // Compound flags.
  SERIALIZER_FLAG_INCLUDE_ALL =
      SERIALIZER_FLAG_INCLUDE_DEFAULT | SERIALIZER_FLAG_INCLUDE_DYNAMIC | SERIALIZER_FLAG_INCLUDE_FEATURE,
};

/* Enumeration for serializer field flags. */
enum ENUM_SERIALIZER_FIELD_FLAGS {
  _SERIALIZER_FIELD_FLAGS_START = 1 << 16,
  SERIALIZER_FIELD_FLAG_HIDDEN = 1 << 16,
  SERIALIZER_FIELD_FLAG_DYNAMIC = 1 << 17,
  SERIALIZER_FIELD_FLAG_FEATURE = 1 << 18,
  SERIALIZER_FIELD_FLAG_DEFAULT = 1 << 19,
  SERIALIZER_FIELD_FLAG_VISIBLE = 1 << 20,
  _SERIALIZER_FIELD_FLAGS_END
};

enum ENUMSERIALIZER_GENERIC_FLAGS {
  _SERIALIZER_GENERIC_FLAGS_START = 1 << 24,
  _SERIALIZER_GENERIC_FLAGS_END,
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Serializer.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerNode.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerNode.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes SerializerNode's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Enumeration for serializer node type. */
enum SerializerNodeType {
  SerializerNodeUnknown,
  SerializerNodeObject,
  SerializerNodeValue,
  SerializerNodeArray,
  SerializerNodeObjectProperty,
  SerializerNodeArrayItem
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerNode.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerNodeParam.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerConversions.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Refs.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Refs' structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward class declaration.
class Refs;
class ReferenceCounter;
template <typename X>
struct WeakRef;

/**
 * Simples type of reference. Deletes object's pointer if reference goes out of the scope/is destructed.
 */
template <typename X>
struct SimpleRef {
  /**
   * Pointer to target object.
   */
  X* ptr_object;

  /**
   * Constructor.
   */
  SimpleRef(X* _ptr) { this = _ptr; }

  /**
   * Destructor.
   */
  ~SimpleRef() {
    if (ptr_object != NULL) {
      delete ptr_object;
    }
  }

  /**
   * Makes a reference to the given object.
   */
  void operator=(X* _ptr) {
    if (ptr_object == _ptr) {
      // Assigning the same object.
      return;
    }
    Unset();

    ptr_object = _ptr;
  }

  /**
   * Unbinds holding reference.
   */
  void Unset() {
    if (ptr_object != NULL) {
      delete ptr_object;
      ptr_object = NULL;
    }
  }
};

/**
 * Class used to hold strong reference to reference-counted object.
 */
template <typename X>
struct Ref {
  /**
   * Pointer to target object.
   */
  X* ptr_object;

 public:
  /**
   * Constructor.
   */
  Ref(X* _ptr) { this = _ptr; }

  /**
   * Constructor.
   */
  Ref(Ref<X>& ref) { this = ref.Ptr(); }

  /**
   * Constructor.
   */
  Ref(WeakRef<X>& ref) { this = ref.Ptr(); }

  /**
   * Constructor.
   */
  Ref() { ptr_object = NULL; }

  /**
   * Destructor.
   */
  ~Ref() { Unset(); }

  /**
   * Returns pointer to target object.
   */
  X* Ptr() { return ptr_object; }

  /**
   * Checks whether any object is referenced.
   */
  bool IsSet() { return ptr_object != NULL; }

  /**
   * Unbinds holding reference.
   */
  void Unset() {
    if (ptr_object != NULL) {
      if (CheckPointer(ptr_object) == POINTER_INVALID) {
        // Double check the pointer for invalid references. Can happen in rare circumstances.
        ptr_object = NULL;
        return;
      }
      if (ptr_object.ptr_ref_counter == NULL) {
        // Object is not reference counted. Maybe a stack-based one?
        return;
      }
      // Dropping strong reference.
      if (!--ptr_object.ptr_ref_counter.num_strong_refs) {
#ifdef __debug_ref__
        Print(ptr_object.ptr_ref_counter.Debug());
#endif

        // No more strong references.
        if (!ptr_object.ptr_ref_counter.num_weak_refs) {
          if (CheckPointer(ptr_object.ptr_ref_counter) == POINTER_INVALID) {
            // Serious problem.
#ifndef __MQL4__
            // Bug: Avoid calling in MQL4 due to 'global initialization failed' error.
            DebugBreak();
#endif
            return;
          }

          // Also no more weak references.
          delete ptr_object.ptr_ref_counter;
          ptr_object.ptr_ref_counter = NULL;
        } else {
          // Object becomes deleted, but there are some weak references.
          ptr_object.ptr_ref_counter.deleted = true;
        }

        // Avoiding delete loop for cyclic references.
        X* ptr_to_delete = ptr_object;

        if (CheckPointer(ptr_to_delete) == POINTER_INVALID) {
          // Serious problem.
#ifndef __MQL4__
          // Bug: Avoid calling in MQL4 due to 'global initialization failed' error.
          DebugBreak();
#endif
          return;
        }

        // Avoiding double deletion in Dynamic's destructor.
        ptr_object.ptr_ref_counter = NULL;
        ptr_object = NULL;

#ifdef __debug__
        Print("Refs: Deleting object ", ptr_to_delete);
#endif

        delete ptr_to_delete;
      }

      ptr_object = NULL;
    }
  }

  /**
   * Makes a strong reference to the given object.
   */
  X* operator=(X* _ptr) {
    if (ptr_object == _ptr) {
      // Assigning the same object.
      return Ptr();
    }

    Unset();

    ptr_object = _ptr;

    if (ptr_object != NULL) {
      if (CheckPointer(ptr_object) == POINTER_INVALID || ptr_object.ptr_ref_counter == NULL) {
        // Double check the pointer for invalid references. Can happen very rarely.
        return Ptr();
      }
      ++ptr_object.ptr_ref_counter.num_strong_refs;
#ifdef __debug_ref__
      Print(ptr_object.ptr_ref_counter.Debug());
#endif
    }

    return Ptr();
  }

  /**
   * Makes a strong reference to the given weakly-referenced object.
   */
  X* operator=(WeakRef<X>& right) {
    this = right.Ptr();
    return Ptr();
  }

  /**
   * Makes a strong reference to the strongly-referenced object.
   */
  X* operator=(Ref<X>& right) {
    this = right.Ptr();
    return Ptr();
  }

  /**
   * Equality operator.
   */
  bool operator==(const Ref<X>& r) { return ptr_object != NULL && ptr_object == r.ptr_object; }
};

/**
 * Class used to hold weak reference to reference-counted object.
 */
template <typename X>
struct WeakRef {
  /**
   * Pointer to object holding reference counts.
   */
  ReferenceCounter* ptr_ref_counter;

 public:
  /**
   * Constructor.
   */
  WeakRef(X* _ptr = NULL) { this = _ptr; }

  /**
   * Constructor.
   */
  WeakRef(WeakRef<X>& ref) { this = ref.Ptr(); }

  /**
   * Constructor.
   */
  WeakRef(Ref<X>& ref) { this = ref.Ptr(); }

  /**
   * Destructor.
   */
  ~WeakRef() { Unset(); }

  bool ObjectExists() { return ptr_ref_counter != NULL && !ptr_ref_counter.deleted; }

  X* Ptr() { return ObjectExists() ? (X*)ptr_ref_counter.ptr_object : NULL; }

  /**
   * Makes a strong reference to the given object.
   */
  X* operator=(X* _ptr) {
    if (ptr_ref_counter == (_ptr == NULL ? NULL : _ptr.ptr_ref_counter)) {
      // Assigning the same object or the same NULL.
      return Ptr();
    }

    Unset();

    if (_ptr == NULL) {
      // Assigning NULL.
      return Ptr();
    }

    if (_ptr.ptr_ref_counter.deleted) {
      // Assigning already deleted object.
      ptr_ref_counter = NULL;
      return Ptr();
    }

    ptr_ref_counter = _ptr.ptr_ref_counter;

#ifdef __debug_ref__
    Print(ptr_ref_counter.Debug());
#endif

    ++ptr_ref_counter.num_weak_refs;

    return Ptr();
  }

  /**
   * Makes a weak reference to the given weakly-referenced object.
   */
  X* operator=(WeakRef<X>& right) {
    this = right.Ptr();
    return Ptr();
  }

  /**
   * Makes a weak reference to the strongly-referenced object.
   */
  X* operator=(Ref<X>& right) {
    this = right.Ptr();
    return Ptr();
  }

  /**
   * Equality operator.
   */
  bool operator==(const WeakRef<X>& r) const { return ptr_ref_counter != NULL && ptr_ref_counter == r.ptr_ref_counter; }

  /**
   * Unbinds holding reference.
   */
  void Unset() {
    if (ptr_ref_counter != NULL) {
      // Dropping weak reference.
      if (!--ptr_ref_counter.num_weak_refs) {
        // No more weak references.
#ifdef __debug_ref__
        Print(ptr_ref_counter.Debug());
#endif

        if (!ptr_ref_counter.num_strong_refs) {
          // There are also no strong references.
          ReferenceCounter* stored_ptr_ref_counter = ptr_ref_counter;
          if (!ptr_ref_counter.deleted) {
            // It is safe to delete object and reference counter object.
            // Avoiding double deletion in Dynamic's destructor.
            ptr_ref_counter.ptr_object.ptr_ref_counter = NULL;

#ifdef __debug_ref__
            Print("Refs: Deleting object ", ptr_ref_counter.ptr_object);
#endif

            if (CheckPointer(ptr_ref_counter.ptr_object) == POINTER_INVALID) {
              // Serious problem.
#ifndef __MQL4__
              // Bug: Avoid calling in MQL4 due to 'global initialization failed' error.
              DebugBreak();
#endif
              return;
            }

            delete ptr_ref_counter.ptr_object;
          }

          if (CheckPointer(stored_ptr_ref_counter) == POINTER_INVALID) {
            // Serious problem.
#ifndef __MQL4__
            // Bug: Avoid calling in MQL4 due to 'global initialization failed' error.
            DebugBreak();
#endif
            return;
          }

          delete stored_ptr_ref_counter;
        }
      }
    }

    ptr_ref_counter = NULL;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Refs.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DictObject.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Convert.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Order.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Order's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Order actions. */
enum ENUM_ORDER_ACTION {
  ORDER_ACTION_CLOSE = 1,       // Close the order.
  ORDER_ACTION_COND_CLOSE_ADD,  // Add close condition.
  ORDER_ACTION_OPEN,            // Open the order.
  FINAL_ORDER_ACTION_ENTRY
};

/* Order conditions. */
enum ENUM_ORDER_CONDITION {
  ORDER_COND_NONE = 0,         // Empty condition.
  ORDER_COND_IN_LOSS,          // When order in loss
  ORDER_COND_IN_PROFIT,        // When order in profit
  ORDER_COND_IS_CLOSED,        // When order is closed
  ORDER_COND_IS_OPEN,          // When order is open
  ORDER_COND_LIFETIME_GT_ARG,  // Order lifetime greater than argument value.
  ORDER_COND_LIFETIME_LT_ARG,  // Order lifetime lesser than argument value.
  ORDER_COND_PROP_EQ_ARG,      // Order property equals argument value.
  ORDER_COND_PROP_GT_ARG,      // Order property greater than argument value.
  ORDER_COND_PROP_LT_ARG,      // Order property lesser than argument value.
  FINAL_ORDER_CONDITION_ENTRY
};

// Defines enumeration for order properties.
enum ENUM_ORDER_PARAM {
  ORDER_PARAM_NONE = 0,              // None.
  ORDER_PARAM_COLOR_ARROW,           // Color of the opening arrow on the chart.
  ORDER_PARAM_COND_CLOSE,            // Close condition.
  ORDER_PARAM_COND_CLOSE_ARG_VALUE,  // Close condition arguments.
  ORDER_PARAM_COND_CLOSE_NUM,        // Number of close conditions.
  ORDER_PARAM_DUMMY,                 // Whether order is dummy.
  ORDER_PARAM_REFRESH_FREQ,          // How often to refresh order values (in secs).
  ORDER_PARAM_UPDATE_FREQ,           // How often to update order stops (in secs).
  FINAL_ENUM_ORDER_PARAM
};

/**
 * A variety of custom properties for reading order values.
 */
enum ENUM_ORDER_PROPERTY_CUSTOM {
  ORDER_PROP_NONE = 0,
  ORDER_PROP_COMMISSION,         // Commission.
  ORDER_PROP_LAST_ERROR,         // Last error code.
  ORDER_PROP_PRICE_CLOSE,        // Close price.
  ORDER_PROP_PRICE_OPEN,         // Open price.
  ORDER_PROP_PRICE_STOPLIMIT,    // The limit order price for the StopLimit order.
  ORDER_PROP_PROFIT,             // Current profit in price difference.
  ORDER_PROP_PROFIT_PIPS,        // Current profit in pips.
  ORDER_PROP_PROFIT_TOTAL,       // Total profit (profit minus fees).
  ORDER_PROP_PROFIT_VALUE,       // Total profit in base currency value.
  ORDER_PROP_REASON_CLOSE,       // Reason or source for closing an order.
  ORDER_PROP_TICKET,             // Ticket number.
  ORDER_PROP_TIME_CLOSED,        // Closed time.
  ORDER_PROP_TIME_OPENED,        // Opened time.
  ORDER_PROP_TIME_LAST_REFRESH,  // Last refresh of the order values.
  ORDER_PROP_TIME_LAST_UPDATE,   // Last update of the order values.
  ORDER_PROP_TOTAL_FEES,         // Total fees.
};

// Defines enumeration for order close reasons.
enum ENUM_ORDER_REASON_CLOSE {
  ORDER_REASON_CLOSED_ALL = 0,      // Closed all
  ORDER_REASON_CLOSED_BY_ACTION,    // Closed by action
  ORDER_REASON_CLOSED_BY_EXPIRE,    // Closed by expiration
  ORDER_REASON_CLOSED_BY_OPPOSITE,  // Closed by opposite order
  ORDER_REASON_CLOSED_BY_SIGNAL,    // Closed by signal
  ORDER_REASON_CLOSED_BY_SL,        // Closed by stop loss
  ORDER_REASON_CLOSED_BY_TEST,      // Closed by test
  ORDER_REASON_CLOSED_BY_TP,        // Closed by take profit
  ORDER_REASON_CLOSED_BY_USER,      // Closed by user
  ORDER_REASON_CLOSED_UNKNOWN,      // Closed by unknown event
};

#ifndef __MQL5__
/* Defines the reason for order placing. */
enum ENUM_ORDER_REASON {
  ORDER_REASON_CLIENT,  // The order was placed from a desktop terminal.
  ORDER_REASON_EXPERT,  // The order was placed from an MQL5-program (e.g. by an EA or a script).
  ORDER_REASON_MOBILE,  // The order was placed from a mobile application.
  ORDER_REASON_SL,      // The order was placed as a result of Stop Loss activation.
  ORDER_REASON_SO,      // The order was placed as a result of the Stop Out event.
  ORDER_REASON_TP,      // The order was placed as a result of Take Profit activation.
  ORDER_REASON_WEB,     // The order was placed from a web platform.
};
#endif

#ifndef __MQ4__
/**
 * Enumeration for order selection type.
 *
 * Notes:
 * - Enum has sense only in MQL5 and C++.
 */
enum ENUM_ORDER_SELECT_TYPE {
  ORDER_SELECT_TYPE_NONE,
  ORDER_SELECT_TYPE_ACTIVE,
  ORDER_SELECT_TYPE_HISTORY,
  ORDER_SELECT_TYPE_DEAL,
  ORDER_SELECT_TYPE_POSITION
};

/**
 * Enumeration for order data type.
 *
 * Notes:
 * - Enums has sense only in MQL5.
 */
enum ENUM_ORDER_SELECT_DATA_TYPE {
  ORDER_SELECT_DATA_TYPE_INTEGER,
  ORDER_SELECT_DATA_TYPE_DOUBLE,
  ORDER_SELECT_DATA_TYPE_STRING
};
#endif

#ifndef __MQL__
/**
 * Enumeration for OrderGetDouble() and HistoryOrderGetDouble().
 *
 * @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
 */
enum ENUM_ORDER_PROPERTY_DOUBLE {
  ORDER_VOLUME_INITIAL,  // Order initial volume.
  ORDER_VOLUME_CURRENT,  // Order current volume.
  ORDER_PRICE_OPEN,      // Price specified in the order.
  ORDER_SL,              // Stop Loss value.
  ORDER_TP,              // Take Profit value.
  ORDER_PRICE_CURRENT,   // The current price of the order symbol.
  ORDER_PRICE_STOPLIMIT  // The Limit order price for the StopLimit order.
};

/**
 * A variety of properties for reading order values.
 * Enumeration for OrderGetInteger() and HistoryOrderGetInteger().
 *
 * @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
 */
enum ENUM_ORDER_PROPERTY_INTEGER {
  ORDER_TICKET,           // Order ticket. Unique number assigned to each order.
  ORDER_TIME_SETUP,       // Order setup time.
  ORDER_TYPE,             // Order type.
  ORDER_STATE,            // Order state.
  ORDER_TIME_EXPIRATION,  // Order expiration time.
  ORDER_TIME_DONE,        // Order execution or cancellation time.
  ORDER_TIME_SETUP_MSC,   // The time of placing an order for execution in milliseconds since 01.01.1970.
  ORDER_TIME_DONE_MSC,    // Order execution/cancellation time in milliseconds since 01.01.1970.
  ORDER_TYPE_FILLING,     // Order filling type.
  ORDER_TYPE_TIME,        // Order lifetime.
  ORDER_MAGIC,            // ID of an Expert Advisor that has placed the order.
  ORDER_REASON,           // The reason or source for placing an order.
  ORDER_POSITION_ID,      // Position identifier that is set to an order as soon as it is executed.
  ORDER_POSITION_BY_ID    // Identifier of an opposite position used for closing by order ORDER_TYPE_CLOSE_BY.
};

/**
 * A variety of properties for reading order values.
 * Enumeration for OrderGetString() and HistoryOrderGetString().
 *
 * @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
 */
enum ENUM_ORDER_PROPERTY_STRING {
  ORDER_COMMENT,      // Order comment.
  ORDER_EXTERNAL_ID,  // Order identifier in an external trading system (on the Exchange).
  ORDER_SYMBOL,       // Symbol of the order.
};
#endif

/* Defines modes for order type values (Take Profit and Stop Loss). */
enum ENUM_ORDER_TYPE_VALUE { ORDER_TYPE_TP = ORDER_TP, ORDER_TYPE_SL = ORDER_SL };

#ifndef __MQL__
/**
 * Order operation type.
 *
 * @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
 */
enum ENUM_ORDER_TYPE {
  ORDER_TYPE_BUY,              // Market Buy order.
  ORDER_TYPE_SELL,             // Market Sell order.
  ORDER_TYPE_BUY_LIMIT,        // Buy Limit pending order.
  ORDER_TYPE_SELL_LIMIT,       // Sell Limit pending order.
  ORDER_TYPE_BUY_STOP,         // Buy Stop pending order
  ORDER_TYPE_SELL_STOP,        // Sell Stop pending order.
  ORDER_TYPE_BUY_STOP_LIMIT,   // Upon reaching the order price, a pending Buy Limit order is placed at the StopLimit
                               // price.
  ORDER_TYPE_SELL_STOP_LIMIT,  // Upon reaching the order price, a pending Sell Limit order is placed at the StopLimit
                               // price.
  ORDER_TYPE_CLOSE_BY          // Order to close a position by an opposite one.
};
#endif

/* Positions */

#ifndef __MQL5__
/**
 * Returns double type of the position property.
 *
 * @see:
 * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
 */
enum ENUM_POSITION_PROPERTY_DOUBLE {
  POSITION_PRICE_CURRENT,  // Current price of the position symbol (double).
  POSITION_PRICE_OPEN,     // Position open price (double).
  POSITION_PROFIT,         // Current profit (double).
  POSITION_SL,             // Stop Loss level of opened position (double).
  POSITION_SWAP,           // Cumulative swap (double).
  POSITION_TP,             // Take Profit level of opened position (double).
  POSITION_VOLUME,         // Position volume (double).
};

//#define POSITION_TICKET

/**
 * Returns integer type of the position property.
 *
 * @see:
 * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
 */
enum ENUM_POSITION_PROPERTY_INTEGER {
  POSITION_IDENTIFIER,       // A unique number assigned to each re-opened position (long).
  POSITION_MAGIC,            // Position magic number (see ORDER_MAGIC) (long).
  POSITION_REASON,           // The reason for opening a position (ENUM_POSITION_REASON).
  POSITION_TICKET,           // Unique number assigned to each newly opened position (long).
  POSITION_TIME,             // Position open time (datetime).
  POSITION_TIME_MSC,         // Position opening time in milliseconds since 01.01.1970 (long).
  POSITION_TIME_UPDATE,      // Position changing time (datetime).
  POSITION_TIME_UPDATE_MSC,  // Position changing time in milliseconds since 01.01.1970 (long).
  POSITION_TYPE,             // Position type (ENUM_POSITION_TYPE).
};

/**
 * Returns string type of the position property.
 *
 * @see:
 * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
 */
enum ENUM_POSITION_PROPERTY_STRING {
  POSITION_COMMENT,      // Position comment (string).
  POSITION_EXTERNAL_ID,  // Position identifier in an external trading system (on the Exchange) (string).
  POSITION_SYMBOL,       // Symbol of the position (string).
};

/**
 * Returns reason for opening a position.
 *
 * @see:
 * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
 */
enum ENUM_POSITION_REASON {
  POSITION_REASON_CLIENT,  // Order placed from a desktop terminal.
  POSITION_REASON_EXPERT,  // Order placed from an Expert.
  POSITION_REASON_MOBILE,  // Order placed from a mobile application.
  POSITION_REASON_WEB,     // Order placed from the web platform.
};

/**
 * Direction of an open position (buy or sell).
 *
 * @see:
 * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
 */
enum ENUM_POSITION_TYPE {
  POSITION_TYPE_BUY,  // Buy position.
  POSITION_TYPE_SELL  // Sell position.
};
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Order.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Account.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Account's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Account type of values for statistics. */
enum ENUM_ACC_STAT_VALUE {
  ACC_BALANCE = 0,
  ACC_CREDIT = 1,
  ACC_EQUITY = 2,
  ACC_PROFIT = 3,
  ACC_MARGIN_USED = 4,
  ACC_MARGIN_FREE = 5,
  FINAL_ENUM_ACC_STAT_VALUE = 6
};

/* Account type of periods for statistics. */
enum ENUM_ACC_STAT_PERIOD { ACC_DAILY = 0, ACC_WEEKLY = 1, ACC_MONTHLY = 2, FINAL_ENUM_ACC_STAT_PERIOD = 3 };

/* Account type of calculation for statistics. */
enum ENUM_ACC_STAT_TYPE { ACC_VALUE_MIN = 0, ACC_VALUE_MAX = 1, ACC_VALUE_AVG = 2, FINAL_ENUM_ACC_STAT_TYPE = 3 };

/* Account type of index for statistics. */
enum ENUM_ACC_STAT_INDEX { ACC_VALUE_CURR = 0, ACC_VALUE_PREV = 1, FINAL_ENUM_ACC_STAT_INDEX = 2 };

#ifndef __MQL__
/**
 * Enumeration for the current account double values.
 *
 * Used for function AccountInfoDouble().
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/accountinformation
 */
enum ENUM_ACCOUNT_INFO_DOUBLE {
  ACCOUNT_BALANCE,             // Account balance in the deposit currency (double).
  ACCOUNT_CREDIT,              // Account credit in the deposit currency (double).
  ACCOUNT_PROFIT,              // Current profit of an account in the deposit currency (double).
  ACCOUNT_EQUITY,              // Account equity in the deposit currency (double).
  ACCOUNT_MARGIN,              // Account margin used in the deposit currency (double).
  ACCOUNT_MARGIN_FREE,         // Free margin of an account in the deposit currency (double).
  ACCOUNT_MARGIN_LEVEL,        // Account margin level in percents (double).
  ACCOUNT_MARGIN_SO_CALL,      // Margin call level (double).
  ACCOUNT_MARGIN_SO_SO,        // Margin stop out level (double).
  ACCOUNT_MARGIN_INITIAL,      // Initial margin (double).
  ACCOUNT_MARGIN_MAINTENANCE,  // Maintenance margin (double).
  ACCOUNT_ASSETS,              // The current assets of an account (double).
  ACCOUNT_LIABILITIES,         // The current liabilities on an account (double).
  ACCOUNT_COMMISSION_BLOCKED,  // The current blocked commission amount on an account (double).
};

/**
 * Enumeration for the current account integer values.
 *
 * Used for function AccountInfoInteger().
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/accountinformation
 */
enum ENUM_ACCOUNT_INFO_INTEGER {
  ACCOUNT_LOGIN,            // Account number (long).
  ACCOUNT_TRADE_MODE,       // Account trade mode (ENUM_ACCOUNT_TRADE_MODE).
  ACCOUNT_LEVERAGE,         // Account leverage (long).
  ACCOUNT_LIMIT_ORDERS,     // Maximum allowed number of active pending orders (int).
  ACCOUNT_MARGIN_SO_MODE,   // Mode for setting the minimal allowed margin (ENUM_ACCOUNT_STOPOUT_MODE).
  ACCOUNT_TRADE_ALLOWED,    // Allowed trade for the current account (bool).
  ACCOUNT_TRADE_EXPERT,     // Allowed trade for an Expert Advisor (bool).
  ACCOUNT_MARGIN_MODE,      // Margin calculation mode (ENUM_ACCOUNT_MARGIN_MODE).
  ACCOUNT_CURRENCY_DIGITS,  // The number of decimal places in the account currency (int).
  ACCOUNT_FIFO_CLOSE,       // An indication showing that positions can only be closed by FIFO rule (bool).
};

/**
 * Enumeration for the current account string values.
 *
 * Used for function AccountInfoString().
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/accountinformation
 */
enum ENUM_ACCOUNT_INFO_STRING {
  ACCOUNT_NAME,      // Client name (string).
  ACCOUNT_SERVER,    // Trade server name (string).
  ACCOUNT_CURRENCY,  // Account currency (string).
  ACCOUNT_COMPANY,   // Name of a company that serves the account (string).
};

/**
 * Enumeration for the margin modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/accountinformation
 */
enum ENUM_ACCOUNT_MARGIN_MODE {
  ACCOUNT_MARGIN_MODE_RETAIL_NETTING,  // Used for the OTC markets to interpret positions in the "netting" mode.
  ACCOUNT_MARGIN_MODE_EXCHANGE,        // Used for the exchange markets.
  ACCOUNT_MARGIN_MODE_RETAIL_HEDGING,  // Used for the exchange markets where individual positions are possible.
};

/**
 * Enumeration for the types of accounts on a trade server.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/accountinformation
 */
enum ENUM_ACCOUNT_TRADE_MODE {
  ACCOUNT_TRADE_MODE_DEMO,     // Demo account.
  ACCOUNT_TRADE_MODE_CONTEST,  // Contest account.
  ACCOUNT_TRADE_MODE_REAL,     // Real account.
};

/**
 * Enumeration for the Stop Out modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/accountinformation
 */
enum ENUM_ACCOUNT_STOPOUT_MODE {
  ACCOUNT_STOPOUT_MODE_PERCENT,  // Account stop out mode in percents.
  ACCOUNT_STOPOUT_MODE_MONEY,    // Account stop out mode in money.
};
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Account.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SymbolInfo.struct.static.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Std.h
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: sstream
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: locale
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: iomanip
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: vector
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Data types.
#ifdef __cplusplus





// Data types.
typedef std::string string;
typedef unsigned int uint;
typedef unsigned long datetime;
typedef unsigned long ulong;
typedef unsigned short ushort;
#endif

#ifdef __MQL__
#define ASSIGN_TO_THIS(TYPE, VALUE) ((TYPE)this) = ((TYPE)VALUE)
#else
#define ASSIGN_TO_THIS(TYPE, VALUE) ((TYPE&)this) = ((TYPE&)VALUE)
#endif

// Pointers.
#ifdef __MQL__
#define THIS_PTR (&this)
#define THIS_REF this
#define PTR_ATTRIB(O, A) O.A
#define PTR_TO_REF(PTR) PTR
#define MAKE_REF_FROM_PTR(TYPE, NAME, PTR) TYPE* NAME = PTR
#else
#define THIS_PTR (this)
#define THIS_REF (*this)
#define PTR_ATTRIB(O, A) O->A
#define PTR_TO_REF(PTR) (*PTR)
#define MAKE_REF_FROM_PTR(TYPE, NAME, PTR) TYPE& NAME = PTR
#endif

// References.
#ifdef __cplusplus
#define REF(X) (&X)
#else
#define REF(X) X&
#endif

// Arrays and references to arrays.
#ifdef __MQL__
#define ARRAY_DECLARATION_BRACKETS []
#else
// C++'s _cpp_array is an object, so no brackets are nedded.
#define ARRAY_DECLARATION_BRACKETS
#endif

#ifdef __MQL__
/**
 * Reference to the array.
 *
 * @usage
 *   ARRAY_REF(<type of the array items>, <name of the variable>)
 */
#define ARRAY_REF(T, N) REF(T) N ARRAY_DECLARATION_BRACKETS

/**
 * Array definition.
 *
 * @usage
 *   ARRAY(<type of the array items>, <name of the variable>)
 */
#define ARRAY(T, N) T N[];

#else

/**

 * Reference to the array.
 *
 * @usage
 *   ARRAY_REF(<type of the array items>, <name of the variable>)
 */
#define ARRAY_REF(T, N) _cpp_array<T>& N

/**
 * Array definition.
 *
 * @usage
 *   ARRAY(<type of the array items>, <name of the variable>)
 */
#define ARRAY(T, N) ::_cpp_array<T> N
#endif

// typename(T)
#ifndef __MQL__
#define typename(T) typeid(T).name()
#endif

// C++ array class.
#ifndef __MQL__
/**
 * Custom array template to be used as a replacement of dynamic array in MQL.
 */
template <typename T>
class _cpp_array {
  // List of items.
  std::vector<T> m_data;

  // IsSeries flag.
  bool m_isSeries = false;

 public:
  _cpp_array() {}

  template <int size>
  _cpp_array(const T REF(_arr)[size]) {
    for (const auto& _item : _arr) m_data.push_back(_item);
  }

  /**
   * Returns pointer of first element (provides a way to iterate over array elements).
   */
  // operator T*() { return &m_data.first(); }

  /**
   * Index operator. Takes care of IsSeries flag.
   */
  T& operator[](int index) { return m_data[m_isSeries ? (size() - index - 1) : index]; }

  /**
   * Index operator. Takes care of IsSeries flag.
   */
  const T& operator[](int index) const { return m_data[m_isSeries ? (size() - index - 1) : index]; }

  /**
   * Returns number of elements in the array.
   */
  int size() const { return m_data.size(); }

  /**
   * Checks whether
   */
  int getIsSeries() const { return m_isSeries; }

  /**
   * Sets IsSeries flag for an array.
   * Array indexing is from 0 without IsSeries flag or from last-element
   * with IsSeries flag.
   */
  void setIsSeries(bool _isSeries) { m_isSeries = _isSeries; }
};

template <typename T>
class _cpp_array;
#endif

// Mql's color class.
#ifndef __MQL__
class color {
  unsigned int value;

 public:
  color(unsigned int _color) { value = _color; }
  color& operator=(unsigned int _color) {
    value = _color;
    return *this;
  }
  operator unsigned int() const { return value; }
};
#endif

// GetPointer(ptr).
#ifndef __MQL__
unsigned int GetPointer(void* _ptr) { return (unsigned int)_ptr; }
#endif

// MQL defines.
#ifndef __MQL__
#define WHOLE_ARRAY -1  // For processing the entire array.
#endif

// Converts string into C++-style string pointer.
#ifdef __MQL__
#define C_STR(S) S
#else
#define C_STR(S) cstring_from(S)

const char* cstring_from(const std::string& _value) { return _value.c_str(); }
#endif

/**
 * Referencing struct's enum.
 *
 * @usage
 *   STRUCT_ENUM(<struct_name>, <enum_name>)
 */
#ifdef __MQL4__
#define STRUCT_ENUM(S, E) E
#else
#define STRUCT_ENUM(S, E) S::E
#endif

#ifndef __MQL__
/**
 * @file
 * Includes MQL-compatible enumerations.
 */
enum ENUM_TRADE_REQUEST_ACTIONS {
  // @see: https://www.mql5.com/en/docs/constants/tradingconstants/enum_trade_request_actions
  TRADE_ACTION_DEAL,     // Place a trade order for an immediate execution with the specified parameters (market order).
  TRADE_ACTION_PENDING,  // Place a trade order for the execution under specified conditions (pending order).
  TRADE_ACTION_SLTP,     // Modify Stop Loss and Take Profit values of an opened position.
  TRADE_ACTION_MODIFY,   // Modify the parameters of the order placed previously.
  TRADE_ACTION_REMOVE,   // Delete the pending order placed previously.
  TRADE_ACTION_CLOSE_BY  // Close a position by an opposite one.
};
// Fill Policy.
enum ENUM_SYMBOL_FILLING {
  // @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
  SYMBOL_FILLING_FOK = 1,  // A deal can be executed only with the specified volume.
  SYMBOL_FILLING_IOC = 2   // Trader agrees to execute a deal with the volume maximally available in the market.
};
enum ENUM_ORDER_TYPE_FILLING {
  // @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
  ORDER_FILLING_FOK,    // An order can be filled only in the specified amount.
  ORDER_FILLING_IOC,    // A trader agrees to execute a deal with the volume maximally available in the market.
  ORDER_FILLING_RETURN  // In case of partial filling a market or limit order with remaining volume is not canceled but
                        // processed further.
};
enum ENUM_ORDER_TYPE_TIME {
  // @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
  ORDER_TIME_GTC,           // Good till cancel order.
  ORDER_TIME_DAY,           // Good till current trade day order.
  ORDER_TIME_SPECIFIED,     // Good till expired order.
  ORDER_TIME_SPECIFIED_DAY  // The order will be effective till 23:59:59 of the specified day.
};
// An order status that describes its state.
enum ENUM_ORDER_STATE {
  ORDER_STATE_STARTED,         // Order checked, but not yet accepted by broker
  ORDER_STATE_PLACED,          // Order accepted
  ORDER_STATE_CANCELED,        // Order canceled by client
  ORDER_STATE_PARTIAL,         // Order partially executed
  ORDER_STATE_FILLED,          // Order fully executed
  ORDER_STATE_REJECTED,        // Order rejected
  ORDER_STATE_EXPIRED,         // Order expired
  ORDER_STATE_REQUEST_ADD,     // Order is being registered (placing to the trading system)
  ORDER_STATE_REQUEST_MODIFY,  // Order is being modified (changing its parameters)
  ORDER_STATE_REQUEST_CANCEL   // Order is being deleted (deleting from the trading system)
};

// @see: https://www.mql5.com/en/docs/constants/structures/mqltraderequest
struct MqlTradeRequest {
  ENUM_TRADE_REQUEST_ACTIONS action;     // Trade operation type.
  ulong magic;                           // Expert Advisor ID (magic number).
  ulong order;                           // Order ticket.
  string symbol;                         // Trade symbol.
  double volume;                         // Requested volume for a deal in lots.
  double price;                          // Price.
  double stoplimit;                      // StopLimit level of the order.
  double sl;                             // Stop Loss level of the order.
  double tp;                             // Take Profit level of the order.
  ulong deviation;                       // Maximal possible deviation from the requested price.
  ENUM_ORDER_TYPE type;                  // Order type.
  ENUM_ORDER_TYPE_FILLING type_filling;  // Order execution type.
  ENUM_ORDER_TYPE_TIME type_time;        // Order expiration type.
  datetime expiration;                   // Order expiration time (for the orders of ORDER_TIME_SPECIFIED type.
  string comment;                        // Order comment.
  ulong position;                        // Position ticket.
  ulong position_by;                     // The ticket of an opposite position.
};
// @see: https://www.mql5.com/en/docs/constants/structures/mqltraderesult
struct MqlTradeResult {
  uint retcode;     // Operation return code.
  ulong deal;       // Deal ticket, if it is performed.
  ulong order;      // Order ticket, if it is placed.
  double volume;    // Deal volume, confirmed by broker.
  double price;     // Deal price, confirmed by broker.
  double bid;       // Current Bid price.
  double ask;       // Current Ask price.
  string comment;   // Broker comment to operation (by default it is filled by description of trade server return code).
  uint request_id;  // Request ID set by the terminal during the dispatch.
  uint retcode_external;  // Return code of an external trading system.
};

#define ERR_USER_ERROR_FIRST 65536  // User defined errors start with this code.

#define AliceBlue 0xFFF8F0
#define AntiqueWhite 0xD7EBFA
#define Aqua 0xFFFF00
#define Aquamarine 0xD4FF7F
#define Beige 0xDCF5F5
#define Bisque 0xC4E4FF
#define Black 0x000000
#define BlanchedAlmond 0xCDEBFF
#define Blue 0xFF0000
#define BlueViolet 0xE22B8A
#define Brown 0x2A2AA5
#define BurlyWood 0x87B8DE
#define CadetBlue 0xA09E5F
#define Chartreuse 0x00FF7F
#define Chocolate 0x1E69D2
#define Coral 0x507FFF
#define CornflowerBlue 0xED9564
#define Cornsilk 0xDCF8FF
#define Crimson 0x3C14DC
#define DarkBlue 0x8B0000
#define DarkGoldenrod 0x0B86B8
#define DarkGray 0xA9A9A9
#define DarkGreen 0x006400
#define DarkKhaki 0x6BB7BD
#define DarkOliveGreen 0x2F6B55
#define DarkOrange 0x008CFF
#define DarkOrchid 0xCC3299
#define DarkSalmon 0x7A96E9
#define DarkSeaGreen 0x8BBC8F
#define DarkSlateBlue 0x8B3D48
#define DarkSlateGray 0x4F4F2F
#define DarkTurquoise 0xD1CE00
#define DarkViolet 0xD30094
#define DeepPink 0x9314FF
#define DeepSkyBlue 0xFFBF00
#define DimGray 0x696969
#define DodgerBlue 0xFF901E
#define FireBrick 0x2222B2
#define ForestGreen 0x228B22
#define Gainsboro 0xDCDCDC
#define Gold 0x00D7FF
#define Goldenrod 0x20A5DA
#define Gray 0x808080
#define Green 0x008000
#define GreenYellow 0x2FFFAD
#define Honeydew 0xF0FFF0
#define HotPink 0xB469FF
#define IndianRed 0x5C5CCD
#define Indigo 0x82004B
#define Ivory 0xF0FFFF
#define Khaki 0x8CE6F0
#define Lavender 0xFAE6E6
#define LavenderBlush 0xF5F0FF
#define LawnGreen 0x00FC7C
#define LemonChiffon 0xCDFAFF
#define LightBlue 0xE6D8AD
#define LightCoral 0x8080F0
#define LightCyan 0xFFFFE0
#define LightGoldenrod 0xD2FAFA
#define LightGray 0xD3D3D3
#define LightGreen 0x90EE90
#define LightPink 0xC1B6FF
#define LightSalmon 0x7AA0FF
#define LightSeaGreen 0xAAB220
#define LightSkyBlue 0xFACE87
#define LightSlateGray 0x998877
#define LightSteelBlue 0xDEC4B0
#define LightYellow 0xE0FFFF
#define Lime 0x00FF00
#define LimeGreen 0x32CD32
#define Linen 0xE6F0FA
#define Magenta 0xFF00FF
#define Maroon 0x000080
#define MediumAquamarine 0xAACD66
#define MediumBlue 0xCD0000
#define MediumOrchid 0xD355BA
#define MediumPurple 0xDB7093
#define MediumSeaGreen 0x71B33C
#define MediumSlateBlue 0xEE687B
#define MediumSpringGreen 0x9AFA00
#define MediumTurquoise 0xCCD148
#define MediumVioletRed 0x8515C7
#define MidnightBlue 0x701919
#define MintCream 0xFAFFF5
#define MistyRose 0xE1E4FF
#define Moccasin 0xB5E4FF
#define NavajoWhite 0xADDEFF
#define Navy 0x800000
#define OldLace 0xE6F5FD
#define Olive 0x008080
#define OliveDrab 0x238E6B
#define Orange 0x00A5FF
#define OrangeRed 0x0045FF
#define Orchid 0xD670DA
#define PaleGoldenrod 0xAAE8EE
#define PaleGreen 0x98FB98
#define PaleTurquoise 0xEEEEAF
#define PaleVioletRed 0x9370DB
#define PapayaWhip 0xD5EFFF
#define PeachPuff 0xB9DAFF
#define Peru 0x3F85CD
#define Pink 0xCBC0FF
#define Plum 0xDDA0DD
#define PowderBlue 0xE6E0B0
#define Purple 0x800080
#define Red 0x0000FF
#define RosyBrown 0x8F8FBC
#define RoyalBlue 0xE16941
#define SaddleBrown 0x13458B
#define Salmon 0x7280FA
#define SandyBrown 0x60A4F4
#define SeaGreen 0x578B2E
#define Seashell 0xEEF5FF
#define Sienna 0x2D52A0
#define Silver 0xC0C0C0
#define SkyBlue 0xEBCE87
#define SlateBlue 0xCD5A6A
#define SlateGray 0x908070
#define Snow 0xFAFAFF
#define SpringGreen 0x7FFF00
#define SteelBlue 0xB48246
#define Tan 0x8CB4D2
#define Teal 0x808000
#define Thistle 0xD8BFD8
#define Tomato 0x4763FF
#define Turquoise 0xD0E040
#define Violet 0xEE82EE
#define Wheat 0xB3DEF5
#define White 0xFFFFFF
#define WhiteSmoke 0xF5F5F5
#define Yellow 0x00FFFF
#define YellowGreen 0x32CD9A
#define clrNONE -1
#define CLR_NONE -1

// Additional enum values for ENUM_SYMBOL_INFO_DOUBLE
#define SYMBOL_MARGIN_LIMIT ((ENUM_SYMBOL_INFO_DOUBLE)46)
#define SYMBOL_MARGIN_MAINTENANCE ((ENUM_SYMBOL_INFO_DOUBLE)43)
#define SYMBOL_MARGIN_LONG ((ENUM_SYMBOL_INFO_DOUBLE)44)
#define SYMBOL_MARGIN_SHORT ((ENUM_SYMBOL_INFO_DOUBLE)45)
#define SYMBOL_MARGIN_STOP ((ENUM_SYMBOL_INFO_DOUBLE)47)
#define SYMBOL_MARGIN_STOPLIMIT ((ENUM_SYMBOL_INFO_DOUBLE)48)

#define TRADE_RETCODE_REQUOTE 10004             // Requote
#define TRADE_RETCODE_REJECT 10006              // Request rejected
#define TRADE_RETCODE_CANCEL 10007              // Request canceled by trader
#define TRADE_RETCODE_PLACED 10008              // Order placed
#define TRADE_RETCODE_DONE 10009                // Request completed
#define TRADE_RETCODE_DONE_PARTIAL 10010        // Only part of the request was completed
#define TRADE_RETCODE_ERROR 10011               // Request processing error
#define TRADE_RETCODE_TIMEOUT 10012             // Request canceled by timeout
#define TRADE_RETCODE_INVALID 10013             // Invalid request
#define TRADE_RETCODE_INVALID_VOLUME 10014      // Invalid volume in the request
#define TRADE_RETCODE_INVALID_PRICE 10015       // Invalid price in the request
#define TRADE_RETCODE_INVALID_STOPS 10016       // Invalid stops in the request
#define TRADE_RETCODE_TRADE_DISABLED 10017      // Trade is disabled
#define TRADE_RETCODE_MARKET_CLOSED 10018       // Market is closed
#define TRADE_RETCODE_NO_MONEY 10019            // There is not enough money to complete the request
#define TRADE_RETCODE_PRICE_CHANGED 10020       // Prices changed
#define TRADE_RETCODE_PRICE_OFF 10021           // There are no quotes to process the request
#define TRADE_RETCODE_INVALID_EXPIRATION 10022  // Invalid order expiration date in the request
#define TRADE_RETCODE_ORDER_CHANGED 10023       // Order state changed
#define TRADE_RETCODE_TOO_MANY_REQUESTS 10024   // Too frequent requests
#define TRADE_RETCODE_NO_CHANGES 10025          // No changes in request
#define TRADE_RETCODE_SERVER_DISABLES_AT 10026  // Autotrading disabled by server
#define TRADE_RETCODE_CLIENT_DISABLES_AT 10027  // Autotrading disabled by client terminal
#define TRADE_RETCODE_LOCKED 10028              // Request locked for processing
#define TRADE_RETCODE_FROZEN 10029              // Order or position frozen
#define TRADE_RETCODE_INVALID_FILL 10030        // Invalid order filling type
#define TRADE_RETCODE_CONNECTION 10031          // No connection with the trade server
#define TRADE_RETCODE_ONLY_REAL 10032           // Operation is allowed only for live accounts
#define TRADE_RETCODE_LIMIT_ORDERS 10033        // The number of pending orders has reached the limit
#define TRADE_RETCODE_LIMIT_VOLUME 10034     // The volume of orders and positions for the symbol has reached the limit
#define TRADE_RETCODE_INVALID_ORDER 10035    // Incorrect or prohibited order type
#define TRADE_RETCODE_POSITION_CLOSED 10036  // Position with the specified POSITION_IDENTIFIER has already been closed
#define TRADE_RETCODE_INVALID_CLOSE_VOLUME 10038  // A close volume exceeds the current position volume
#define TRADE_RETCODE_CLOSE_ORDER_EXIST 10039     // A close order already exists.
#define TRADE_RETCODE_LIMIT_POSITIONS 10040  // The number of open positions can be limited (e.g. Netting, Hedging).
#endif

#ifndef __MQL__
// Converter of NULL_VALUE into expected type. e.g., "int x = NULL_VALUE" will end up with "x = 0".
struct _NULL_VALUE {
  template <typename T>
  explicit operator T() const {
    return (T)0;
  }
} NULL_VALUE;

template <>
inline _NULL_VALUE::operator const std::string() const {
  return "";
}
#else
#define NULL_VALUE NULL
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Std.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: MqlTick.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * MqlTick structure.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

#ifndef __MQL__
/**
 * Structure for storing the latest prices of the symbol.
 * @docs
 * https://www.mql5.com/en/docs/constants/structures/mqltick
 */
struct MqlTick {
  datetime time;         // Time of the last prices update.
  double ask;            // Current Ask price.
  double bid;            // Current Bid price.
  double last;           // Price of the last deal (last).
  double volume_real;    // Volume for the current last price with greater accuracy.
  long time_msc;         // Time of a price last update in milliseconds.
  unsigned int flags;    // Tick flags.
  unsigned long volume;  // Volume for the current last price.
};
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: MqlTick.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: MQL5.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Provides forward compatibility for MQL5 in MT4/MQL4.
 */

// Prevents processing this includes file for the second time.
#ifndef MQL5_MQH
#define MQL5_MQH

//+------------------------------------------------------------------+
//| Declaration of constants
//+------------------------------------------------------------------+

// Missing error handling constants in MQL4.
// @see: https://docs.mql4.com/constants/errorswarnings/errorcodes
// @see: https://www.mql5.com/en/docs/constants/errorswarnings
#ifdef __MQL4__
// Return codes of the trade server.
#define TRADE_RETCODE_REQUOTE              10004 // Requote
#define TRADE_RETCODE_REJECT               10006 // Request rejected
#define TRADE_RETCODE_CANCEL               10007 // Request canceled by trader
#define TRADE_RETCODE_PLACED               10008 // Order placed
#define TRADE_RETCODE_DONE                 10009 // Request completed
#define TRADE_RETCODE_DONE_PARTIAL         10010 // Only part of the request was completed
#define TRADE_RETCODE_ERROR                10011 // Request processing error
#define TRADE_RETCODE_TIMEOUT              10012 // Request canceled by timeout
#define TRADE_RETCODE_INVALID              10013 // Invalid request
#define TRADE_RETCODE_INVALID_VOLUME       10014 // Invalid volume in the request
#define TRADE_RETCODE_INVALID_PRICE        10015 // Invalid price in the request
#define TRADE_RETCODE_INVALID_STOPS        10016 // Invalid stops in the request
#define TRADE_RETCODE_TRADE_DISABLED       10017 // Trade is disabled
#define TRADE_RETCODE_MARKET_CLOSED        10018 // Market is closed
#define TRADE_RETCODE_NO_MONEY             10019 // There is not enough money to complete the request
#define TRADE_RETCODE_PRICE_CHANGED        10020 // Prices changed
#define TRADE_RETCODE_PRICE_OFF            10021 // There are no quotes to process the request
#define TRADE_RETCODE_INVALID_EXPIRATION   10022 // Invalid order expiration date in the request
#define TRADE_RETCODE_ORDER_CHANGED        10023 // Order state changed
#define TRADE_RETCODE_TOO_MANY_REQUESTS    10024 // Too frequent requests
#define TRADE_RETCODE_NO_CHANGES           10025 // No changes in request
#define TRADE_RETCODE_SERVER_DISABLES_AT   10026 // Autotrading disabled by server
#define TRADE_RETCODE_CLIENT_DISABLES_AT   10027 // Autotrading disabled by client terminal
#define TRADE_RETCODE_LOCKED               10028 // Request locked for processing
#define TRADE_RETCODE_FROZEN               10029 // Order or position frozen
#define TRADE_RETCODE_INVALID_FILL         10030 // Invalid order filling type
#define TRADE_RETCODE_CONNECTION           10031 // No connection with the trade server
#define TRADE_RETCODE_ONLY_REAL            10032 // Operation is allowed only for live accounts
#define TRADE_RETCODE_LIMIT_ORDERS         10033 // The number of pending orders has reached the limit
#define TRADE_RETCODE_LIMIT_VOLUME         10034 // The volume of orders and positions for the symbol has reached the limit
#define TRADE_RETCODE_INVALID_ORDER        10035 // Incorrect or prohibited order type
#define TRADE_RETCODE_POSITION_CLOSED      10036 // Position with the specified POSITION_IDENTIFIER has already been closed
#define TRADE_RETCODE_INVALID_CLOSE_VOLUME 10038 // A close volume exceeds the current position volume
#define TRADE_RETCODE_CLOSE_ORDER_EXIST    10039 // A close order already exists.
#define TRADE_RETCODE_LIMIT_POSITIONS      10040 // The number of open positions can be limited (e.g. Netting, Hedging).
#endif
// Runtime Errors (@see: https://www.mql5.com/en/docs/constants/errorswarnings/errorcodes)
// General error codes.
#ifndef ERR_SUCCESS
#define ERR_SUCCESS                            0 // The operation completed successfully.
#endif
#define ERR_NO_MQLERROR                     4000
#ifndef ERR_INTERNAL_ERROR
#define ERR_INTERNAL_ERROR                  4001 // Operating system error.
#endif
#define ERR_WRONG_INTERNAL_PARAMETER        4002 // Wrong parameter in the inner call of the client terminal function.
//#define ERR_INVALID_PARAMETER               4003 // Wrong parameter when calling the system function.
#define ERR_NOT_ENOUGH_MEMORY               4004 // Not enough memory to perform the system function.
#define ERR_STRUCT_WITHOBJECTS_ORCLASS      4005 // The structure contains objects of strings and/or dynamic arrays and/or structure of such objects and/or classes.
#define ERR_INVALID_ARRAY                   4006 // Array of a wrong type, wrong size, or a damaged object of a dynamic array.
#define ERR_ARRAY_RESIZE_ERROR              4007 // Not enough memory for the relocation of an array, or an attempt to change the size of a static array.
#define ERR_STRING_RESIZE_ERROR             4008 // Not enough memory for the relocation of string.
#define ERR_NOTINITIALIZED_STRING           4009 // Not initialized string.
#define ERR_INVALID_DATETIME                4010 // Invalid date and/or time.
#define ERR_ARRAY_BAD_SIZE                  4011 // Requested array size exceeds 2 GB.
#ifndef ERR_INVALID_POINTER
#define ERR_INVALID_POINTER                 4012 // Wrong pointer.
#endif
#define ERR_INVALID_POINTER_TYPE            4013 // Wrong type of pointer.
#define ERR_FUNCTION_NOT_ALLOWED            4014 // Function is not allowed for call.
#define ERR_RESOURCE_NAME_DUPLICATED        4015 // The names of the dynamic and the static resource match.
#ifndef ERR_RESOURCE_NOT_FOUND
#define ERR_RESOURCE_NOT_FOUND              4016 // Resource with this name has not been found in EX5.
#endif
#define ERR_RESOURCE_UNSUPPOTED_TYPE        4017 // Unsupported resource type or its size exceeds 16 Mb.
#define ERR_RESOURCE_NAME_IS_TOO_LONG       4018 // The resource name exceeds 63 characters.
// Charts.
#define ERR_CHART_WRONG_ID                  4101 // Wrong chart ID.
#define ERR_CHART_NO_REPLY                  4102 // Chart does not respond.
#ifndef ERR_CHART_NOT_FOUND
#define ERR_CHART_NOT_FOUND                 4103 // Chart not found.
#endif
#define ERR_CHART_NO_EXPERT                 4104 // No Expert Advisor in the chart that could handle the event.
#define ERR_CHART_CANNOT_OPEN               4105 // Chart opening error.
#define ERR_CHART_CANNOT_CHANGE             4106 // Failed to change chart symbol and period.
#define ERR_CHART_WRONG_PARAMETER           4107 // Error value of the parameter for the function of working with charts.
#define ERR_CHART_CANNOT_CREATE_TIMER       4108 // Failed to create timer.
#define ERR_CHART_WRONG_PROPERTY            4109 // Wrong chart property ID.
#define ERR_CHART_SCREENSHOT_FAILED         4110 // Error creating screenshots.
#define ERR_CHART_NAVIGATE_FAILED           4111 // Error navigating through chart.
#define ERR_CHART_TEMPLATE_FAILED           4112 // Error applying template.
#define ERR_CHART_WINDOW_NOT_FOUND          4113 // Subwindow containing the indicator was not found.
#define ERR_CHART_INDICATOR_CANNOT_ADD      4114 // Error adding an indicator to chart.
#define ERR_CHART_INDICATOR_CANNOT_DEL      4115 // Error deleting an indicator from the chart.
#define ERR_CHART_INDICATOR_NOT_FOUND       4116 // Indicator not found on the specified chart.
// Graphical Objects.
#define ERR_OBJECT_ERROR                    4201 // Error working with a graphical object.
#define ERR_OBJECT_NOT_FOUND                4202 // Graphical object was not found.
#define ERR_OBJECT_WRONG_PROPERTY           4203 // Wrong ID of a graphical object property.
#define ERR_OBJECT_GETDATE_FAILED           4204 // Unable to get date corresponding to the value.
#define ERR_OBJECT_GETVALUE_FAILED          4205 // Unable to get value corresponding to the date.
// MarketInfo.
#define ERR_MARKET_UNKNOWN_SYMBOL           4301 // Unknown symbol.
#define ERR_MARKET_NOT_SELECTED             4302 // Symbol is not selected in MarketWatch.
#define ERR_MARKET_WRONG_PROPERTY           4303 // Wrong identifier of a symbol property.
#define ERR_MARKET_LASTTIME_UNKNOWN         4304 // Time of the last tick is not known (no ticks).
#define ERR_MARKET_SELECT_ERROR             4305 // Error adding or deleting a symbol in MarketWatch.
// History Access.
#define ERR_HISTORY_NOT_FOUND               4401 // Requested history not found.
#define ERR_HISTORY_WRONG_PROPERTY          4402 // Wrong ID of the history property.
#define ERR_HISTORY_TIMEOUT                 4403 // Exceeded history request timeout.
#define ERR_HISTORY_BARS_LIMIT              4404 // Number of requested bars limited by terminal settings.
#define ERR_HISTORY_LOAD_ERRORS             4405 // Multiple errors when loading history.
#define ERR_HISTORY_SMALL_BUFFER            4407 // Receiving array is too small to store all requested data.
// Global_Variables.
#define ERR_GLOBALVARIABLE_NOT_FOUND        4501 // Global variable of the client terminal is not found.
#define ERR_GLOBALVARIABLE_EXISTS           4502 // Global variable of the client terminal with the same name already exists.
#define ERR_MAIL_SEND_FAILED                4510 // Email sending failed.
#define ERR_PLAY_SOUND_FAILED               4511 // Sound playing failed.
#define ERR_MQL5_WRONG_PROPERTY             4512 // Wrong identifier of the program property.
#define ERR_TERMINAL_WRONG_PROPERTY         4513 // Wrong identifier of the terminal property.
#define ERR_FTP_SEND_FAILED                 4514 // File sending via ftp failed.
#define ERR_NOTIFICATION_SEND_FAILED        4515 // Failed to send a notification.
#define ERR_NOTIFICATION_WRONG_PARAMETER    4516 // Invalid parameter for sending a notification - an empty string or NULL has been passed to the SendNotification() function.
#define ERR_NOTIFICATION_WRONG_SETTINGS     4517 // Wrong settings of notifications in the terminal (ID is not specified or permission is not set).
#ifndef ERR_NOTIFICATION_TOO_FREQUENT
#define ERR_NOTIFICATION_TOO_FREQUENT       4518 // Too frequent sending of notifications.
#endif
#ifndef ERR_FTP_NOSERVER
#define ERR_FTP_NOSERVER                    4519 // FTP server is not specified.
#endif
#ifndef ERR_FTP_NOLOGIN
#define ERR_FTP_NOLOGIN                     4520 // FTP login is not specified.
#endif
#ifndef ERR_FTP_FILE_ERROR
#define ERR_FTP_FILE_ERROR                  4521 // File not found in the MQL5\Files directory to send on FTP server.
#endif
#ifndef ERR_FTP_CONNECT_FAILED
#define ERR_FTP_CONNECT_FAILED              4522 // FTP connection failed.
#endif
#ifndef ERR_FTP_CHANGEDIR
#define ERR_FTP_CHANGEDIR                   4523 // FTP path not found on server.
#endif
#ifndef ERR_FTP_CLOSED
#define ERR_FTP_CLOSED                      4524 // FTP connection closed.
#endif
// Custom Indicator Buffers.
#define ERR_BUFFERS_NO_MEMORY               4601 // Not enough memory for the distribution of indicator buffers.
#define ERR_BUFFERS_WRONG_INDEX             4602 // Wrong indicator buffer index.
// Custom Indicator Properties.
#define ERR_CUSTOM_WRONG_PROPERTY           4603 // Wrong ID of the custom indicator property.
// Account.
#define ERR_ACCOUNT_WRONG_PROPERTY          4701 // Wrong account property ID.
#define ERR_TRADE_WRONG_PROPERTY            4751 // Wrong trade property ID.
#ifndef ERR_TRADE_DISABLED
#define ERR_TRADE_DISABLED                  4752 // Trading by Expert Advisors prohibited.
#endif
#define ERR_TRADE_POSITION_NOT_FOUND        4753 // Position not found.
#define ERR_TRADE_ORDER_NOT_FOUND           4754 // Order not found.
#define ERR_TRADE_DEAL_NOT_FOUND            4755 // Deal not found.
#define ERR_TRADE_SEND_FAILED               4756 // Trade request sending failed.
// Indicators.
#define ERR_INDICATOR_UNKNOWN_SYMBOL        4801 // Unknown symbol.
#define ERR_INDICATOR_CANNOT_CREATE         4802 // Indicator cannot be created.
#define ERR_INDICATOR_NO_MEMORY             4803 // Not enough memory to add the indicator.
#define ERR_INDICATOR_CANNOT_APPLY          4804 // The indicator cannot be applied to another indicator.
#define ERR_INDICATOR_CANNOT_ADD            4805 // Error applying an indicator to chart.
#define ERR_INDICATOR_DATA_NOT_FOUND        4806 // Requested data not found.
#define ERR_INDICATOR_WRONG_HANDLE          4807 // Wrong indicator handle.
#define ERR_INDICATOR_WRONG_PARAMETERS      4808 // Wrong number of parameters when creating an indicator.
#define ERR_INDICATOR_PARAMETERS_MISSING    4809 // No parameters when creating an indicator.
#define ERR_INDICATOR_CUSTOM_NAME           4810 // The first parameter in the array must be the name of the custom indicator.
#define ERR_INDICATOR_PARAMETER_TYPE        4811 // Invalid parameter type in the array when creating an indicator.
#define ERR_INDICATOR_WRONG_INDEX           4812 // Wrong index of the requested indicator buffer.
// Depth of Market.
#define ERR_BOOKS_CANNOT_ADD                4901 // Depth Of Market can not be added.
#define ERR_BOOKS_CANNOT_DELETE             4902 // Depth Of Market can not be removed.
#define ERR_BOOKS_CANNOT_GET                4903 // The data from Depth Of Market can not be obtained.
#define ERR_BOOKS_CANNOT_SUBSCRIBE          4904 // Error in subscribing to receive new data from Depth Of Market.
// File Operations.
#define ERR_TOO_MANY_FILES                  5001 // More than 64 files cannot be opened at the same time.
#define ERR_WRONG_FILENAME                  5002 // Invalid file name.
#define ERR_TOO_LONG_FILENAME               5003 // Too long file name.
#ifndef ERR_CANNOT_OPEN_FILE
#define ERR_CANNOT_OPEN_FILE                5004 // File opening error.
#endif
#define ERR_FILE_CACHEBUFFER_ERROR          5005 // Not enough memory for cache to read.
#define ERR_CANNOT_DELETE_FILE              5006 // File deleting error.
#define ERR_INVALID_FILEHANDLE              5007 // A file with this handle was closed, or was not opening at all.
#define ERR_WRONG_FILEHANDLE                5008 // Wrong file handle.
#define ERR_FILE_NOTTOWRITE                 5009 // The file must be opened for writing.
#define ERR_FILE_NOTTOREAD                  5010 // The file must be opened for reading.
#define ERR_FILE_NOTBIN                     5011 // The file must be opened as a binary one.
#define ERR_FILE_NOTTXT                     5012 // The file must be opened as a text.
#define ERR_FILE_NOTTXTORCSV                5013 // The file must be opened as a text or CSV.
#define ERR_FILE_NOTCSV                     5014 // The file must be opened as CSV.
#define ERR_FILE_READERROR                  5015 // File reading error.
#define ERR_FILE_BINSTRINGSIZE              5016 // String size must be specified, because the file is opened as binary.
#define ERR_INCOMPATIBLE_FILE               5017 // A text file must be for string arrays, for other arrays - binary.
#ifndef ERR_FILE_IS_DIRECTORY
#define ERR_FILE_IS_DIRECTORY               5018 // This is not a file, this is a directory.
#endif
#ifndef ERR_FILE_NOT_EXIST
#define ERR_FILE_NOT_EXIST                  5019 // File does not exist.
#endif
#ifndef ERR_FILE_CANNOT_REWRITE
#define ERR_FILE_CANNOT_REWRITE             5020 // File can not be rewritten.
#endif
#define ERR_WRONG_DIRECTORYNAME             5021 // Wrong directory name.
#define ERR_DIRECTORY_NOT_EXIST             5022 // Directory does not exist.
#define ERR_FILE_ISNOT_DIRECTORY            5023 // This is a file, not a directory.
#define ERR_CANNOT_DELETE_DIRECTORY         5024 // The directory cannot be removed.
#define ERR_CANNOT_CLEAN_DIRECTORY          5025 // Failed to clear the directory (probably one or more files are blocked and removal operation failed).
#define ERR_FILE_WRITEERROR                 5026 // Failed to write a resource to a file.
#define ERR_FILE_ENDOFFILE                  5027 // Unable to read the next piece of data from a CSV file (FileReadString, FileReadNumber, FileReadDatetime, FileReadBool), since the end of file is reached.
// String Casting.
#define ERR_NO_STRING_DATE                  5030 // No date in the string.
#define ERR_WRONG_STRING_DATE               5031 // Wrong date in the string.
#define ERR_WRONG_STRING_TIME               5032 // Wrong time in the string.
#define ERR_STRING_TIME_ERROR               5033 // Error converting string to date.
#define ERR_STRING_OUT_OF_MEMORY            5034 // Not enough memory for the string.
#define ERR_STRING_SMALL_LEN                5035 // The string length is less than expected.
#define ERR_STRING_TOO_BIGNUMBER            5036 // Too large number, more than ULONG_MAX.
#define ERR_WRONG_FORMATSTRING              5037 // Invalid format string.
#define ERR_TOO_MANY_FORMATTERS             5038 // Amount of format specifiers more than the parameters.
#define ERR_TOO_MANY_PARAMETERS             5039 // Amount of parameters more than the format specifiers.
#define ERR_WRONG_STRING_PARAMETER          5040 // Damaged parameter of string type.
#define ERR_STRINGPOS_OUTOFRANGE            5041 // Position outside the string.
#define ERR_STRING_ZEROADDED                5042 // 0 added to the string end, a useless operation.
#define ERR_STRING_UNKNOWNTYPE              5043 // Unknown data type when converting to a string.
#define ERR_WRONG_STRING_OBJECT             5044 // Damaged string object.
// Operations with Array.
#ifndef ERR_INCOMPATIBLE_ARRAYS
#define ERR_INCOMPATIBLE_ARRAYS             5050 // Copying incompatible arrays. String array can be copied only to a string array, and a numeric array - in numeric array only.
#endif
#define ERR_SMALL_ASSERIES_ARRAY            5051 // The receiving array is declared as AS_SERIES, and it is of insufficient size.
#define ERR_SMALL_ARRAY                     5052 // Too small array, the starting position is outside the array.
#define ERR_ZEROSIZE_ARRAY                  5053 // An array of zero length.
#define ERR_NUMBER_ARRAYS_ONLY              5054 // Must be a numeric array.
#define ERR_ONEDIM_ARRAYS_ONLY              5055 // Must be a one-dimensional array.
#define ERR_SERIES_ARRAY                    5056 // Timeseries cannot be used.
#define ERR_DOUBLE_ARRAY_ONLY               5057 // Must be an array of type double.
#define ERR_FLOAT_ARRAY_ONLY                5058 // Must be an array of type float.
#define ERR_LONG_ARRAY_ONLY                 5059 // Must be an array of type long.
#define ERR_INT_ARRAY_ONLY                  5060 // Must be an array of type int.
#define ERR_SHORT_ARRAY_ONLY                5061 // Must be an array of type short.
#define ERR_CHAR_ARRAY_ONLY                 5062 // Must be an array of type char.
// Operations with OpenCL.
#define ERR_OPENCL_NOT_SUPPORTED            5100 // OpenCL functions are not supported on this computer.
#define ERR_OPENCL_INTERNAL                 5101 // Internal error occurred when running OpenCL.
#define ERR_OPENCL_INVALID_HANDLE           5102 // Invalid OpenCL handle.
#define ERR_OPENCL_CONTEXT_CREATE           5103 // Error creating the OpenCL context.
#define ERR_OPENCL_QUEUE_CREATE             5104 // Failed to create a run queue in OpenCL.
#define ERR_OPENCL_PROGRAM_CREATE           5105 // Error occurred when compiling an OpenCL program.
#define ERR_OPENCL_TOO_LONG_KERNEL_NAME     5106 // Too long kernel name (OpenCL kernel).
#define ERR_OPENCL_KERNEL_CREATE            5107 // Error creating an OpenCL kernel.
#define ERR_OPENCL_SET_KERNEL_PARAMETER     5108 // Error occurred when setting parameters for the OpenCL kernel.
#define ERR_OPENCL_EXECUTE                  5109 // OpenCL program runtime error.
#define ERR_OPENCL_WRONG_BUFFER_SIZE        5110 // Invalid size of the OpenCL buffer.
#define ERR_OPENCL_WRONG_BUFFER_OFFSET      5111 // Invalid offset in the OpenCL buffer.
#define ERR_OPENCL_BUFFER_CREATE            5112 // Failed to create an OpenCL buffer.
// Operations with WebRequest.
#ifndef ERR_WEBREQUEST_INVALID_ADDRESS
#define ERR_WEBREQUEST_INVALID_ADDRESS      5200 // Invalid URL.
#endif
#ifndef ERR_WEBREQUEST_CONNECT_FAILED
#define ERR_WEBREQUEST_CONNECT_FAILED       5201 // Failed to connect to specified URL.
#endif
#ifndef ERR_WEBREQUEST_TIMEOUT
#define ERR_WEBREQUEST_TIMEOUT              5202 // Timeout exceeded.
#endif
#ifndef ERR_WEBREQUEST_REQUEST_FAILED
#define ERR_WEBREQUEST_REQUEST_FAILED       5203 // HTTP request failed.
#endif
// User-Defined Errors.
#ifndef ERR_USER_ERROR_FIRST
#define ERR_USER_ERROR_FIRST               65536 // User defined errors start with this code.
#endif

/**
 * MQL5 wrapper to work in MQL4.
 */
class MQL5 {

  public:
    // Enums.
    #ifdef __MQL4__
    // Trading operations.
    enum ENUM_TRADE_REQUEST_ACTIONS {
      // @see: https://www.mql5.com/en/docs/constants/tradingconstants/enum_trade_request_actions
      TRADE_ACTION_DEAL,    // Place a trade order for an immediate execution with the specified parameters (market order).
      TRADE_ACTION_PENDING, // Place a trade order for the execution under specified conditions (pending order).
      TRADE_ACTION_SLTP,    // Modify Stop Loss and Take Profit values of an opened position.
      TRADE_ACTION_MODIFY,  // Modify the parameters of the order placed previously.
      TRADE_ACTION_REMOVE,  // Delete the pending order placed previously.
      TRADE_ACTION_CLOSE_BY // Close a position by an opposite one.
    };
    // Fill Policy.
    enum ENUM_SYMBOL_FILLING {
      // @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
      SYMBOL_FILLING_FOK = 1, // A deal can be executed only with the specified volume.
      SYMBOL_FILLING_IOC = 2  // Trader agrees to execute a deal with the volume maximally available in the market.
    };
    enum ENUM_ORDER_TYPE_FILLING {
      // @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
      ORDER_FILLING_FOK, // An order can be filled only in the specified amount.
      ORDER_FILLING_IOC, // A trader agrees to execute a deal with the volume maximally available in the market.
      ORDER_FILLING_RETURN // In case of partial filling a market or limit order with remaining volume is not canceled but processed further.
    };
    enum ENUM_ORDER_TYPE_TIME {
      // @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
      ORDER_TIME_GTC,           // Good till cancel order.
      ORDER_TIME_DAY,           // Good till current trade day order.
      ORDER_TIME_SPECIFIED,     // Good till expired order.
      ORDER_TIME_SPECIFIED_DAY  // The order will be effective till 23:59:59 of the specified day.
    };
    // An order status that describes its state.
    enum ENUM_ORDER_STATE {
      ORDER_STATE_STARTED,        // Order checked, but not yet accepted by broker
      ORDER_STATE_PLACED,         // Order accepted
      ORDER_STATE_CANCELED,       // Order canceled by client
      ORDER_STATE_PARTIAL,        // Order partially executed
      ORDER_STATE_FILLED,         // Order fully executed
      ORDER_STATE_REJECTED,       // Order rejected
      ORDER_STATE_EXPIRED,        // Order expired
      ORDER_STATE_REQUEST_ADD,    // Order is being registered (placing to the trading system)
      ORDER_STATE_REQUEST_MODIFY, // Order is being modified (changing its parameters)
      ORDER_STATE_REQUEST_CANCEL  // Order is being deleted (deleting from the trading system)
    };
    #endif

    #ifdef __MQL4__
    // @see: https://www.mql5.com/en/docs/constants/structures/mqltraderequest
    struct MqlTradeRequest {
      ENUM_TRADE_REQUEST_ACTIONS    action;           // Trade operation type.
      ulong                         magic;            // Expert Advisor ID (magic number).
      ulong                         order;            // Order ticket.
      string                        symbol;           // Trade symbol.
      double                        volume;           // Requested volume for a deal in lots.
      double                        price;            // Price.
      double                        stoplimit;        // StopLimit level of the order.
      double                        sl;               // Stop Loss level of the order.
      double                        tp;               // Take Profit level of the order.
      ulong                         deviation;        // Maximal possible deviation from the requested price.
      ENUM_ORDER_TYPE               type;             // Order type.
      ENUM_ORDER_TYPE_FILLING       type_filling;     // Order execution type.
      ENUM_ORDER_TYPE_TIME          type_time;        // Order expiration type.
      datetime                      expiration;       // Order expiration time (for the orders of ORDER_TIME_SPECIFIED type.
      string                        comment;          // Order comment.
      ulong                         position;         // Position ticket.
      ulong                         position_by;      // The ticket of an opposite position.
    };
    // @see: https://www.mql5.com/en/docs/constants/structures/mqltraderesult
    struct MqlTradeResult  {
      uint     retcode;          // Operation return code.
      ulong    deal;             // Deal ticket, if it is performed.
      ulong    order;            // Order ticket, if it is placed.
      double   volume;           // Deal volume, confirmed by broker.
      double   price;            // Deal price, confirmed by broker.
      double   bid;              // Current Bid price.
      double   ask;              // Current Ask price.
      string   comment;          // Broker comment to operation (by default it is filled by description of trade server return code).
      uint     request_id;       // Request ID set by the terminal during the dispatch.
      uint     retcode_external; // Return code of an external trading system.
    };
    #endif
};
#endif // MQL5_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: MQL5.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef __MQL__
#pragma once
#endif





/**
 * Struct to provide symbol information.
 */
struct SymbolInfoStatic {
 public:
  /**
   * Get the current symbol pair from the current chart.
   */
  static string GetCurrentSymbol() { return _Symbol; }

  /**
   * Updates and gets the latest tick prices.
   *
   * @docs MQL4 https://docs.mql4.com/constants/structures/mqltick
   * @docs MQL5 https://www.mql5.com/en/docs/constants/structures/mqltick
   */
  static MqlTick GetTick(string _symbol) {
    MqlTick _last_tick;
    if (!::SymbolInfoTick(_symbol, _last_tick)) {
      PrintFormat("Error: %s(): %s", __FUNCTION__, "Cannot return current prices!");
    }
    return _last_tick;
  }

  /**
   * Updates and gets the latest ask price (best buy offer).
   */
  static double GetAsk(string _symbol) { return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_ASK); }

  /**
   * Updates and gets the latest bid price (best sell offer).
   */
  static double GetBid(string _symbol) { return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_BID); }

  /**
   * Get the last volume for the current last price.
   *
   * @see: https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  static ulong GetVolume(string _symbol) { return GetTick(_symbol).volume; }

  /**
   * Get summary volume of current session deals.
   *
   * @see: https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  static double GetSessionVolume(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_SESSION_VOLUME);
  }

  /**
   * Time of the last quote
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_info_double
   */
  static datetime GetQuoteTime(string _symbol) {
    return (datetime)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_TIME);
  }

  /**
   * Get current open price depending on the operation type.
   *
   * @param:
   *   op_type int Order operation type of the order.
   * @return
   *   Current open price.
   */
  static double GetOpenOffer(string _symbol, ENUM_ORDER_TYPE _cmd) {
    // Use the right open price at opening of a market order. For example:
    // - When selling, only the latest Bid prices can be used.
    // - When buying, only the latest Ask prices can be used.
    return _cmd == ORDER_TYPE_BUY ? GetAsk(_symbol) : GetBid(_symbol);
  }

  /**
   * Get current close price depending on the operation type.
   *
   * @param:
   *   op_type int Order operation type of the order.
   * @return
   * Current close price.
   */
  static double GetCloseOffer(string _symbol, ENUM_ORDER_TYPE _cmd) {
    return _cmd == ORDER_TYPE_BUY ? GetBid(_symbol) : GetAsk(_symbol);
  }

  /**
   * Get pip precision.
   */
  static unsigned int GetPipDigits(string _symbol) { return GetDigits(_symbol) < 4 ? 2 : 4; }

  /**
   * Get pip value.
   */
  static double GetPipValue(string _symbol) {
    unsigned int _pdigits = GetPipDigits(_symbol);
    return 10 >> _pdigits;
  }

  /**
   * Get number of points per pip.
   *
   */
  static unsigned int GetPointsPerPip(string _symbol) {
    // To be used to replace Point for trade parameters calculations.
    // See: https://www.mql5.com/en/forum/124692
    return (unsigned int)pow(10, SymbolInfoStatic::GetDigits(_symbol) - SymbolInfoStatic::GetPipDigits(_symbol));
  }

  /**
   * Get the point size in the quote currency.
   *
   * The smallest digit of price quote.
   * A change of 1 in the least significant digit of the price.
   * You may also use Point predefined variable for the current symbol.
   */
  static double GetPointSize(string _symbol) {
    // Same as: MarketInfo(symbol, MODE_POINT);
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_POINT);
  }

  /**
   * Return a pip size.
   *
   * In most cases, a pip is equal to 1/100 (.01%) of the quote currency.
   */
  static double GetPipSize(string _symbol) {
    // @todo: This code may fail at Gold and Silver (https://www.mql5.com/en/forum/135345#515262).
    return GetPointSize(_symbol) * (GetDigits(_symbol) % 2 == 0 ? 1 : 10);
  }

  /**
   * Get current spread in points.
   *
   * @param
   *   symbol string (optional)
   *   Currency pair symbol.
   *
   * @return
   *   Return symbol trade spread level in points.
   */
  static unsigned int GetSpreadInPts(string _symbol) { return GetSpread(_symbol); }

  /**
   * Get current spread in percent.
   */
  static double GetSpreadInPct(string _symbol) { return 100.0 * (GetAsk(_symbol) - GetBid(_symbol)) / GetAsk(_symbol); }

  /**
   * Get a tick size in the price value.
   *
   * It is the smallest movement in the price quoted by the broker,
   * which could be several points.
   * In currencies it is equivalent to point size, in metals they are not.
   */
  static float GetTickSize(string _symbol) {
    // Note: In currencies a tick is always a point, but not for other markets.
    return (float)SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_TRADE_TICK_SIZE);
  }

  /**
   * Get a tick size in points.
   *
   * It is a minimal price change in points.
   * In currencies it is equivalent to point size, in metals they are not.
   */
  static double GetTradeTickSize(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_TRADE_TICK_SIZE);
  }

  /**
   * Get a tick value in the deposit currency.
   *
   * @return
   * Returns the number of base currency units for one pip of movement.
   */
  static double GetTickValue(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(_symbol,
                                              SYMBOL_TRADE_TICK_VALUE);  // Same as: MarketInfo(symbol, MODE_TICKVALUE);
  }

  /**
   * Get a calculated tick price for a profitable position.
   *
   * @return
   * Returns the number of base currency units for one pip of movement.
   */
  static double GetTickValueProfit(string _symbol) {
    // Not supported in MQL4.
    return SymbolInfoStatic::SymbolInfoDouble(
        _symbol, SYMBOL_TRADE_TICK_VALUE_PROFIT);  // Same as: MarketInfo(symbol, SYMBOL_TRADE_TICK_VALUE_PROFIT);
  }

  /**
   * Get a calculated tick price for a losing position.
   *
   * @return
   * Returns the number of base currency units for one pip of movement.
   */
  static double GetTickValueLoss(string _symbol) {
    // Not supported in MQL4.
    return SymbolInfoStatic::SymbolInfoDouble(
        _symbol, SYMBOL_TRADE_TICK_VALUE_LOSS);  // Same as: MarketInfo(symbol, SYMBOL_TRADE_TICK_VALUE_LOSS);
  }

  /**
   * Get count of digits after decimal point for the symbol price.
   *
   * For the current symbol, it is stored in the predefined variable Digits.
   *
   */
  static uint GetDigits(string _symbol) {
    return (uint)SymbolInfoStatic::SymbolInfoInteger(_symbol,
                                                     SYMBOL_DIGITS);  // Same as: MarketInfo(symbol, MODE_DIGITS);
  }

  /**
   * Get current spread in points.
   *
   * @param
   *   symbol string (optional)
   *   Currency pair symbol.
   *
   * @return
   *   Return symbol trade spread level in points.
   */
  static uint GetSpread(string _symbol) { return (uint)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_SPREAD); }

  /**
   * Get real spread based on the ask and bid price (in points).
   */
  static unsigned int GetRealSpread(double _bid, double _ask, unsigned int _digits) {
    return (unsigned int)round((_ask - _bid) * pow(10, _digits));
  }
  static unsigned int GetRealSpread(string _symbol) {
    return GetRealSpread(SymbolInfoStatic::GetBid(_symbol), SymbolInfoStatic::GetAsk(_symbol),
                         SymbolInfoStatic::GetDigits(_symbol));
  }

  /**
   * Minimal indention in points from the current close price to place Stop orders.
   *
   * This is due that at placing of a pending order, the open price cannot be too close to the market.
   * The minimal distance of the pending price from the current market one in points can be obtained
   * using the MarketInfo() function with the MODE_STOPLEVEL parameter.
   * Related error messages:
   *   Error 130 (ERR_INVALID_STOPS) happens In case of false open price of a pending order.
   *   Error 145 (ERR_TRADE_MODIFY_DENIED) happens when modification of order was too close to market.
   *
   * @param
   *   symbol string (optional)
   *   Currency pair symbol.
   *
   * @return
   *   Returns the minimal permissible distance value in points for StopLoss/TakeProfit.
   *   A zero value means either absence of any restrictions on the minimal distance.
   *
   * @see: https://book.mql4.com/appendix/limits
   */
  static long GetTradeStopsLevel(string _symbol) {
    return SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_TRADE_STOPS_LEVEL);
  }

  /**
   * Get a contract lot size in the base currency.
   */
  static double GetTradeContractSize(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(
        _symbol,
        SYMBOL_TRADE_CONTRACT_SIZE);  // Same as: MarketInfo(symbol, MODE_LOTSIZE);
  }

  /**
   * Get a volume precision.
   */
  static unsigned int GetVolumeDigits(string _symbol) {
    return (unsigned int)-log10(fmin(GetVolumeStep(_symbol), GetVolumeMin(_symbol)));
  }

  /**
   * Minimum permitted amount of a lot/volume for a deal.
   */
  static double GetVolumeMin(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_VOLUME_MIN);  // Same as: MarketInfo(symbol, MODE_MINLOT);
  }

  /**
   * Maximum permitted amount of a lot/volume for a deal.
   */
  static double GetVolumeMax(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_VOLUME_MAX);  // Same as: MarketInfo(symbol, MODE_MAXLOT);
  }

  /**
   * Get a lot/volume step for a deal.
   *
   * Minimal volume change step for deal execution
   */
  static double GetVolumeStep(string _symbol) {
    return SymbolInfoStatic::SymbolInfoDouble(_symbol,
                                              SYMBOL_VOLUME_STEP);  // Same as: MarketInfo(symbol, MODE_LOTSTEP);
  }

  /**
   * Order freeze level in points.
   *
   * Freeze level is a value that determines the price band,
   * within which the order is considered as 'frozen' (prohibited to change).
   *
   * If the execution price lies within the range defined by the freeze level,
   * the order cannot be modified, cancelled or closed.
   * The possibility of deleting a pending order is regulated by the FreezeLevel.
   *
   * @see: https://book.mql4.com/appendix/limits
   */
  static uint GetFreezeLevel(string _symbol) {
    return (uint)SymbolInfoStatic::SymbolInfoInteger(
        _symbol, SYMBOL_TRADE_FREEZE_LEVEL);  // Same as: MarketInfo(symbol, MODE_FREEZELEVEL);
  }

  /**
   * Gets flags of allowed order filling modes.
   *
   *  The flags can be combined by the operation of the logical OR (e.g. SYMBOL_FILLING_FOK|SYMBOL_FILLING_IOC).
   *
   * @docs
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   */
  static ENUM_ORDER_TYPE_FILLING GetFillingMode(string _symbol) {
    // Note: Not supported for MQL4.
    return (ENUM_ORDER_TYPE_FILLING)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_FILLING_MODE);
  }

  /**
   * Buy order swap value
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  static double GetSwapLong(string _symbol) { return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_SWAP_LONG); }

  /**
   * Sell order swap value
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  static double GetSwapShort(string _symbol) { return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_SWAP_SHORT); }

  /**
   * Swap calculation model.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  static ENUM_SYMBOL_SWAP_MODE GetSwapMode(string _symbol) {
    return (ENUM_SYMBOL_SWAP_MODE)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_SWAP_MODE);
  }

  /**
   * Returns initial margin (a security deposit) requirements for opening an order.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_info_double
   */
  static double GetMarginInit(string _symbol, ENUM_ORDER_TYPE _cmd = ORDER_TYPE_BUY) {
#ifdef __MQL4__
    // The amount in the margin currency required for opening an order with the volume of one lot.
    // It is used for checking a client's assets when entering the market.
    // Same as: MarketInfo(symbol, MODE_MARGININIT);
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_MARGIN_INITIAL);
#else  // __MQL5__
       // In MQL5, SymbolInfoDouble() is used for stock markets, not Forex (https://www.mql5.com/en/forum/7418).
       // So we've to use OrderCalcMargin() which calculates the margin required for the specified order type.
    double _margin_init, _margin_main;
    const bool _result = SymbolInfoMarginRate(_symbol, _cmd, _margin_init, _margin_main);
    return _result ? _margin_init : 0;
#endif
  }

  /**
   * Return the maintenance margin to maintain open orders.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_info_double
   */
  static double GetMarginMaintenance(string _symbol, ENUM_ORDER_TYPE _cmd = ORDER_TYPE_BUY) {
#ifdef __MQL4__
    // The margin amount in the margin currency of the symbol, charged from one lot.
    // It is used for checking a client's assets when his/her account state changes.
    // If the maintenance margin is equal to 0, the initial margin should be used.
    // Same as: MarketInfo(symbol, SYMBOL_MARGIN_MAINTENANCE);
    return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_MARGIN_MAINTENANCE);
#else  // __MQL5__
       // In MQL5, SymbolInfoDouble() is used for stock markets, not Forex (https://www.mql5.com/en/forum/7418).
       // So we've to use OrderCalcMargin() which calculates the margin required for the specified order type.
    double _margin_init, _margin_main;
    const bool _result = SymbolInfoMarginRate(_symbol, _cmd, _margin_init, _margin_main);
    return _result ? _margin_main : 0;
#endif
  }

  /**
   * Returns the value of a corresponding property of the symbol.
   *
   * @param string name
   *   Symbol name.
   * @param ENUM_SYMBOL_INFO_DOUBLE prop_id
   *   Identifier of a property.
   *
   * @return double
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   *
   * @docs
   * - https://docs.mql4.com/marketinformation/symbolinfodouble
   * - https://www.mql5.com/en/docs/marketinformation/symbolinfodouble
   *
   */
  static double SymbolInfoDouble(string name, ENUM_SYMBOL_INFO_DOUBLE prop_id) {
#ifdef __MQLBUILD__
    return ::SymbolInfoDouble(name, prop_id);
#else
    printf("@fixme: %s\n", "Symbol::SymbolInfoDouble()");
    return 0;
#endif
  }

  /**
   * Returns the value of a corresponding property of the symbol.
   *
   * @param string name
   *   Symbol name.
   * @param ENUM_SYMBOL_INFO_INTEGER prop_id
   *   Identifier of a property.
   *
   * @return long
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   *
   * @docs
   * - https://docs.mql4.com/marketinformation/symbolinfointeger
   * - https://www.mql5.com/en/docs/marketinformation/symbolinfointeger
   *
   */
  static long SymbolInfoInteger(string name, ENUM_SYMBOL_INFO_INTEGER prop_id) {
    return ::SymbolInfoInteger(name, prop_id);
  }

  /**
   * Returns the value of a corresponding property of the symbol.
   *
   * @param string name
   *   Symbol name.
   * @param ENUM_SYMBOL_INFO_STRING prop_id
   *   Identifier of a property.
   *
   * @return string
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   *
   * @docs
   * - https://docs.mql4.com/marketinformation/symbolinfostring
   * - https://www.mql5.com/en/docs/marketinformation/symbolinfostring
   *
   */
  static string SymbolInfoString(string name, ENUM_SYMBOL_INFO_STRING prop_id) {
#ifdef __MQLBUILD__
    return ::SymbolInfoString(name, prop_id);
#else
    printf("@fixme: %s\n", "SymbolInfoStatic::SymbolInfoString()");
    return 0;
#endif
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SymbolInfo.struct.static.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SymbolInfo.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes SymbolInfo's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

#ifndef __MQL5__
// Methods of swap calculation at position transfer.
// @see: https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_swap_mode
enum ENUM_SYMBOL_SWAP_MODE {
  SYMBOL_SWAP_MODE_DISABLED = -1,         // Swaps disabled (no swaps).
  SYMBOL_SWAP_MODE_POINTS = 0,            // Swaps are charged in points.
  SYMBOL_SWAP_MODE_CURRENCY_SYMBOL = 1,   // Swaps are charged in money in base currency of the symbol.
  SYMBOL_SWAP_MODE_INTEREST_CURRENT = 2,  // Swaps are charged as the specified annual interest.
  SYMBOL_SWAP_MODE_CURRENCY_MARGIN = 3,   // Swaps are charged in money in margin currency of the symbol.
  SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT,      // Swaps are charged in money, in client deposit currency.
  SYMBOL_SWAP_MODE_INTEREST_OPEN,         // Swaps are charged as the specified annual interest from the open price.
  SYMBOL_SWAP_MODE_REOPEN_CURRENT,        // Swaps are charged by reopening positions.
  SYMBOL_SWAP_MODE_REOPEN_BID             // Swaps are charged by reopening positions.
};
#endif

#ifndef __MQL__
/**
 * Enumeration for the current market double values.
 *
 * For function SymbolInfoDouble().
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_INFO_DOUBLE {
  SYMBOL_BID,                      // Bid - best sell offer (double).
  SYMBOL_BIDHIGH,                  // Maximal Bid of the day (double).
  SYMBOL_BIDLOW,                   // Minimal Bid of the day (double).
  SYMBOL_ASK,                      // Ask - best buy offer (double).
  SYMBOL_ASKHIGH,                  // Maximal Ask of the day (double).
  SYMBOL_ASKLOW,                   // Minimal Ask of the day (double).
  SYMBOL_LAST,                     // Price of the last deal (double).
  SYMBOL_LASTHIGH,                 // Maximal Last of the day (double).
  SYMBOL_LASTLOW,                  // Minimal Last of the day (double).
  SYMBOL_VOLUME_REAL,              // Volume of the last deal (double).
  SYMBOL_VOLUMEHIGH_REAL,          // Maximum Volume of the day (double).
  SYMBOL_VOLUMELOW_REAL,           // Minimum Volume of the day (double).
  SYMBOL_OPTION_STRIKE,            // The strike price of an option (double).
  SYMBOL_POINT,                    // Symbol point value (double).
  SYMBOL_TRADE_TICK_VALUE,         // Value of SYMBOL_TRADE_TICK_VALUE_PROFIT (double).
  SYMBOL_TRADE_TICK_VALUE_PROFIT,  // Calculated tick price for a profitable position (double).
  SYMBOL_TRADE_TICK_VALUE_LOSS,    // Calculated tick price for a losing position (double).
  SYMBOL_TRADE_TICK_SIZE,          // Minimal price change (double).
  SYMBOL_TRADE_CONTRACT_SIZE,      // Trade contract size (double).
  SYMBOL_TRADE_ACCRUED_INTEREST,   // Accrued interest - accumulated coupon interest (double).
  SYMBOL_TRADE_FACE_VALUE,         // Face value - initial bond value set by the issuer (double).
  SYMBOL_TRADE_LIQUIDITY_RATE,     // Liquidity Rate is the share of the asset that can be used for the margin (double).
  SYMBOL_VOLUME_MIN,               // Minimal volume for a deal (double).
  SYMBOL_VOLUME_MAX,               // Maximal volume for a deal (double).
  SYMBOL_VOLUME_STEP,              // Minimal volume change step for deal execution (double).
  SYMBOL_VOLUME_LIMIT,      // Maximum allowed aggregate volume of an open position and pending orders in one direction.
  SYMBOL_SWAP_LONG,         // Long swap value (double).
  SYMBOL_SWAP_SHORT,        // Short swap value (double).
  SYMBOL_MARGIN_INITIAL,    // The amount in the margin currency required for opening a position.
  SYMBOL_SESSION_VOLUME,    // Summary volume of current session deals (double).
  SYMBOL_SESSION_TURNOVER,  // Summary turnover of the current session (double).
  SYMBOL_SESSION_INTEREST,  // Summary open interest (double).
  SYMBOL_SESSION_BUY_ORDERS_VOLUME,   // Current volume of Buy orders (double).
  SYMBOL_SESSION_SELL_ORDERS_VOLUME,  // Current volume of Sell orders (double).
  SYMBOL_SESSION_OPEN,                // Open price of the current session (double).
  SYMBOL_SESSION_CLOSE,               // Close price of the current session (double).
  SYMBOL_SESSION_AW,                  // Average weighted price of the current session (double).
  SYMBOL_SESSION_PRICE_SETTLEMENT,    // Settlement price of the current session (double).
  SYMBOL_SESSION_PRICE_LIMIT_MIN,     // Minimal price of the current session (double).
  SYMBOL_SESSION_PRICE_LIMIT_MAX,     // Maximal price of the current session (double).
  SYMBOL_MARGIN_HEDGED,               // Contract size or margin value per one lot of hedged positions.
  SYMBOL_PRICE_CHANGE,  // Change of the current price relative to the end of the previous trading day in % (double).
  SYMBOL_PRICE_VOLATILITY,   // Price volatility in % (double).
  SYMBOL_PRICE_THEORETICAL,  // Theoretical option price (double).
  SYMBOL_PRICE_DELTA,        // Option/warrant delta shows the value the option price changes by.
  SYMBOL_PRICE_THETA,        // Option/warrant theta shows the number of points the option price is to lose.
  SYMBOL_PRICE_GAMMA,        // Option/warrant gamma shows the change rate of delta.
  SYMBOL_PRICE_VEGA,         // Option/warrant vega shows the number of points the option price changes.
  SYMBOL_PRICE_RHO,          // Option/warrant rho reflects the sensitivity of the theoretical option price.
  SYMBOL_PRICE_OMEGA,        // Option/warrant omega (double).
  SYMBOL_PRICE_SENSITIVITY,  // Option/warrant sensitivity (double).
};

/**
 * Enumeration for the current market integer values.
 *
 * For function SymbolInfoInteger().
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_INFO_INTEGER {
  SYMBOL_SECTOR,            // The sector of the economy to which the asset belongs (ENUM_SYMBOL_SECTOR).
  SYMBOL_INDUSTRY,          // The industry or the economy branch to which the symbol belongs (ENUM_SYMBOL_INDUSTRY).
  SYMBOL_CUSTOM,            // A custom symbol - the symbol has been created synthetically based on other symbols.
  SYMBOL_BACKGROUND_COLOR,  // The color of the background used for the symbol in Market Watch (color).
  SYMBOL_CHART_MODE,     // The price type used for generating symbols bars, i.e. Bid or Last (ENUM_SYMBOL_CHART_MODE).
  SYMBOL_EXIST,          // Symbol with this name exists (bool).
  SYMBOL_SELECT,         // Symbol is selected in Market Watch (bool).
  SYMBOL_VISIBLE,        // Symbol is visible in Market Watch (bool).
  SYMBOL_SESSION_DEALS,  // Number of deals in the current session (long).
  SYMBOL_SESSION_BUY_ORDERS,     // Number of Buy orders at the moment (long).
  SYMBOL_SESSION_SELL_ORDERS,    // Number of Sell orders at the moment (long).
  SYMBOL_VOLUME,                 // Volume of the last deal (long).
  SYMBOL_VOLUMEHIGH,             // Maximal day volume (long).
  SYMBOL_VOLUMELOW,              // Minimal day volume (long).
  SYMBOL_TIME,                   // Time of the last quote (datetime).
  SYMBOL_TIME_MSC,               // Time of the last quote in milliseconds since 1970.01.01 (long).
  SYMBOL_DIGITS,                 // Digits after a decimal point (int).
  SYMBOL_SPREAD_FLOAT,           // Indication of a floating spread (bool).
  SYMBOL_SPREAD,                 // Spread value in points (int).
  SYMBOL_TICKS_BOOKDEPTH,        // Maximal number of requests shown in Depth of Market.
  SYMBOL_TRADE_CALC_MODE,        // Contract price calculation mode (ENUM_SYMBOL_CALC_MODE).
  SYMBOL_TRADE_MODE,             // Order execution type (ENUM_SYMBOL_TRADE_MODE).
  SYMBOL_START_TIME,             // Date of the symbol trade beginning (usually used for futures) (datetime).
  SYMBOL_EXPIRATION_TIME,        // Date of the symbol trade end (usually used for futures) (datetime).
  SYMBOL_TRADE_STOPS_LEVEL,      // Minimal indention in points from the current close price to place Stop orders (int).
  SYMBOL_TRADE_FREEZE_LEVEL,     // Distance to freeze trade operations in points (int).
  SYMBOL_TRADE_EXEMODE,          // Deal execution mode (ENUM_SYMBOL_TRADE_EXECUTION).
  SYMBOL_SWAP_MODE,              // Swap calculation model (ENUM_SYMBOL_SWAP_MODE).
  SYMBOL_SWAP_ROLLOVER3DAYS,     // Day of week to charge 3 days swap rollover (ENUM_DAY_OF_WEEK).
  SYMBOL_MARGIN_HEDGED_USE_LEG,  // Calculating hedging margin using the larger leg (Buy or Sell) (bool).
  SYMBOL_EXPIRATION_MODE,        // Flags of allowed order expiration modes (int).
  SYMBOL_FILLING_MODE,           // Flags of allowed order filling modes (int).
  SYMBOL_ORDER_MODE,             // Flags of allowed order types (int).
  SYMBOL_ORDER_GTC_MODE,         // Expiration of Stop Loss and Take Profit orders.
  SYMBOL_OPTION_MODE,            // Option type (ENUM_SYMBOL_OPTION_MODE).
  SYMBOL_OPTION_RIGHT,           // Option right (Call/Put) (ENUM_SYMBOL_OPTION_RIGHT).
};

/**
 * Enumeration for the current market string values.
 *
 * For function SymbolInfoString().
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_INFO_STRING {
  SYMBOL_BASIS,            // The underlying asset of a derivative (string).
  SYMBOL_CATEGORY,         // The name of the sector or category to which the financial symbol belongs (string).
  SYMBOL_COUNTRY,          // The country to which the financial symbol belongs (string).
  SYMBOL_SECTOR_NAME,      // The sector of the economy to which the financial symbol belongs (string).
  SYMBOL_INDUSTRY_NAME,    // The industry branch or the industry to which the financial symbol belongs (string).
  SYMBOL_CURRENCY_BASE,    // Basic currency of a symbol (string).
  SYMBOL_CURRENCY_PROFIT,  // Profit currency (string).
  SYMBOL_CURRENCY_MARGIN,  // Margin currency (string).
  SYMBOL_BANK,             // Feeder of the current quote (string).
  SYMBOL_DESCRIPTION,      // Symbol description (string).
  SYMBOL_EXCHANGE,         // The name of the exchange in which the financial symbol is traded (string).
  SYMBOL_FORMULA,          // The formula used for the custom symbol pricing (string).
  SYMBOL_ISIN,             // The name of a symbol in the ISIN system (International Securities Identification Number).
  SYMBOL_PAGE,             // The address of the web page containing symbol information.
  SYMBOL_PATH,             // Path in the symbol tree (string).
};

/**
 * Enumeration for the current market modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_CHART_MODE {
  SYMBOL_CHART_MODE_BID,   // Bars are based on Bid prices.
  SYMBOL_CHART_MODE_LAST,  // Bars are based on Last prices.
};

/**
 * Enumeration for the symbol order GTC mode.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_ORDER_GTC_MODE {
  SYMBOL_ORDERS_GTC,    // Pending orders and Stop Loss/Take Profit levels are valid for an unlimited period.
  SYMBOL_ORDERS_DAILY,  // Orders are valid during one trading day.
  SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS,  // When a trade day changes, only pending orders are deleted.
};

/**
 * Enumeration for the margin calculation modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_CALC_MODE {
  SYMBOL_CALC_MODE_FOREX,              // Forex mode - calculation of profit and margin for Forex.
  SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE,  // Forex No Leverage mode.
  SYMBOL_CALC_MODE_FUTURES,            // Futures mode - calculation of margin and profit for futures.
  SYMBOL_CALC_MODE_CFD,                // CFD mode - calculation of margin and profit for CFD.
  SYMBOL_CALC_MODE_CFDINDEX,           // CFD index mode - calculation of margin and profit for CFD by indexes.
  SYMBOL_CALC_MODE_CFDLEVERAGE,   // CFD Leverage mode - calculation of margin and profit for CFD at leverage trading.
  SYMBOL_CALC_MODE_EXCH_STOCKS,   // Exchange mode - calculation of margin and profit for trading securities.
  SYMBOL_CALC_MODE_EXCH_FUTURES,  // Futures mode - calculation of margin and profit for trading futures contracts.
  SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS,  // FORTS Futures mode.
  SYMBOL_CALC_MODE_EXCH_BONDS,          // Exchange Bonds mode.
  SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX,    // Exchange MOEX Stocks mode.
  SYMBOL_CALC_MODE_EXCH_BONDS_MOEX,     // Exchange MOEX Bonds mode.
  SYMBOL_CALC_MODE_SERV_COLLATERAL,     // Collateral mode.
};

/**
 * Enumeration for the trading modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_TRADE_MODE {
  SYMBOL_TRADE_MODE_DISABLED,   // Trade is disabled for the symbol.
  SYMBOL_TRADE_MODE_LONGONLY,   // Allowed only long positions.
  SYMBOL_TRADE_MODE_SHORTONLY,  // Allowed only short positions.
  SYMBOL_TRADE_MODE_CLOSEONLY,  // Allowed only position close operations.
  SYMBOL_TRADE_MODE_FULL,       // No trade restrictions.
};

/**
 * Enumeration for the possible deal execution modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_TRADE_EXECUTION {
  SYMBOL_TRADE_EXECUTION_REQUEST,   // Execution by request.
  SYMBOL_TRADE_EXECUTION_INSTANT,   // Instant execution.
  SYMBOL_TRADE_EXECUTION_MARKET,    // Market execution.
  SYMBOL_TRADE_EXECUTION_EXCHANGE,  // Exchange execution.
};

/**
 * Enumeration for the option right modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_OPTION_RIGHT {
  SYMBOL_OPTION_RIGHT_CALL,  // A call option gives you the right to buy an asset at a specified price.
  SYMBOL_OPTION_RIGHT_PUT,   // A put option gives you the right to sell an asset at a specified price.
};

/**
 * Enumeration for the symbol option modes.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_OPTION_MODE {
  SYMBOL_OPTION_MODE_EUROPEAN,  // European option may only be exercised on a specified date.
  SYMBOL_OPTION_MODE_AMERICAN,  // American option may be exercised on any trading day or before expiry.
};

/**
 * Enumeration for the type of financial instruments.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_SECTOR {
  SECTOR_UNDEFINED,               // Undefined.
  SECTOR_BASIC_MATERIALS,         // Basic materials.
  SECTOR_COMMUNICATION_SERVICES,  // Communication services.
  SECTOR_CONSUMER_CYCLICAL,       // Consumer cyclical.
  SECTOR_CONSUMER_DEFENSIVE,      // Consumer defensive.
  SECTOR_CURRENCY,                // Currencies.
  SECTOR_CURRENCY_CRYPTO,         // Cryptocurrencies.
  SECTOR_ENERGY,                  // Energy.
  SECTOR_FINANCIAL,               // Finance.
  SECTOR_HEALTHCARE,              // Healthcare.
  SECTOR_INDUSTRIALS,             // Industrials.
  SECTOR_REAL_ESTATE,             // Real estate.
  SECTOR_TECHNOLOGY,              // Technology.
  SECTOR_UTILITIES,               // Utilities.
};

/**
 * Enumeration for each type of industry or economy branch.
 *
 * @docs
 * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
 */
enum ENUM_SYMBOL_INDUSTRY {
  INDUSTRY_UNDEFINED,  // Undefined.
  // Basic materials.
  INDUSTRY_AGRICULTURAL_INPUTS,  // Agricultural inputs.
  INDUSTRY_ALUMINIUM,            // Aluminium.
  INDUSTRY_BUILDING_MATERIALS,   // Building materials.
  INDUSTRY_CHEMICALS,            // Chemicals.
  INDUSTRY_COKING_COAL,          // Coking coal.
  INDUSTRY_COPPER,               // Copper.
  INDUSTRY_GOLD,                 // Gold.
  INDUSTRY_LUMBER_WOOD,          // Lumber and wood production.
  INDUSTRY_INDUSTRIAL_METALS,    // Other industrial metals and mining.
  INDUSTRY_PRECIOUS_METALS,      // Other precious metals and mining.
  INDUSTRY_PAPER,                // Paper and paper products.
  INDUSTRY_SILVER,               // Silver.
  INDUSTRY_SPECIALTY_CHEMICALS,  // Specialty chemicals.
  INDUSTRY_STEEL,                // Steel.
  // Communication services.
  INDUSTRY_ADVERTISING,        // Advertising agencies.
  INDUSTRY_BROADCASTING,       // Broadcasting.
  INDUSTRY_GAMING_MULTIMEDIA,  // Electronic gaming and multimedia.
  INDUSTRY_ENTERTAINMENT,      // Entertainment.
  INDUSTRY_INTERNET_CONTENT,   // Internet content and information.
  INDUSTRY_PUBLISHING,         // Publishing.
  INDUSTRY_TELECOM,            // Telecom services.
  // Consumer cyclical.
  INDUSTRY_APPAREL_MANUFACTURING,  // Apparel manufacturing.
  INDUSTRY_APPAREL_RETAIL,         // Apparel retail.
  INDUSTRY_AUTO_MANUFACTURERS,     // Auto manufacturers.
  INDUSTRY_AUTO_PARTS,             // Auto parts.
  INDUSTRY_AUTO_DEALERSHIP,        // Auto and truck dealerships.
  INDUSTRY_DEPARTMENT_STORES,      // Department stores.
  INDUSTRY_FOOTWEAR_ACCESSORIES,   // Footwear and accessories.
  INDUSTRY_FURNISHINGS,            // Furnishing, fixtures and appliances.
  INDUSTRY_GAMBLING,               // Gambling.
  INDUSTRY_HOME_IMPROV_RETAIL,     // Home improvement retail.
  INDUSTRY_INTERNET_RETAIL,        // Internet retail.
  INDUSTRY_LEISURE,                // Leisure.
  INDUSTRY_LODGING,                // Lodging.
  INDUSTRY_LUXURY_GOODS,           // Luxury goods.
  INDUSTRY_PACKAGING_CONTAINERS,   // Packaging and containers.
  INDUSTRY_PERSONAL_SERVICES,      // Personal services.
  INDUSTRY_RECREATIONAL_VEHICLES,  // Recreational vehicles.
  INDUSTRY_RESIDENT_CONSTRUCTION,  // Residential construction.
  INDUSTRY_RESORTS_CASINOS,        // Resorts and casinos.
  INDUSTRY_RESTAURANTS,            // Restaurants.
  INDUSTRY_SPECIALTY_RETAIL,       // Specialty retail.
  INDUSTRY_TEXTILE_MANUFACTURING,  // Textile manufacturing.
  INDUSTRY_TRAVEL_SERVICES,        // Travel services.
  // Consumer defensive.
  INDUSTRY_BEVERAGES_BREWERS,   // Beverages - Brewers.
  INDUSTRY_BEVERAGES_NON_ALCO,  // Beverages - Non-alcoholic.
  INDUSTRY_BEVERAGES_WINERIES,  // Beverages - Wineries and distilleries.
  INDUSTRY_CONFECTIONERS,       // Confectioners.
  INDUSTRY_DISCOUNT_STORES,     // Discount stores.
  INDUSTRY_EDUCATION_TRAINIG,   // Education and training services.
  INDUSTRY_FARM_PRODUCTS,       // Farm products.
  INDUSTRY_FOOD_DISTRIBUTION,   // Food distribution.
  INDUSTRY_GROCERY_STORES,      // Grocery stores.
  INDUSTRY_HOUSEHOLD_PRODUCTS,  // Household and personal products.
  INDUSTRY_PACKAGED_FOODS,      // Packaged foods.
  INDUSTRY_TOBACCO,             // Tobacco.
  // Energy.
  INDUSTRY_OIL_GAS_DRILLING,    // Oil and gas drilling.
  INDUSTRY_OIL_GAS_EP,          // Oil and gas extraction and processing.
  INDUSTRY_OIL_GAS_EQUIPMENT,   // Oil and gas equipment and services.
  INDUSTRY_OIL_GAS_INTEGRATED,  // Oil and gas integrated.
  INDUSTRY_OIL_GAS_MIDSTREAM,   // Oil and gas midstream.
  INDUSTRY_OIL_GAS_REFINING,    // Oil and gas refining and marketing.
  INDUSTRY_THERMAL_COAL,        // Thermal coal.
  INDUSTRY_URANIUM,             // Uranium.
  // Finance.
  INDUSTRY_EXCHANGE_TRADED_FUND,     // Exchange traded fund.
  INDUSTRY_ASSETS_MANAGEMENT,        // Assets management.
  INDUSTRY_BANKS_DIVERSIFIED,        // Banks - Diversified.
  INDUSTRY_BANKS_REGIONAL,           // Banks - Regional.
  INDUSTRY_CAPITAL_MARKETS,          // Capital markets.
  INDUSTRY_CLOSE_END_FUND_DEBT,      // Closed-End fund - Debt.
  INDUSTRY_CLOSE_END_FUND_EQUITY,    // Closed-end fund - Equity.
  INDUSTRY_CLOSE_END_FUND_FOREIGN,   // Closed-end fund - Foreign.
  INDUSTRY_CREDIT_SERVICES,          // Credit services.
  INDUSTRY_FINANCIAL_CONGLOMERATE,   // Financial conglomerates.
  INDUSTRY_FINANCIAL_DATA_EXCHANGE,  // Financial data and stock exchange.
  INDUSTRY_INSURANCE_BROKERS,        // Insurance brokers.
  INDUSTRY_INSURANCE_DIVERSIFIED,    // Insurance - Diversified.
  INDUSTRY_INSURANCE_LIFE,           // Insurance - Life.
  INDUSTRY_INSURANCE_PROPERTY,       // Insurance - Property and casualty.
  INDUSTRY_INSURANCE_REINSURANCE,    // Insurance - Reinsurance.
  INDUSTRY_INSURANCE_SPECIALTY,      // Insurance - Specialty.
  INDUSTRY_MORTGAGE_FINANCE,         // Mortgage finance.
  INDUSTRY_SHELL_COMPANIES,          // Shell companies.
  // Healthcare.
  INDUSTRY_BIOTECHNOLOGY,             // Biotechnology.
  INDUSTRY_DIAGNOSTICS_RESEARCH,      // Diagnostics and research.
  INDUSTRY_DRUGS_MANUFACTURERS,       // Drugs manufacturers - general.
  INDUSTRY_DRUGS_MANUFACTURERS_SPEC,  // Drugs manufacturers - Specialty and generic.
  INDUSTRY_HEALTHCARE_PLANS,          // Healthcare plans.
  INDUSTRY_HEALTH_INFORMATION,        // Health information services.
  INDUSTRY_MEDICAL_FACILITIES,        // Medical care facilities.
  INDUSTRY_MEDICAL_DEVICES,           // Medical devices.
  INDUSTRY_MEDICAL_DISTRIBUTION,      // Medical distribution.
  INDUSTRY_MEDICAL_INSTRUMENTS,       // Medical instruments and supplies.
  INDUSTRY_PHARM_RETAILERS,           // Pharmaceutical retailers.
  // Industrials.
  INDUSTRY_AEROSPACE_DEFENSE,           // Aerospace and defense.
  INDUSTRY_AIRLINES,                    // Airlines.
  INDUSTRY_AIRPORTS_SERVICES,           // Airports and air services.
  INDUSTRY_BUILDING_PRODUCTS,           // Building products and equipment.
  INDUSTRY_BUSINESS_EQUIPMENT,          // Business equipment and supplies.
  INDUSTRY_CONGLOMERATES,               // Conglomerates.
  INDUSTRY_CONSULTING_SERVICES,         // Consulting services.
  INDUSTRY_ELECTRICAL_EQUIPMENT,        // Electrical equipment and parts.
  INDUSTRY_ENGINEERING_CONSTRUCTION,    // Engineering and construction.
  INDUSTRY_FARM_HEAVY_MACHINERY,        // Farm and heavy construction machinery.
  INDUSTRY_INDUSTRIAL_DISTRIBUTION,     // Industrial distribution.
  INDUSTRY_INFRASTRUCTURE_OPERATIONS,   // Infrastructure operations.
  INDUSTRY_FREIGHT_LOGISTICS,           // Integrated freight and logistics.
  INDUSTRY_MARINE_SHIPPING,             // Marine shipping.
  INDUSTRY_METAL_FABRICATION,           // Metal fabrication.
  INDUSTRY_POLLUTION_CONTROL,           // Pollution and treatment controls.
  INDUSTRY_RAILROADS,                   // Railroads.
  INDUSTRY_RENTAL_LEASING,              // Rental and leasing services.
  INDUSTRY_SECURITY_PROTECTION,         // Security and protection services.
  INDUSTRY_SPEALITY_BUSINESS_SERVICES,  // Specialty business services.
  INDUSTRY_SPEALITY_MACHINERY,          // Specialty industrial machinery.
  INDUSTRY_STUFFING_EMPLOYMENT,         // Stuffing and employment services.
  INDUSTRY_TOOLS_ACCESSORIES,           // Tools and accessories.
  INDUSTRY_TRUCKING,                    // Trucking.
  INDUSTRY_WASTE_MANAGEMENT,            // Waste management.
  // Real estate.
  INDUSTRY_REAL_ESTATE_DEVELOPMENT,  // Real estate - Development.
  INDUSTRY_REAL_ESTATE_DIVERSIFIED,  // Real estate - Diversified.
  INDUSTRY_REAL_ESTATE_SERVICES,     // Real estate services.
  INDUSTRY_REIT_DIVERSIFIED,         // REIT - Diversified.
  INDUSTRY_REIT_HEALTCARE,           // REIT - Healthcase facilities.
  INDUSTRY_REIT_HOTEL_MOTEL,         // REIT - Hotel and motel.
  INDUSTRY_REIT_INDUSTRIAL,          // REIT - Industrial.
  INDUSTRY_REIT_MORTAGE,             // REIT - Mortgage.
  INDUSTRY_REIT_OFFICE,              // REIT - Office.
  INDUSTRY_REIT_RESIDENTAL,          // REIT - Residential.
  INDUSTRY_REIT_RETAIL,              // REIT - Retail.
  INDUSTRY_REIT_SPECIALITY,          // REIT - Specialty.
  // Technology.
  INDUSTRY_COMMUNICATION_EQUIPMENT,  // Communication equipment.
  INDUSTRY_COMPUTER_HARDWARE,        // Computer hardware.
  INDUSTRY_CONSUMER_ELECTRONICS,     // Consumer electronics.
  INDUSTRY_ELECTRONIC_COMPONENTS,    // Electronic components.
  INDUSTRY_ELECTRONIC_DISTRIBUTION,  // Electronics and computer distribution.
  INDUSTRY_IT_SERVICES,              // Information technology services.
  INDUSTRY_SCIENTIFIC_INSTRUMENTS,   // Scientific and technical instruments.
  INDUSTRY_SEMICONDUCTOR_EQUIPMENT,  // Semiconductor equipment and materials.
  INDUSTRY_SEMICONDUCTORS,           // Semiconductors.
  INDUSTRY_SOFTWARE_APPLICATION,     // Software - Application.
  INDUSTRY_SOFTWARE_INFRASTRUCTURE,  // Software - Infrastructure.
  INDUSTRY_SOLAR,                    // Solar.
  // Utilities.
  INDUSTRY_UTILITIES_DIVERSIFIED,         // Utilities - Diversified.
  INDUSTRY_UTILITIES_POWERPRODUCERS,      // Utilities - Independent power producers.
  INDUSTRY_UTILITIES_RENEWABLE,           // Utilities - Renewable.
  INDUSTRY_UTILITIES_REGULATED_ELECTRIC,  // Utilities - Regulated electric.
  INDUSTRY_UTILITIES_REGULATED_GAS,       // Utilities - Regulated gas.
  INDUSTRY_UTILITIES_REGULATED_WATER,     // Utilities - Regulated water.
  INDUSTRY_UTILITIES_FIRST,               // Start of the utilities services types enumeration.
  INDUSTRY_UTILITIES_LAST,                // End of the utilities services types enumeration.
};
#endif

// Enum constants.
const ENUM_SYMBOL_INFO_INTEGER market_icache[] = {
    SYMBOL_DIGITS,          SYMBOL_EXPIRATION_MODE, SYMBOL_FILLING_MODE,
    SYMBOL_ORDER_MODE,      SYMBOL_SWAP_MODE,       SYMBOL_SWAP_ROLLOVER3DAYS,
    SYMBOL_TRADE_CALC_MODE, SYMBOL_TRADE_EXEMODE,   SYMBOL_TRADE_MODE};

// Enum constants.
const ENUM_SYMBOL_INFO_DOUBLE market_dcache[] = {SYMBOL_MARGIN_INITIAL,
                                                 SYMBOL_MARGIN_LIMIT,
                                                 SYMBOL_MARGIN_LONG,
                                                 SYMBOL_MARGIN_MAINTENANCE,
                                                 SYMBOL_MARGIN_SHORT,
                                                 SYMBOL_MARGIN_STOP,
                                                 SYMBOL_MARGIN_STOPLIMIT,
                                                 SYMBOL_POINT,
                                                 SYMBOL_SWAP_LONG,
                                                 SYMBOL_SWAP_SHORT,
                                                 SYMBOL_TRADE_CONTRACT_SIZE,
                                                 SYMBOL_TRADE_TICK_SIZE,
                                                 SYMBOL_TRADE_TICK_VALUE,
                                                 SYMBOL_TRADE_TICK_VALUE_LOSS,
                                                 SYMBOL_TRADE_TICK_VALUE_PROFIT,
                                                 SYMBOL_VOLUME_LIMIT,
                                                 SYMBOL_VOLUME_MAX,
                                                 SYMBOL_VOLUME_MIN,
                                                 SYMBOL_VOLUME_STEP};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SymbolInfo.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Array.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.


// Defines.
#ifndef MODE_ASCEND
#define MODE_ASCEND 0
#endif
#ifndef MODE_DESCEND
#define MODE_DESCEND 1
#endif
// Other constants.
// @see https://docs.mql4.com/constants/namedconstants/otherconstants
#ifndef WHOLE_ARRAY
// Indicates that all array elements will be processed.
#define WHOLE_ARRAY 0
#endif

/*
 * Class to provide methods to deal with arrays.
 */
class Array {
 public:
  /**
   * Finds the median value in the array of any numeric type.
   */
  template <typename T>
  static T Median(ARRAY_REF(T, _arr)) {
    int _size = ArraySize(_arr);
    if (_size > 0) {
      ArraySort(_arr);
      return _arr[_size / 2];
    } else {
      return 0;
    }
  }

  /**
   * Finds the highest value in the array of any numeric type.
   */
  template <typename T>
  static T Sum(ARRAY_REF(T, _arr)) {
    int i;
    int _size = ArraySize(_arr);
    if (_size > 0) {
      T _sum = _arr[0];
      for (i = 1; i < _size; i++) {
        _sum += _arr[i];
      }
      return _sum;
    } else {
      return 0;
    }
  }

  /**
   * Finds the highest value in the array of any numeric type.
   */
  template <typename T>
  static T Max(ARRAY_REF(T, _arr)) {
    int i;
    int _size = ArraySize(_arr);
    if (_size > 0) {
      T _max = _arr[0];
      for (i = 1; i < _size; i++) {
        _max = _max < _arr[i] ? _arr[i] : _max;
      }
      return _max;
    } else {
      return 0;
    }
  }

  template <typename T>
  static int ArrayCopy(ARRAY_REF(T, dst_array), const ARRAY_REF(T, src_array), const int dst_start = 0,
                       const int src_start = 0, const int count = WHOLE_ARRAY) {
    throw NotImplementedException();
  }

  /**
   * Return plain text of array values separated by the delimiter.
   *
   * @param
   *   int arr[] - array to look for the values
   *   string sep - delimiter to separate array values
   */
  static string GetArrayValues(ARRAY_REF(int, arr), string sep = ", ") {
    int i;
    string result = "";
    for (i = 0; i < ArraySize(arr); i++) {
      result += StringFormat("%d:%d%s", i, arr[i], sep);
    }
    // Return text without last separator.
    return StringSubstr(result, 0, StringLen(result) - StringLen(sep));
  }

  /**
   * Return plain text of array values separated by the delimiter.
   *
   * @param
   *   double arr[] - array to look for the values
   *   string sep - delimiter to separate array values
   */
  static string GetArrayValues(ARRAY_REF(double, arr), string sep = ", ") {
    int i;
    string result = "";
    for (i = 0; i < ArraySize(arr); i++) {
      result += StringFormat("%d:%g%s", i, arr[i], sep);
    }
    // Return text without last separator.
    return StringSubstr(result, 0, StringLen(result) - StringLen(sep));
  }

  /**
   * Find lower value within the 1-dim array of floats.
   */
  static double LowestArrValue(ARRAY_REF(double, arr)) { return (arr[ArrayMinimum(arr)]); }

  /**
   * Find higher value within the 1-dim array of floats.
   */
  static double HighestArrValue(ARRAY_REF(double, arr)) { return (arr[ArrayMaximum(arr)]); }

/**
 * Find lower value within the 2-dim array of floats by the key.
 */
#ifdef __MQL4__
  static double LowestArrValue2(double& arr[][], int key1) {
    int i;
    double lowest = 999;
    for (i = 0; i < ArrayRange(arr, 1); i++) {
      if (arr[key1][i] < lowest) {
        lowest = arr[key1][i];
      }
    }
    return lowest;
  }
#else
// @todo
#endif

/**
 * Find higher value within the 2-dim array of floats by the key.
 */
#ifdef __MQL4__
  static double HighestArrValue2(double& arr[][], int key1) {
    double highest = -1;
    int i;
    for (i = 0; i < ArrayRange(arr, 1); i++) {
      if (arr[key1][i] > highest) {
        highest = arr[key1][i];
      }
    }
    return highest;
  }
#else
// @todo
#endif

/**
 * Find highest value in 2-dim array of integers by the key.
 */
#ifdef __MQL4__
  static int HighestValueByKey(int& arr[][], int key) {
    int highest = -1;
    int i;
    for (i = 0; i < ArrayRange(arr, 1); i++) {
      if (arr[key][i] > highest) {
        highest = arr[key][i];
      }
    }
    return highest;
  }
#else
// @todo
#endif

/**
 * Find lowest value in 2-dim array of integers by the key.
 */
#ifdef __MQL4__
  static int LowestValueByKey(int& arr[][], int key) {
    int i;
    int lowest = 999;
    for (i = 0; i < ArrayRange(arr, 1); i++) {
      if (arr[key][i] < lowest) {
        lowest = arr[key][i];
      }
    }
    return lowest;
  }
#else
// @todo
#endif

/*
#ifdef __MQL4__
static int GetLowestArrDoubleValue(double& arr[][], int key) {
  int i, j;
  double lowest = -1;
  for (i = 0; i < ArrayRange(arr, 0); i++) {
    for (j = 0; j < ArrayRange(arr, 1); j++) {
      if (arr[i][j] < lowest) {
        lowest = arr[i][j];
      }
    }
  }
  return lowest;
}
#else
// @todo
#endif
*/

/**
 * Find key in array of integers with the highest value.
 */
#ifdef __MQL4__
  static int GetArrKey1ByHighestKey2Value(int& arr[][], int key2) {
    int i;
    int key1 = EMPTY;
    int highest = 0;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      if (arr[i][key2] > highest) {
        highest = arr[i][key2];
        key1 = i;
      }
    }
    return key1;
  }
#else
// @todo
#endif

/**
 * Find key in array of integers with the lowest value.
 */
#ifdef __MQL4__
  static int GetArrKey1ByLowestKey2Value(int& arr[][], int key2) {
    int i;
    int key1 = EMPTY;
    int lowest = 999;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      if (arr[i][key2] < lowest) {
        lowest = arr[i][key2];
        key1 = i;
      }
    }
    return key1;
  }
#else
// @todo
#endif

/**
 * Find key in array of doubles with the highest value.
 */
#ifdef __MQL4__
  static int GetArrKey1ByHighestKey2ValueD(double& arr[][], int key2) {
    int i;
    int key1 = EMPTY;
    double highest = -1;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      if (arr[i][key2] > highest) {
        highest = arr[i][key2];
        key1 = i;
      }
    }
    return key1;
  }
#else
// @todo
#endif

/**
 * Find key in array of doubles with the lowest value.
 */
#ifdef __MQL4__
  static int GetArrKey1ByLowestKey2ValueD(double& arr[][], int key2) {
    int i;
    int key1 = EMPTY;
    double lowest = 999;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      if (arr[i][key2] < lowest) {
        lowest = arr[i][key2];
        key1 = i;
      }
    }
    return key1;
  }
#else
// @todo
#endif

/**
 * Set array value for double items with specific keys.
 */
#ifdef __MQL4__
  static void ArrSetValueD(double& arr[][], int key, double value) {
    int i;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      arr[i][key] = value;
    }
  }
#else
// @todo
#endif

/**
 * Set array value for integer items with specific keys.
 */
#ifdef __MQL4__
  static void ArrSetValueI(int& arr[][], int key, int value) {
    int i;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      arr[i][key] = value;
    }
  }
#else
// @todo
#endif

/**
 * Calculate sum of 2 dimentional array based on given key.
 */
#ifdef __MQL4__
  static double GetArrSumKey1(double& arr[][], int key1, int offset = 0) {
    int i;
    double sum = 0;
    offset = MathMin(offset, ArrayRange(arr, 1) - 1);
    for (i = offset; i < ArrayRange(arr, 1); i++) {
      sum += arr[key1][i];
    }
    return sum;
  }
#else
// @todo
#endif

  /**
   * Print a one-dimensional array.
   *
   * @param int arr
   *   The one dimensional array of integers.
   * @param string dlm
   *   Delimiter to separate the items.
   *
   * @return string
   *   String representation of array.
   */
  static string ArrToString(ARRAY_REF(int, arr), string dlm = ",") {
    int i;
    string res = "";
    for (i = 0; i < ArraySize(arr); i++) {
      res += IntegerToString(arr[i]) + dlm;
    }
    res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
    return res;
  }

  /**
   * Print a one-dimensional array.
   *
   * @param double arr
   *   The one dimensional array of doubles.
   * @param string dlm
   *   Delimiter to separate the items.
   *
   * @return string
   *   String representation of array.
   */
  static string ArrToString(ARRAY_REF(double, arr), string dlm = ",", int digits = 2) {
    int i;
    string res = "";
    for (i = 0; i < ArraySize(arr); i++) {
      res += StringFormat("%g%s", NormalizeDouble(arr[i], digits), dlm);
    }
    res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
    return res;
  }

  /**
   * Print a one-dimensional array in hex format.
   *
   * @param double unsigned char[]
   *   The one dimensional array of characters.
   * @param int count
   *   If specified, limit the number of printed characters.
   *
   * @return string
   *   String representation of array in hexadecimal format.
   */
  static string ArrToHex(ARRAY_REF(unsigned char, arr), int count = -1) {
    int i;
    string res;
    for (i = 0; i < (count > 0 ? count : ArraySize(arr)); i++) {
      res += StringFormat("%.2X", arr[i]);
    }
    return res;
  }

/**
 * Print a two-dimensional array.
 *
 * @param string arr
 *   The two dimensional array of doubles.
 * @param string dlm
 *   Delimiter to separate the items.
 * @param string digits
 *   Number of digits after point.
 *
 * @return string
 *   String representation of array.
 */
#ifdef __MQL4__
  static string ArrToString2D(double& arr[][], string dlm = ",", int digits = 2) {
    string res = "";
    int i, j;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      res += "[";
      for (j = 0; j < ArrayRange(arr, 1); j++) {
        res += StringFormat("%g%s", NormalizeDouble(arr[i][j], digits), dlm);
      }
      res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
      res += "]" + dlm;
    }
    res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
    return res;
  }
#else
// @todo
#endif

/**
 * Print a three-dimensional array.
 *
 * @param string arr
 *   The three dimensional array of doubles.
 * @param string dlm
 *   Delimiter to separate the items.
 * @param string digits
 *   Number of digits after point.
 *
 * @return string
 *   String representation of array.
 */
#ifdef __MQL4__
  static string ArrToString3D(double& arr[][][], string dlm = ",", int digits = 2) {
    string res = "";
    int i, j, k;
    for (i = 0; i < ArrayRange(arr, 0); i++) {
      res += "[";
      for (j = 0; j < ArrayRange(arr, 1); j++) {
        res += "[";
        for (k = 0; k < ArrayRange(arr, 2); k++) {
          res += StringFormat("%g%s", NormalizeDouble(arr[i][j][k], digits), dlm);
        }
        res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
        res += "]" + dlm;
      }
      res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
      res += "]" + dlm;
    }
    res = StringSubstr(res, 0, StringLen(res) - StringLen(dlm));
    return res;
  }
#else
// @todo
#endif

  /**
   * Print a one-dimensional array.
   *
   * @param string arr
   *   The one dimensional array of strings.
   * @param string dlm
   *   Delimiter to separate the items.
   * @param string prefix
   *   Prefix to add if array is non-empty.
   * @param string suffix
   *   Suffix to add if array is non-empty.
   *
   * @return string
   *   String representation of array.
   */
  static string ArrToString(ARRAY_REF(string, arr), string dlm = ",", string prefix = "", string suffix = "") {
    int i;
    string output = "";
    if (ArraySize(arr) > 0) output += prefix;
    for (i = 0; i < ArraySize(arr); i++) {
      output += (string)arr[i] + dlm;
    }
    output = StringSubstr(output, 0, StringLen(output) - StringLen(dlm));
    if (ArraySize(arr) > 0) output += suffix;
    return output;
  }

  /**
   * Prints an array of a simple type.
   *
   * @docs:
   * - https://www.mql5.com/en/docs/array/arrayprint
   */
  template <typename T>
  void ArrayPrint(ARRAY_REF(T, _arr),         // Printed array.
                  int _digits = NULL,         // Number of decimal places.
                  const string _dlm = NULL,   // Separator of the structure field values.
                  long _start = 0,            // First printed element index.
                  long _count = WHOLE_ARRAY,  // Number of printed elements.
                  long _flags = NULL) {
#ifdef __MQL5__
    ::ArrayPrint(_arr, _digits, _dlm, _start, _count, _flags);
#else
    int i;
    string output = "";
    for (i = _start; i < _count == WHOLE_ARRAY ? ArraySize(_arr) : _count; i++) {
      output += (string)_arr[i] + _dlm;
    }
    Print(output);
#endif
  }

  /**
   * Resize array from the left.
   *
   * @param string arr
   *   The one dimensional array of doubles.
   * @param int _new_size
   *   New size of array.
   *
   * @return bool
   *   Returns count of all elements contained in the array after resizing,
   *   otherwise returns -1 without resizing array.
   *
   * @see: http://www.forexfactory.com/showthread.php?p=2878455#post2878455
   */
  static int ArrayResizeLeft(ARRAY_REF(double, arr), int _new_size, int _reserve_size = 0) {
    ArraySetAsSeries(arr, true);
    int _res = ArrayResize(arr, _new_size, _reserve_size);
    ArraySetAsSeries(arr, false);
    return _res;
  }

  /**
   * Sorts numeric arrays by first dimension.
   *
   * @param &array[] arr
   *   Numeric array for sorting.
   * @param int count
   *   Count of elements to sort. By default, it sorts the whole array (WHOLE_ARRAY).
   * @param int start
   *   Starting index to sort. By default, the sort starts at the first element.
   * @param int direction
   *   Sort direction. It can be any of the following values: MODE_ASCEND or MODE_DESCEND.
   *
   * @return bool
   *   The function returns true on success, otherwise false.
   *
   * @docs:
   *   - https://docs.mql4.com/array/arraysort
   *   - https://www.mql5.com/en/docs/array/arraysort
   *   - https://www.mql5.com/en/docs/array/array_reverse
   */
  // One dimensional array.
  template <typename T>
  static bool ArraySort(ARRAY_REF(T, arr), int count = WHOLE_ARRAY, int start = 0, int direction = MODE_ASCEND) {
#ifdef __MQL4__
    return ::ArraySort(arr, count, start, direction);
#else
    if (direction == MODE_DESCEND) {
      return ::ArrayReverse(arr, start, count);
    } else {
      // @fixme: Add support for _count and _start.
      return ::ArraySort(arr);
    }
#endif
  }
// Two dimensional array.
#ifdef __MQL4__
  template <typename T>
  static bool ArraySort2D(T& arr[][], int count = WHOLE_ARRAY, int start = 0, int direction = MODE_ASCEND) {
#ifdef __MQL4__
    return (bool)::ArraySort(arr, count, start, direction);
#else
    if (direction == MODE_DESCEND) {
      return ::ArrayReverse(arr, start, count);
    } else {
      // @fixme: Add support for _count amd _start.
      return ::ArraySort(arr);
    }
#endif
  }
#endif

  /**
   * Resizes array and fills allocated slots with given value.
   *
   * @param &array[] array
   *   Single dimensonal array. For multi-dimensional array consider: template <typename X, typename Y> int
   * ArrayResizeFill(X &array[][2], int new_size, int reserve_size = 0, Y fill_value = EMPTY) { ... }
   * @param int new_size
   *   New array size.
   * @param reserve_size
   *   Reserve size value (excess).
   * @param fill_value
   *   Value to be used as filler for allocated slots.
   * @return int
   *   Returns the same value as ArrayResize function (count of all elements contained in the array after resizing or -1
   * if error occured).
   */
  template <typename X, typename Y>
  static int ArrayResizeFill(ARRAY_REF(X, array), int new_size, int reserve_size = 0, Y fill_value = EMPTY_VALUE) {
    const int old_size = ArrayRange(array, 0);

    if (new_size <= old_size) return old_size;

    // We want to fill all allocated slots (the whole allocated memory).
    const int allocated_size = MathMax(new_size, reserve_size);

    int result = ArrayResize(array, new_size, reserve_size);

    ArrayFill(array, old_size, allocated_size - old_size, fill_value);

    return result;
  }

  /**
   * Initializes a numeric array by a preset value.
   *
   * @param array[]
   *   Numeric array that should be initialized.
   * @param char value
   *   New value that should be set to all array elements.
   * @return int
   *   Number of initialized elements.
   *
   * @docs
   * - https://docs.mql4.com/array/arrayinitialize
   * - https://www.mql5.com/en/docs/array/arrayinitialize
   */
  template <typename X>
  static int ArrayInitialize(ARRAY_REF(X, array), char value) {
    return ::ArrayInitialize(array, value);
  }

  /**
   * Searches for the lowest element in the first dimension of a multidimensional numeric array.
   *
   * @param void &array[]
   *   A numeric array, in which search is made.
   * @param int start
   *   Index to start checking with.
   * @param int count
   *   Number of elements for search. By default, searches in the entire array.
   * @return int
   *   The function returns an index of a found element.
   *
   * @docs
   * - https://docs.mql4.com/array/arraymaximum
   * - https://www.mql5.com/en/docs/array/arraymaximum
   */
  template <typename X>
  static int ArrayMinimum(const ARRAY_REF(X, _array), int _start = 0, int _count = WHOLE_ARRAY) {
#ifdef __MQL__
    return ::ArrayMinimum(_array);
#else
    int _peak_index = 0;

    for (int i = 1; i < ArraySize(_array); ++i) {
      if (_array[i] < _array[_peak_index]) {
        _peak_index = i;
      }
    }

    return _peak_index;
#endif
  }

  /**
   * Searches for the largest element in the first dimension of a multidimensional numeric array.
   *
   * @param void &array[]
   *   A numeric array, in which search is made.
   * @param int start
   *   Index to start checking with.
   * @param int count
   *   Number of elements for search. By default, searches in the entire array.
   * @return int
   *   The function returns an index of a found element.
   *
   * @docs
   * - https://docs.mql4.com/array/arraymaximum
   * - https://www.mql5.com/en/docs/array/arraymaximum
   */
  template <typename X>
  static int ArrayMaximum(const ARRAY_REF(X, _array), int start = 0, int count = WHOLE_ARRAY) {
#ifdef __MQL__
    return ::ArrayMaximum(_array);
#else
    int _peak_index = 0;

    for (int i = 1; i < ArraySize(_array); ++i) {
      if (_array[i] > _array[_peak_index]) {
        _peak_index = i;
      }
    }

    return _peak_index;
#endif
  }

  /**
   * Returns the number of elements of a selected array.
   *
   * @param void &array[]
   *   Array of any type.
   * @return int
   *   Value of int type.
   *
   * @docs
   * - https://docs.mql4.com/array/arraysize
   * - https://www.mql5.com/en/docs/array/arraysize
   */
  template <typename X>
  static int ArraySize(ARRAY_REF(X, array)) {
    return ::ArraySize(array);
  }

  template <typename X>
  static void ArrayStore(ARRAY_REF(X, array), int index, X value, int reserve_size = 0) {
    if (index >= ArraySize(array)) {
      ArrayResize(array, MathMax(index + 1, ArraySize(array)), reserve_size);
    }

    array[index] = value;
  }
};

template <typename X>
void ArrayPush(ARRAY_REF(X, array), X value) {
  ArrayResize(Array::ArraySize(array) + 1);
  array[ArraySize(array) - 1] = value;
}
template <typename X>
void ArrayPushObject(ARRAY_REF(X, array), X& value) {
  ArrayResize(array, Array::ArraySize(array) + 1);
  array[Array::ArraySize(array) - 1] = value;
}

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Array.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef CONVERT_MQH
#define CONVERT_MQH

// Includes.






/**
 * Class to provide conversion methods.
 */
class Convert {
 public:
  /*
   * Returns order type as buy or sell.
   *
   * @param
   *   op_type int Order operation type of the order.
   *
   * @return
   *   Returns OP_BUY for buy related orders,
   *   OP_SELL for sell related orders,
   *   otherwise EMPTY (-1).
   */
  static ENUM_ORDER_TYPE OrderTypeBuyOrSell(ENUM_ORDER_TYPE _cmd) {
    switch (_cmd) {
      case ORDER_TYPE_SELL:
      case ORDER_TYPE_SELL_LIMIT:
      case ORDER_TYPE_SELL_STOP:
        return ORDER_TYPE_SELL;
      case ORDER_TYPE_BUY:
      case ORDER_TYPE_BUY_LIMIT:
      case ORDER_TYPE_BUY_STOP:
        return ORDER_TYPE_BUY;
      default:
        return (ENUM_ORDER_TYPE)WRONG_VALUE;
    }
  }

  /**
   * Return command operation based on the value.
   *
   * @param
   *   value int
   *     Value to convert.
   *
   * @return
   *   Returns OP_BUY when value is positive, OP_SELL when negative, otherwise -1.
   */
  static ENUM_ORDER_TYPE ValueToOp(int value) {
    return value == 0 ? (ENUM_ORDER_TYPE)-1 : (value > 0 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL);
  }

  /**
   * Return command operation based on the value.
   *
   * @param
   *   value double
   *     Value to convert.
   *
   * @return
   *   Returns OP_BUY when value is positive, OP_SELL when negative, otherwise -1.
   */
  static ENUM_ORDER_TYPE ValueToOp(double value) {
    return value == 0 ? (ENUM_ORDER_TYPE)-1 : (value > 0 ? ORDER_TYPE_BUY : ORDER_TYPE_SELL);
  }

  /**
   * Points per pip given digits after decimal point of a symbol price.
   */
  static uint PointsPerPip(uint digits) { return (uint)pow(10, digits - (digits < 4 ? 2 : 4)); }

  /**
   * Returns number of points per pip.
   */
  static uint PointsPerPip(string _symbol = NULL) {
    return PointsPerPip((uint)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS));
  }

  /**
   * Convert pips into price value.
   *
   */
  static double PipsToValue(double pips, int digits) {
    switch (digits) {
      case 0:
      case 1:
        return pips * 1.0;
      case 2:
      case 3:
        return pips * 0.01;
      case 4:
      case 5:
      default:
        return pips * 0.0001;
    }
  }

  /**
   * Convert pips into price value.
   */
  static double PipsToValue(double pips, string _symbol = NULL) {
    return PipsToValue(pips, (uint)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS));
  }

  /**
   * Convert value into pips given price value and digits.
   */
  static double ValueToPips(double value, uint digits) { return value * pow(10, digits < 4 ? 2 : 4); }

  /**
   * Convert value into pips.
   */
  static double ValueToPips(double value, string _symbol = NULL) {
    return ValueToPips(value, (uint)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS));
  }

  /**
   * Convert pips into points.
   */
  static uint PipsToPoints(double pips, int digits) { return (uint)pips * PointsPerPip(digits); }

  /**
   * Convert pips into points.
   */
  static uint PipsToPoints(double pips, string _symbol = NULL) {
    return PipsToPoints(pips, (uint)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS));
  }

  /**
   * Convert points into pips.
   */
  static double PointsToPips(long pts, int digits) { return (double)(pts / PointsPerPip(digits)); }

  /**
   * Convert points into pips.
   */
  static double PointsToPips(long pts, string _symbol = NULL) {
    return PointsToPips(pts, (uint)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS));
  }

  /**
   * Convert points into price value.
   *
   */
  static double PointsToValue(long pts, int mode, string _symbol = NULL) {
    switch (mode) {
      case 0:  // Forex.
        // In currencies a tick is a point.
        return pts * SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_TRADE_TICK_SIZE);
      case 1:  // CFD.
        // In metals a Tick is still the smallest change, but is larger than a point.
        // If price can change from 123.25 to 123.50,
        // you have a TickSize of 0.25 and a point of 0.01. Pip has no meaning.
        // @todo
        return pts * SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_TRADE_TICK_SIZE);
      case 2:  // Futures.
        // @todo
        return pts * SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_TRADE_TICK_SIZE);
      case 3:  // CFD for indices.
        // @todo
        return pts * SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_TRADE_TICK_SIZE);
    }
    return false;
  }

  /**
   * Convert points into price value.
   */
  static double PointsToValue(long pts, int mode, int digits) {
    switch (mode) {
      case 0:  // Forex.
        return PipsToValue((double)pts / PointsPerPip(digits), digits);
      case 1:  // CFD.
        // In metals a Tick is still the smallest change, but is larger than a point.
        // @todo
        return PipsToValue((double)pts / PointsPerPip(digits), digits);
      case 2:  // Futures.
        // @todo
        return PipsToValue((double)pts / PointsPerPip(digits), digits);
      case 3:  // CFD for indices.
        // @todo
        return PipsToValue((double)pts / PointsPerPip(digits), digits);
    }
    return false;
  }

  /**
   * Convert points into price value.
   */
  static double PointsToValue(long pts, string _symbol = NULL) {
    return PointsToValue(pts, (int)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_TRADE_CALC_MODE));
  }

  /**
   * Convert price value into money value in base currency.
   *
   * @return
   *   Returns amount in a base currency based on the given the value.
   */
  static double ValueToMoney(double value, string _symbol = NULL) {
    double _tick_value = SymbolInfoStatic::GetTickValue(_symbol) > 0 ? SymbolInfoStatic::GetTickValue(_symbol) : 1;
    return value * _tick_value / SymbolInfoStatic::GetPointSize(_symbol);
  }

  /**
   * Convert money to value.
   *
   * @return
   *   Returns value in points equivalent to the amount in a base currency.
   */
  static float MoneyToValue(float money, float lot_size, string _symbol = NULL) {
    double _tick_value = SymbolInfoStatic::GetTickValue(_symbol) > 0 ? SymbolInfoStatic::GetTickValue(_symbol) : 1;
    return money > 0 && lot_size > 0 ? float(money / _tick_value * SymbolInfoStatic::GetPointSize(_symbol) / lot_size)
                                     : 0;
  }

  /**
   * Get the difference between two price values (in pips).
   */
  static double GetValueDiffInPips(double price1, double price2, bool abs = false, int digits = NULL,
                                   string _symbol = NULL) {
    digits = digits ? digits : (int)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS);
    return ValueToPips(abs ? fabs(price1 - price2) : (price1 - price2), digits);
  }

  /**
   * Add currency sign to the plain value.
   */
  static string ValueWithCurrency(double value, int digits = 2, string currency = "USD") {
    unsigned char sign;
    bool prefix = true;
    currency = currency == "" ? AccountInfoString(ACCOUNT_CURRENCY) : currency;
    if (currency == "USD")
      sign = (unsigned char)'$';
    else if (currency == "GBP")
      sign = (unsigned char)0xA3;  // ANSI code.
    else if (currency == "EUR")
      sign = (unsigned char)0x80;  // ANSI code.
    else {
      sign = NULL;
      prefix = false;
    }
    return prefix ? CharToString(sign) + DoubleToString(value, digits)
                  : DoubleToString(value, digits) + CharToString(sign);
  }

  /**
   * Convert integer to hex.
   */
  static string IntToHex(long long_number) {
    string result;
    int integer_number = (int)long_number;
    for (int i = 0; i < 4; i++) {
      int byte = (integer_number >> (i * 8)) & 0xff;
      result += StringFormat("%02x", byte);
    }
    return result;
  }

  /**
   * Convert character into integer.
   */
  static int CharToInt(ARRAY_REF(int, _chars)) {
    return ((_chars[0]) | (_chars[1] << 8) | (_chars[2] << 16) | (_chars[3] << 24));
  }

  /**
   * Assume: len % 4 == 0.
   */
  static int String4ToIntArray(ARRAY_REF(int, output), string in) {
    int len;
    int i, j;
    len = StringLen(in);
    if (len % 4 != 0) len = len - len % 4;
    int size = ArraySize(output);
    if (size < len / 4) {
      ArrayResize(output, len / 4);
    }
    for (i = 0, j = 0; j < len; i++, j += 4) {
      output[i] = (StringGetCharacter(in, j)) | ((StringGetCharacter(in, j + 1)) << 8) |
                  ((StringGetCharacter(in, j + 2)) << 16) | ((StringGetCharacter(in, j + 3)) << 24);
    }
    return (len / 4);
  }

  static void StringToType(string _value, bool& _out) {
#ifdef __MQL__
    _out = _value != "" && _value != NULL && _value != "0" && _value != "false";
#else
    _out = _value != "" && _value != "0" && _value != "false";
#endif
  }

  static void StringToType(string _value, int& _out) { _out = (int)StringToInteger(_value); }
  static void StringToType(string _value, unsigned int& _out) { _out = (unsigned int)StringToInteger(_value); }
  static void StringToType(string _value, char& _out) { _out = (char)_value[0]; }
  static void StringToType(string _value, unsigned char& _out) { _out = (unsigned char)_value[0]; }
  static void StringToType(string _value, long& _out) { _out = StringToInteger(_value); }
  static void StringToType(string _value, unsigned long& _out) { _out = StringToInteger(_value); }
  static void StringToType(string _value, short& _out) { _out = (short)StringToInteger(_value); }
  static void StringToType(string _value, unsigned short& _out) { _out = (unsigned short)StringToInteger(_value); }
  static void StringToType(string _value, float& _out) { _out = (float)StringToDouble(_value); }
  static void StringToType(string _value, double& _out) { _out = StringToDouble(_value); }
  static void StringToType(string _value, string& _out) { _out = _value; }
  static void StringToType(string _value, color& _out) { _out = 0; }
  static void StringToType(string _value, datetime& _out) {
#ifdef __MQL4__
    _out = StrToTime(_value);
#else
    _out = StringToTime(_value);
#endif
  }

  static void BoolToType(bool _value, bool& _out) { _out = _value; }
  static void BoolToType(bool _value, char& _out) { _out = (char)_value; }
  static void BoolToType(bool _value, unsigned char& _out) { _out = (unsigned char)_value; }
  static void BoolToType(bool _value, int& _out) { _out = (int)_value; }
  static void BoolToType(bool _value, unsigned int& _out) { _out = (unsigned int)_value; }
  static void BoolToType(bool _value, long& _out) { _out = (long)_value; }
  static void BoolToType(bool _value, unsigned long& _out) { _out = (unsigned long)_value; }
  static void BoolToType(bool _value, short& _out) { _out = (short)_value; }
  static void BoolToType(bool _value, unsigned short& _out) { _out = (unsigned short)_value; }
  static void BoolToType(bool _value, float& _out) { _out = (float)_value; }
  static void BoolToType(bool _value, double& _out) { _out = (double)_value; }
  static void BoolToType(bool _value, string& _out) { _out = _value ? "1" : "0"; }
  static void BoolToType(bool _value, color& _out) { _out = 0; }
  static void BoolToType(bool _value, datetime& _out) {}

  static void LongToType(long _value, bool& _out) { _out = (bool)_value; }
  static void LongToType(long _value, char& _out) { _out = (char)_value; }
  static void LongToType(long _value, unsigned char& _out) { _out = (unsigned char)_value; }
  static void LongToType(long _value, int& _out) { _out = (int)_value; }
  static void LongToType(long _value, unsigned int& _out) { _out = (unsigned int)_value; }
  static void LongToType(long _value, long& _out) { _out = (long)_value; }
  static void LongToType(long _value, unsigned long& _out) { _out = (unsigned long)_value; }
  static void LongToType(long _value, short& _out) { _out = (short)_value; }
  static void LongToType(long _value, unsigned short& _out) { _out = (unsigned short)_value; }
  static void LongToType(long _value, float& _out) { _out = (float)_value; }
  static void LongToType(long _value, double& _out) { _out = (double)_value; }
  static void LongToType(long _value, string& _out) { _out = _value ? "1" : "0"; }
  static void LongToType(long _value, color& _out) { _out = 0; }
  static void LongToType(long _value, datetime& _out) {}

  static void DoubleToType(double _value, bool& _out) { _out = (bool)_value; }
  static void DoubleToType(double _value, char& _out) { _out = (char)_value; }
  static void DoubleToType(double _value, unsigned char& _out) { _out = (unsigned char)_value; }
  static void DoubleToType(double _value, int& _out) { _out = (int)_value; }
  static void DoubleToType(double _value, unsigned int& _out) { _out = (unsigned int)_value; }
  static void DoubleToType(double _value, long& _out) { _out = (long)_value; }
  static void DoubleToType(double _value, unsigned long& _out) { _out = (unsigned long)_value; }
  static void DoubleToType(double _value, short& _out) { _out = (short)_value; }
  static void DoubleToType(double _value, unsigned short& _out) { _out = (unsigned short)_value; }
  static void DoubleToType(double _value, float& _out) { _out = (float)_value; }
  static void DoubleToType(double _value, double& _out) { _out = (double)_value; }
  static void DoubleToType(double _value, string& _out) { _out = _value ? "1" : "0"; }
  static void DoubleToType(double _value, color& _out) { _out = 0; }
  static void DoubleToType(double _value, datetime& _out) {}
};

#endif  // CONVERT_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Convert.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Serializer.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerNodeIterator.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef JSON_ITERATOR_MQH
#define JSON_ITERATOR_MQH



class SerializerNode;
class Serializer;

class SerializerNodeIterator {
 protected:
  unsigned int _index;
  SerializerNode* _collection;

 public:
  /**
   * Constructor.
   */
  SerializerNodeIterator(SerializerNode* collection = NULL) {
    _index = 0;
    _collection = collection;
  }

  /**
   * Constructor.
   */
  SerializerNodeIterator(const SerializerNodeIterator& r) {
    _index = r._index;
    _collection = r._collection;
  }

  /**
   * Returns current node or NULL.
   */
  SerializerNode* Node() { return !IsValid() ? NULL : PTR_ATTRIB(_collection, GetChild(_index));
  }

  /**
   * Returns current node index.
   */
  unsigned int Index() { return _index; }

  /**
   * Iterator incrementation operator.
   */
  void operator++(void) { ++_index; }

  /**
   * Checks whether iterator is still valid.
   */
  bool IsValid() { return _index < PTR_ATTRIB(_collection, NumChildren());
  }

  /**
   * Returns current's child key or empty string.
   */
  const string Key() { return !IsValid() ? "" : PTR_ATTRIB(PTR_ATTRIB(_collection, GetChild(_index)), Key());
  }

  /**
   * Checks whether current child has key.
   */
  bool HasKey() { return !IsValid() ? false : PTR_ATTRIB(PTR_ATTRIB(_collection, GetChild(_index)), HasKey());
  }

  /**
   * Checks whether current child is a container.
   */
  bool IsContainer() { return !IsValid() ? false : PTR_ATTRIB(PTR_ATTRIB(_collection, GetChild(_index)), IsContainer());
  }
};

template <typename X>
class SerializerIterator : public SerializerNodeIterator {
 protected:
  Serializer* _serializer;

 public:
  /**
   * Constructor.
   */
  SerializerIterator(Serializer* serializer = NULL, SerializerNode* collection = NULL)
      : SerializerNodeIterator(collection) {
    _serializer = serializer;
  }

  /**
   * Constructor.
   */
  SerializerIterator(const SerializerIterator& r) : SerializerNodeIterator(r) { _serializer = r._serializer; }

  /**
   * Returns next value or value by given key.
   */
  template <>
  X Value(string key = "") {
    X value;
    _serializer.Pass(_serializer, key, value);
    return value;
  }

  /**
   * Returns next object or object by given key.
   */
  template <>
  X Object(string key = "") {
    return Struct(key);
  }

  /**
   * Returns next structure or structure by given key.
   */
  template <>
  X Struct(string key = "") {
    X value;
    _serializer.PassStruct(_serializer, key, value);
    return value;
  }

  SerializerNodeType ParentNodeType() { return _collection.GetType(); }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerNodeIterator.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNodeParam.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerConverter.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Serializer.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Serializer's defines.
 */

/* Defines */

#ifdef __MQL__
#define SERIALIZER_EMPTY_STUB \
  template <>                 \
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
#else
#define SERIALIZER_EMPTY_STUB \
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Serializer.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef SERIALIZER_MQH
#define SERIALIZER_MQH

// Includes.








#define SERIALIZER_DEFAULT_FP_PRECISION 8

class Serializer {
 protected:
  SerializerNode* _node;
  SerializerNode* _root;
  SerializerMode _mode;
  bool _root_node_ownership;
  bool _skip_hidden;
  string _single_value_name;

  unsigned int _flags;

  // Floating-point precision.
  int fp_precision;

 public:
  /**
   * Constructor.
   */
  Serializer(SerializerNode* node, SerializerMode mode, int flags) : _node(node), _mode(mode), _flags(flags) {
    _root = node;
    _root_node_ownership = true;
    fp_precision = SERIALIZER_DEFAULT_FP_PRECISION;
    if (_flags == 0) {
      // Preventing flags misuse.
      _flags = SERIALIZER_FLAG_INCLUDE_ALL;
    }
  }

  /**
   * Destructor.
   */
  ~Serializer() {
    if (_root_node_ownership && _root != NULL) delete _root;
  }

  template <typename X>
  SerializerIterator<X> Begin() {
    SerializerIterator<X> iter(&this, _node);
    return iter;
  }

  void FreeRootNodeOwnership() { _root_node_ownership = false; }

  /**
   * Enters object or array for a given key or just iterates over objects/array during unserializing.
   */
  bool Enter(SerializerEnterMode mode = SerializerEnterObject, string key = "") {
    if (IsWriting()) {
#ifdef __MQL__
      SerializerNodeParam* nameParam = (key != "" && key != "") ? SerializerNodeParam::FromString(key) : NULL;
#else
      SerializerNodeParam* nameParam = (key != "") ? SerializerNodeParam::FromString(key) : NULL;
#endif

      // When writing, we need to make parent->child structure. It is not
      // required when reading, because structure is full done by parsing the
      // string.
      _node = new SerializerNode(mode == SerializerEnterObject ? SerializerNodeObject : SerializerNodeArray, _node,
                                 nameParam);

      if (PTR_ATTRIB(_node, GetParent()) != NULL) PTR_ATTRIB(PTR_ATTRIB(_node, GetParent()), AddChild(_node));

      if (_root == NULL) _root = _node;
    } else {
      if (_node == NULL) {
        _node = _root;
        return true;
      }

      SerializerNode* child;

      if (key != "") {
        // We need to enter object that matches given key.
        for (unsigned int i = 0; i < PTR_ATTRIB(_node, NumChildren()); ++i) {
          child = PTR_ATTRIB(_node, GetChild(i));
          if (PTR_ATTRIB(PTR_ATTRIB(child, GetKeyParam()), AsString(false, false)) == key) {
            _node = child;
            return true;
          }
        }
        // We didn't enter into child node.
        return false;
      } else if (key == "") {
        _node = PTR_ATTRIB(_node, GetNextChild());
      }
    }
    return true;
  }

  /**
   * Leaves current object/array. Used in custom Serialize() method.
   */
  void Leave() { _node = PTR_ATTRIB(_node, GetParent()); }

  /**
   * Checks whether we are in serialization process. Used in custom Serialize() method.
   */
  bool IsWriting() { return _mode == Serialize || bool(_flags & SERIALIZER_FLAG_SIMULATE_SERIALIZE); }

  /**
   * Checks whether we are in unserialization process. Used in custom Serialize() method.
   */
  bool IsReading() { return !IsWriting(); }

  /**
   * Checks whether current node is inside array. Used in custom Serialize() method.
   */
  bool IsArray() {
    return _mode == Unserialize && _node != NULL && PTR_ATTRIB(_node, GetType()) == SerializerNodeArray;
  }

  /**
   * Returns number of array items inside current array.
   */
  unsigned int NumArrayItems() { return _node != NULL ? PTR_ATTRIB(_node, NumChildren()) : 0; }

  /**
   * Checks whether current node is an object. Used in custom Serialize() method.
   */
  bool IsObject() {
    return _mode == Unserialize && _node != NULL && PTR_ATTRIB(_node, GetType()) == SerializerNodeObject;
  }

  /**
   * Returns number of child nodes.
   */
  unsigned int NumChildren() { return _node ? PTR_ATTRIB(_node, NumChildren()) : 0; }

  /**
   * Returns root node or NULL. Could be used after unserialization.
   */
  SerializerNode* GetRoot() { return _root; }

  /**
   * Returns child node for a given index or NULL.
   */
  SerializerNode* GetChild(unsigned int index) { return _node ? PTR_ATTRIB(_node, GetChild(index)) : NULL; }

  /**
   * Returns floating-point precision.
   */
  int GetFloatingPointPrecision() { return fp_precision; }

  /**
   * Sets floating-point precision.
   */
  void SetPrecision(int _fp_precision) { fp_precision = _fp_precision; }

  /**
   * Serializes or unserializes object.
   */
  template <typename T, typename V>
  void PassObject(T& self, string name, V& value, unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    PassStruct(self, name, value, flags);
  }

  /**
   * Serializes or unserializes object that acts as a value.
   */
  template <typename T, typename V>
  void PassValueObject(T& self, string name, V& value, unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    if (_mode == Serialize) {
      value.Serialize(this);
      fp_precision = SERIALIZER_DEFAULT_FP_PRECISION;

      SerializerNode* obj = _node.GetChild(_node.NumChildren() - 1);

      obj.SetKey(name);
    } else {
      _single_value_name = name;
      value.Serialize(this);
    }
  }

  bool IsFieldVisible(int serializer_flags, int field_flags) {
    // Is field visible? Such field cannot be exluded in anyway.
    if ((field_flags & SERIALIZER_FIELD_FLAG_VISIBLE) == SERIALIZER_FIELD_FLAG_VISIBLE) {
      return true;
    }

    if ((field_flags & SERIALIZER_FIELD_FLAG_HIDDEN) == SERIALIZER_FIELD_FLAG_HIDDEN) {
      if ((serializer_flags & SERIALIZER_FLAG_SKIP_HIDDEN) != SERIALIZER_FLAG_SKIP_HIDDEN) {
        // Field is hidden, but serializer has no SERIALIZER_FLAG_SKIP_HIDDEN flag set, so field will be serialized.
        return true;
      }
    }

    // Is field hidden?
    if ((serializer_flags & SERIALIZER_FLAG_SKIP_HIDDEN) == SERIALIZER_FLAG_SKIP_HIDDEN) {
      if ((field_flags & SERIALIZER_FIELD_FLAG_HIDDEN) == SERIALIZER_FIELD_FLAG_HIDDEN) {
        return false;
      }
    }

    // Is field default?
    if ((serializer_flags & SERIALIZER_FLAG_EXCLUDE_DEFAULT) == SERIALIZER_FLAG_EXCLUDE_DEFAULT) {
      if ((field_flags & SERIALIZER_FIELD_FLAG_DEFAULT) == SERIALIZER_FIELD_FLAG_DEFAULT) {
        if ((serializer_flags & SERIALIZER_FLAG_INCLUDE_DEFAULT) == SERIALIZER_FLAG_INCLUDE_DEFAULT) {
          // Field was excluded by e.g., dynamic or feature type, but included explicitly by flag.
          return true;
        } else {
          // Field was excluded by e.g., dynamic or feature type, but not included again explicitly by flag.
          return false;
        }
      }
    }

    // Is field dynamic?
    if ((serializer_flags & SERIALIZER_FLAG_INCLUDE_DYNAMIC) == SERIALIZER_FLAG_INCLUDE_DYNAMIC) {
      if ((field_flags & SERIALIZER_FIELD_FLAG_DYNAMIC) == SERIALIZER_FIELD_FLAG_DYNAMIC) {
        return true;
      }
    }

    // Is field a feature?
    if ((serializer_flags & SERIALIZER_FLAG_INCLUDE_FEATURE) == SERIALIZER_FLAG_INCLUDE_FEATURE) {
      if ((field_flags & SERIALIZER_FIELD_FLAG_FEATURE) == SERIALIZER_FIELD_FLAG_FEATURE) {
        return true;
      }
    }

    return false;
  }

  /**
   * Serializes or unserializes structure.
   */
  template <typename T, typename V>
  void PassStruct(T& self, string name, V& value, unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    if (_mode == Serialize) {
      if (!IsFieldVisible(_flags, flags)) return;
    }

    // Entering object or array. value's Serialize() method should check if it's array by s.IsArray().
    // Note that binary serializer shouldn't rely on the property names and just skip entering/leaving at all.
    // Entering a root node does nothing, because we would end up going to first child node, which we don't want to do.

    if (_mode == Serialize || (_mode == Unserialize && name != "")) {
      Enter(SerializerEnterObject, name);
    }

    SerializerNodeType newType = value.Serialize(THIS_REF);
    fp_precision = SERIALIZER_DEFAULT_FP_PRECISION;

    // value's Serialize() method returns which type of node it should be treated as.
    if (newType != SerializerNodeUnknown) PTR_ATTRIB(_node, SetType(newType));

    // Goes to the sibling node. In other words, it goes to the parent's next node.
    if (_mode == Serialize || (_mode == Unserialize && name != "")) {
      Leave();
    }
  }

  void Next() {
    if (PTR_ATTRIB(_node, GetParent()) == NULL) {
      return;
    }

    _node = PTR_ATTRIB(PTR_ATTRIB(_node, GetParent()), GetNextChild());
  }

  /**
   * Serializes or unserializes enum value (stores it as integer).
   */
  template <typename T, typename V>
  void PassEnum(T& self, string name, V& value, unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    int enumValue;
    if (_mode == Serialize) {
      if (!IsFieldVisible(_flags, flags)) {
        return;
      }

      enumValue = (int)value;
      Pass(self, name, enumValue, flags);
    } else {
      Pass(self, name, enumValue, flags);
      value = (V)enumValue;
    }
  }

  template <typename T, typename VT>
  void PassArray(T& self, string name, ARRAY_REF(VT, array), unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    int num_items;

    if (_mode == Serialize) {
      if (!IsFieldVisible(_flags, flags)) {
        // Skipping prematurely instead of creating object by new.
        return;
      }
    }

    if (_mode == Serialize) {
      if (Enter(SerializerEnterArray, name)) {
        num_items = ArraySize(array);
        for (int i = 0; i < num_items; ++i) {
          PassStruct(this, "", array[i]);
        }
        Leave();
      }
    } else {
      if (Enter(SerializerEnterArray, name)) {
        SerializerNode* parent = _node;

        num_items = (int)NumArrayItems();
        ArrayResize(array, num_items);

        for (SerializerIterator<VT> si = Begin<VT>(); si.IsValid(); ++si) {
          if (si.HasKey()) {
            // Should not happen.
          } else {
            _node = parent.GetChild(si.Index());
            array[si.Index()] = si.Struct();
          }
        }

        Leave();
      }
    }
  }

  /**
   * Serializes or unserializes pointer to object.
   */
  template <typename T, typename V>
  void Pass(T& self, string name, V*& value, unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    if (_mode == Serialize) {
      if (!IsFieldVisible(_flags, flags)) {
        return;
      }

      PassObject(self, name, value, flags);
    } else {
      V* newborn = new V();

      PassObject(self, name, newborn, flags);

      value = newborn;
    }
  }

  /**
   * Serializes or unserializes simple value.
   */
  template <typename T, typename V>
  SerializerNode* Pass(T& self, string name, V& value, unsigned int flags = SERIALIZER_FIELD_FLAG_DEFAULT) {
    SerializerNode* child = NULL;
    bool _skip_push = (_flags & SERIALIZER_FLAG_SKIP_PUSH) == SERIALIZER_FLAG_SKIP_PUSH;

    if (_mode == Serialize) {
      if (!IsFieldVisible(_flags, flags)) {
        return NULL;
      }

      SerializerNodeParam* key = name != "" ? SerializerNodeParam::FromString(name) : NULL;
      SerializerNodeParam* val = SerializerNodeParam::FromValue(value);

      if (val == NULL) {
        Print("Error: Value to SerializerNodeParam conversion failed!");
        DebugBreak();
      }

      PTR_ATTRIB(val, SetFloatingPointPrecision(GetFloatingPointPrecision()));
      child = new SerializerNode(SerializerNodeObjectProperty, _node, key, val, flags);

      if (!_skip_push) {
        PTR_ATTRIB(_node, AddChild(child));
      }

      return child;
    } else {
      if (name == "") {
        // Determining name from Serializer's SingleValueName().
        name = _single_value_name;
      }

      for (unsigned int i = 0; i < PTR_ATTRIB(_node, NumChildren()); ++i) {
        child = PTR_ATTRIB(_node, GetChild(i));
        if (PTR_ATTRIB(PTR_ATTRIB(child, GetKeyParam()), AsString(false, false)) == name) {
          SerializerNodeParamType paramType = PTR_ATTRIB(PTR_ATTRIB(child, GetValueParam()), GetType());
          switch (paramType) {
            case SerializerNodeParamBool:
              Convert::BoolToType(PTR_ATTRIB(PTR_ATTRIB(child, GetValueParam()), _integral)._bool, value);
              break;
            case SerializerNodeParamLong:
              Convert::LongToType(PTR_ATTRIB(PTR_ATTRIB(child, GetValueParam()), _integral)._long, value);
              break;
            case SerializerNodeParamDouble:
              Convert::DoubleToType(PTR_ATTRIB(PTR_ATTRIB(child, GetValueParam()), _integral)._double, value);
              break;
            case SerializerNodeParamString:
              // There shouldn't be a conversion to int!
              Convert::StringToType(PTR_ATTRIB(PTR_ATTRIB(child, GetValueParam()), _string), value);
              break;
            default:
              Print("Error: Wrong param type ", EnumToString(paramType), "!");
              DebugBreak();
          }

          return NULL;
        }
      }
    }

    return NULL;
  }

  template <typename X>
  static SerializerConverter MakeStubObject(int _serializer_flags = SERIALIZER_FLAG_INCLUDE_ALL, int _n1 = 1,
                                            int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
    if (_serializer_flags == 0) {
      // Avoiding flags misuse.
      _serializer_flags = SERIALIZER_FLAG_INCLUDE_ALL;
    }

    X stub;
    stub.SerializeStub(_n1, _n2, _n3, _n4, _n5);
    return SerializerConverter::FromObject(stub, _serializer_flags);
  }
};

#endif  // End: SERIALIZER_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Serializer.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DictBase.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Dict.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Dicts's enums and defines.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

#define DICT_GROW_UP_PERCENT_DEFAULT 25
#define DICT_PERFORMANCE_PROBLEM_AVG_CONFLICTS 10

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Dict.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DictSlot.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef DICT_SLOT_MQH
#define DICT_SLOT_MQH

enum DICT_SLOT_FLAGS { DICT_SLOT_INVALID = 1, DICT_SLOT_HAS_KEY = 2, DICT_SLOT_IS_USED = 4, DICT_SLOT_WAS_USED = 8 };

/**
 * Represents a single item in the hash table.
 */
template <typename K, typename V>
class DictSlot {
 public:
  unsigned char _flags;
  K key;    // Key used to store value.
  V value;  // Value stored.

  static const DictSlot Invalid;

  DictSlot(unsigned char flags = 0) : _flags(flags) {}

  bool IsValid() { return !bool(_flags & DICT_SLOT_INVALID); }

  bool HasKey() { return bool(_flags & DICT_SLOT_HAS_KEY); }

  bool IsUsed() { return bool(_flags & DICT_SLOT_IS_USED); }

  bool WasUsed() { return bool(_flags & DICT_SLOT_WAS_USED); }

  void SetFlags(unsigned char flags) { _flags = flags; }

  void AddFlags(unsigned char flags) { _flags |= flags; }

  void RemoveFlags(unsigned char flags) { _flags &= ~flags; }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DictSlot.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DictIteratorBase.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerConversions.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DictSlotsRef.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Dict.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * DictSlotsRef struct.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.


template <typename K, typename V>
class DictSlot;

template <typename K, typename V>
struct DictSlotsRef {
  DictSlot<K, V> DictSlots[];

  // Incremental index for dict operating in list mode.
  int _list_index;

  int _num_used;

  int _num_conflicts;

  float _avg_conflicts;

  DictSlotsRef() {
    _list_index = 0;
    _num_used = 0;
    _num_conflicts = 0;
    _avg_conflicts = 0;
  }

  /**
   * Adds given number of conflicts for an insert action, so we can store average number of conflicts.
   */
  void AddConflicts(int num) {
    if (num != 0) {
      _avg_conflicts += float(num) / ++_num_conflicts;
    }
  }

  /**
   * Checks whethere there is no performance problems with slots.
   */
  bool IsPerformant() { return _avg_conflicts < DICT_PERFORMANCE_PROBLEM_AVG_CONFLICTS; }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DictSlotsRef.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictBase.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif





template <typename K, typename V>
class DictBase;

template <typename K, typename V>
class DictIteratorBase {
 protected:
  DictBase<K, V>* _dict;
  int _hash;
  int _slotIdx;
  int _index;
  bool _invalid_until_incremented;

 public:
  /**
   * Constructor.
   */
  DictIteratorBase() : _dict(NULL) { _invalid_until_incremented = false; }

  /**
   * Constructor.
   */
  DictIteratorBase(DictBase<K, V>& dict, int slotIdx)
      : _dict(&dict), _hash(dict.GetHash()), _slotIdx(slotIdx), _index(0) {
    _invalid_until_incremented = false;
  }

  /**
   * Copy constructor.
   */
  DictIteratorBase(const DictIteratorBase& right)
      : _dict(right._dict),
        _hash(right._dict ? right._dict.GetHash() : 0),
        _slotIdx(right._slotIdx),
        _index(right._index) {
    _invalid_until_incremented = false;
  }

  /**
   * Iterator incrementation operator.
   */
  void operator++(void) {
    // Going to the next slot.
    ++_slotIdx;
    ++_index;
    _invalid_until_incremented = false;

    DictSlot<K, V>* slot = _dict.GetSlot(_slotIdx);

    // Iterating until we find valid, used slot.
    while (slot != NULL && !slot.IsUsed()) {
      slot = _dict.GetSlot(++_slotIdx);
    }

    if (!slot || !slot.IsValid()) {
      // Invalidating iterator.
      _dict = NULL;
    }
  }

  bool HasKey() { return _dict.GetSlot(_slotIdx).HasKey(); }

  K Key() {
    CheckValidity();
    return _dict.GetMode() == DictModeList ? (K)_slotIdx : _dict.GetSlot(_slotIdx).key;
  }

  string KeyAsString(bool includeQuotes = false) {
    return HasKey() ? SerializerConversions::ValueToString(Key(), includeQuotes) : "";
  }

  int Index() {
    CheckValidity();
    return _index;
  }

  V Value() {
    CheckValidity();
    return _dict.GetSlot(_slotIdx).value;
  }

  void CheckValidity() {
    if (_invalid_until_incremented) {
      Alert("Iterator must be incremented before using it again!");
      DebugBreak();
    }
  }

  bool IsValid() { return _dict != NULL; }

  bool IsLast() {
    if (!IsValid()) return true;

    if (_dict.GetMode() == DictModeUnknown || _dict.Size() == 0) {
      return false;
    }

    if (_dict.GetMode() != DictModeList) {
      Alert("Dict iterator's IsLast() method may be used only when elements are added via Push() method.");
    }

    return _index == _dict.Size() - 1;
  }

  void ShiftPosition(int shift, bool invalid_until_incremented = false) {
    _slotIdx += shift;
    _index += shift;
    _invalid_until_incremented |= invalid_until_incremented;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DictIteratorBase.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef DICT_BASE_MQH
#define DICT_BASE_MQH

// Includes.






/**
 * Whether Dict operates in yet uknown mode, as dict or as list.
 */
enum DictMode { DictModeUnknown, DictModeDict, DictModeList };

/**
 * Reason of call to overflow listener.
 */
enum ENUM_DICT_OVERFLOW_REASON {
  DICT_OVERFLOW_REASON_FULL,
  DICT_OVERFLOW_REASON_TOO_MANY_CONFLICTS,
};

/**
 * Dictionary flags.
 */
enum ENUM_DICT_FLAG {
  DICT_FLAG_NONE = 0,
  DICT_FLAG_FILL_HOLES_UNSORTED = 1,
};

/**
 * Dictionary overflow listener. arguments are:
 * - ENUM_DICT_OVERFLOW_REASON overflow_reason
 * - int current_dict_size
 * - int number_of_conflicts
 */
typedef bool (*DictOverflowListener)(ENUM_DICT_OVERFLOW_REASON, int, int);

/**
 * Hash-table based dictionary.
 */
template <typename K, typename V>
class DictBase {
 protected:
  int _hash;

  // Incremental id used by Push() method.
  unsigned int _current_id;

  // Whether Dict operates in yet uknown mode, as dict or as list.
  DictMode _mode;

  // Dictionary flags.
  int _flags;

 public:
  DictBase() {
    _hash = rand();
    _current_id = 0;
    _mode = DictModeUnknown;
    _flags = 0;
  }

  /**
   * Destructor.
   */
  ~DictBase() {}

  DictIteratorBase<K, V> Begin() {
    // Searching for first item index.
    for (unsigned int i = 0; i < (unsigned int)ArraySize(_DictSlots_ref.DictSlots); ++i) {
      if (_DictSlots_ref.DictSlots[i].IsValid() && _DictSlots_ref.DictSlots[i].IsUsed()) {
        DictIteratorBase<K, V> iter(this, i);
        return iter;
      }
    }
    // No items found.
    DictIteratorBase<K, V> invalid;
    return invalid;
  }

  const unsigned int GetSlotCount() const { return ArraySize(_DictSlots_ref.DictSlots); }

  /**
   * Adds flags to dict.
   */
  void AddFlags(int flags) { _flags |= flags; }

  /**
   * Checks whether dict have all given flags.
   */
  bool HasFlags(int flags) { return (_flags & flags) == flags; }

  DictSlot<K, V>* GetSlot(const unsigned int index) {
    if (index >= GetSlotCount()) {
      // Index of out bounds.
      return NULL;
    }

    return &_DictSlots_ref.DictSlots[index];
  }

  /**
   * Returns slot by key.
   */
  DictSlot<K, V>* GetSlotByKey(DictSlotsRef<K, V>& dictSlotsRef, const K _key, unsigned int& position) {
    unsigned int numSlots = ArraySize(dictSlotsRef.DictSlots);

    if (numSlots == 0) return NULL;

    position = Hash(_key) % numSlots;

    unsigned int tries_left = numSlots;

    while (tries_left-- > 0) {
      if (dictSlotsRef.DictSlots[position].WasUsed() == false) {
        // We stop searching now.
        return NULL;
      }

      if (dictSlotsRef.DictSlots[position].IsUsed() && dictSlotsRef.DictSlots[position].HasKey() &&
          dictSlotsRef.DictSlots[position].key == _key) {
        // _key matches, returing value from the DictSlot.
        return &dictSlotsRef.DictSlots[position];
      }

      // Position may overflow, so we will start from the beginning.
      position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
    }

    return NULL;
  }

  /**
   * Returns slot by position.
   */
  DictSlot<K, V>* GetSlotByPos(DictSlotsRef<K, V>& dictSlotsRef, const unsigned int position) {
    return dictSlotsRef.DictSlots[position].IsUsed() ? &dictSlotsRef.DictSlots[position] : NULL;
  }

  /**
   * Returns hash currently used by Dict. It is used to invalidate iterators after Resize().
   */
  int GetHash() { return _hash; }

  int GetMode() { return _mode; }

  /**
   * Removes value from the dictionary by the given iterator. Could be used to remove value on Dict with
   * DICT_FLAG_FILL_HOLES_UNSORTED flag.
   */
  void Unset(DictIteratorBase<K, V>& iter) {
    InternalUnset(iter.Key());
    if (HasFlags(DICT_FLAG_FILL_HOLES_UNSORTED)) {
      // After incrementing, iterator will use moved slot.
      iter.ShiftPosition(-1, true);
    }
  }

  /**
   * Removes value from the dictionary by the given key (if exists).
   */
  void Unset(const K key) {
    if (HasFlags(DICT_FLAG_FILL_HOLES_UNSORTED)) {
      Print(
          "Unset on Dict with DICT_FLAG_FILL_HOLES_UNSORTED flag must be called by passing the iterator, instead of "
          "the key. Thus way iterator will continue with proper value after incrementation.");
      DebugBreak();
      return;
    }
    InternalUnset(key);
  }

  /**
   * Removes value from the dictionary by the given key (if exists).
   */
  void InternalUnset(const K key) {
    if (ArraySize(_DictSlots_ref.DictSlots) == 0) {
      // Nothing to unset.
      return;
    }

    unsigned int position;

    if (GetMode() == DictModeList) {
      // In list mode value index is the slot index.
      position = (int)key;
    } else {
      position = Hash(key) % ArraySize(_DictSlots_ref.DictSlots);
    }

    unsigned int tries_left = ArraySize(_DictSlots_ref.DictSlots);

    while (tries_left-- > 0) {
      if (_DictSlots_ref.DictSlots[position].WasUsed() == false) {
        // We stop searching now.
        return;
      }

      bool _should_be_removed = false;

      if (_DictSlots_ref.DictSlots[position].IsUsed()) {
        if (GetMode() == DictModeList) {
          _should_be_removed = position == (int)key;
        } else {
          _should_be_removed =
              _DictSlots_ref.DictSlots[position].HasKey() && _DictSlots_ref.DictSlots[position].key == key;
        }
      }

      if (_should_be_removed) {
        // Key/index perfectly matches, it indicates key/index exists in the dictionary.
        _DictSlots_ref.DictSlots[position].RemoveFlags(DICT_SLOT_IS_USED);

        if (GetMode() == DictModeDict) {
          // In List mode we don't decrement number of used elements.
          --_DictSlots_ref._num_used;
        } else if (HasFlags(DICT_FLAG_FILL_HOLES_UNSORTED)) {
          // This is List mode and we need to fill this hole.
          FillHoleUnsorted(position);
        }
        return;
      } else if (GetMode() == DictModeList) {
        Print("Internal error. Slot should have been removed!");
        DebugBreak();
        return;
      }

      // Position may overflow, so we will start from the beginning.
      position = (position + 1) % ArraySize(_DictSlots_ref.DictSlots);
    }

    // No key found.
  }

  /**
   * Checks whether overflow listener allows dict to grow up.
   */
  bool IsGrowUpAllowed() {
    if (overflow_listener == NULL) {
      return true;
    }

    // Checking if overflow listener allows resize from current to higher number of slots.
    return overflow_listener(DICT_OVERFLOW_REASON_FULL, Size(), 0);
  }

  /**
   * Moves last slot to given one to fill the hole after removing the value.
   */
  void FillHoleUnsorted(int _hole_slot_idx) {
    // After moving last element to fill the hole we
    if (_hole_slot_idx == Size() - 1) {
      // We've just removed last element, thus don't need to do anything.
    } else {
      // Moving last slot into given one.
      _DictSlots_ref.DictSlots[_hole_slot_idx] = _DictSlots_ref.DictSlots[Size() - 1];

      // Marking last slot as unused.
      _DictSlots_ref.DictSlots[Size() - 1].RemoveFlags(DICT_SLOT_IS_USED);
    }
    // One element less in the List-based Dict.
    --_DictSlots_ref._num_used;
  }

  /**
   * Returns number of used DictSlots.
   */
  const unsigned int Size() { return _DictSlots_ref._num_used; }

  /**
   * Returns number of all (reserved) DictSlots.
   */
  const unsigned int ReservedSize() { return ArraySize(_DictSlots_ref.DictSlots); }

  /**
   * Checks whether given key exists in the dictionary.
   */
  bool KeyExists(const K key, unsigned int& position) {
    int numSlots = ArraySize(_DictSlots_ref.DictSlots);

    if (numSlots == 0) return false;

    position = Hash(key) % numSlots;

    unsigned int tries_left = numSlots;

    while (tries_left-- > 0) {
      if (_DictSlots_ref.DictSlots[position].WasUsed() == false) {
        // We stop searching now.
        return false;
      }

      if (_DictSlots_ref.DictSlots[position].IsUsed() && _DictSlots_ref.DictSlots[position].HasKey() &&
          _DictSlots_ref.DictSlots[position].key == key) {
        // Key perfectly matches, it indicates key exists in the dictionary.
        return true;
      }

      // Position may overflow, so we will start from the beginning.
      position = (position + 1) % numSlots;
    }

    // No key found.
    return false;
  }
  bool KeyExists(const K key) {
    unsigned int position;
    return KeyExists(key, position);
  }

  /**
   * Sets dictionary overflow listener and, optionally, maximum number of conflicts which will cause overflow and
   * eventually a slot reuse.
   */
  void SetOverflowListener(DictOverflowListener _listener, int _num_max_conflicts = -1) {
    overflow_listener = _listener;

    if (_num_max_conflicts != -1) {
      SetMaxConflicts(_num_max_conflicts);
    }
  }

  /**
   * Sets maximum number of conflicts which will cause overflow and a slot reuse if no overflow listener was set.
   */
  void SetMaxConflicts(int _num_max_conflicts = 0) { overflow_listener_max_conflicts = _num_max_conflicts; }

 protected:
  /**
   * Array of DictSlots.
   */
  DictSlotsRef<K, V> _DictSlots_ref;

  DictOverflowListener overflow_listener;
  unsigned int overflow_listener_max_conflicts;

  /* Hash methods */

  /**
   * Specialization of hashing function.
   */
  template <typename X>
  unsigned int Hash(X x) {
    return (int)x;
  }

  /**
   * Specialization of hashing function.
   */
  unsigned int Hash(datetime x) { return (int)x; }

  /**
   * Specialization of hashing function.
   */
  unsigned int Hash(const string& x) {
    unsigned char c[];
    unsigned int h = 0;

    if (x != NULL) {
      h = 5381;
      int n = StringToCharArray(x, c);
      for (int i = 0; i < n; i++) {
        h = ((h << 5) + h) + c[i];
      }
    }

    return h;
  }

  /**
   * Specialization of hashing function.
   */
  unsigned int Hash(unsigned int x) { return x; }

  /**
   * Specialization of hashing function.
   */
  unsigned int Hash(int x) { return (unsigned int)x; }

  /**
   * Specialization of hashing function.
   */
  unsigned int Hash(float x) { return (unsigned int)((unsigned long)x * 10000 % 10000); }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DictBase.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef DICT_OBJECT_MQH
#define DICT_OBJECT_MQH





template <typename K, typename V>
class DictObjectIterator : public DictIteratorBase<K, V> {
 public:
  /**
   * Constructor.
   */
  DictObjectIterator() {}

  /**
   * Constructor.
   */
  DictObjectIterator(DictBase<K, V>& dict, unsigned int slotIdx) : DictIteratorBase(dict, slotIdx) {}

  /**
   * Copy constructor.
   */
  DictObjectIterator(const DictObjectIterator& right) : DictIteratorBase(right) {}

  V* Value() { return &_dict.GetSlot(_slotIdx).value; }
};

/**
 * Hash-table based dictionary.
 */
template <typename K, typename V>
class DictObject : public DictBase<K, V> {
 public:
  /**
   * Constructor. You may specifiy intial number of DictSlots that holds values or just leave it as it is.
   */
  DictObject(unsigned int _initial_size = 0) {
    if (_initial_size > 0) {
      Resize(_initial_size);
    }
  }

  /**
   * Copy constructor.
   */
  DictObject(const DictObject<K, V>& right) {
    Clear();
    Resize(right.GetSlotCount());
    for (unsigned int i = 0; i < (unsigned int)ArraySize(right._DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i] = right._DictSlots_ref.DictSlots[i];
    }
    _DictSlots_ref._num_used = right._DictSlots_ref._num_used;
    _current_id = right._current_id;
    _mode = right._mode;
  }

  void operator=(const DictObject<K, V>& right) {
    Clear();
    Resize(right.GetSlotCount());
    for (unsigned int i = 0; i < (unsigned int)ArraySize(right._DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i] = right._DictSlots_ref.DictSlots[i];
    }
    _DictSlots_ref._num_used = right._DictSlots_ref._num_used;
    _current_id = right._current_id;
    _mode = right._mode;
  }

  void Clear() {
    for (unsigned int i = 0; i < (unsigned int)ArraySize(_DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i].SetFlags(0);
    }

    _DictSlots_ref._num_used = 0;
  }

  /**
   * Inserts value using hashless key.
   */
  bool Push(V& value) {
    if (!InsertInto(_DictSlots_ref, value)) return false;
    return true;
  }

  /**
   * Inserts value using hashless key.
   */
  bool operator+=(V& value) { return Push(value); }

  /**
   * Inserts or replaces value for a given key.
   */
  bool Set(K key, V& value) {
    if (!InsertInto(_DictSlots_ref, key, value, true)) return false;
    return true;
  }

  V* operator[](K key) {
    DictSlot<K, V>* slot;

    unsigned int position;

    if (_mode == DictModeList)
      slot = GetSlot((unsigned int)key);
    else
      slot = GetSlotByKey(_DictSlots_ref, key, position);

    if (slot == NULL || !slot.IsUsed()) return NULL;

    return &slot.value;
  }

  /**
   * Returns value for a given key.
   */
  V* GetByKey(const K _key) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, _key, position);

    if (!slot) return NULL;

    return &slot.value;
  }

  /**
   * Returns value for a given position.
   */
  V* GetByPos(unsigned int _position) {
    DictSlot<K, V>* slot = GetSlotByPos(_DictSlots_ref, _position);

    if (!slot) {
      Alert("Invalid DictStruct position \"", _position, "\" (called by GetByPos()). Returning empty structure.");
      DebugBreak();
      return NULL;
    }

    return &slot.value;
  }

  /**
   * Checks whether dictionary contains given key => value pair.
   */
  template <>
  bool Contains(const K key, const V& value) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, key, position);

    if (!slot) return false;

    return slot.value == value;
  }

  /**
   * Returns index of dictionary's value or -1 if value doesn't exist.
   */
  template <>
  int IndexOf(V& value) {
    for (DictIteratorBase<K, V> i(Begin()); i.IsValid(); ++i) {
      if (i.Value() == value) {
        return (int)i.Index();
      }
    }

    return -1;
  }

 protected:
  /**
   * Inserts value into given array of DictSlots.
   */
  bool InsertInto(DictSlotsRef<K, V>& dictSlotsRef, const K key, V& value, bool allow_resize) {
    if (_mode == DictModeUnknown)
      _mode = DictModeDict;
    else if (_mode != DictModeDict) {
      Alert("Warning: Dict already operates as a list, not a dictionary!");
      return false;
    }

    unsigned int position;
    DictSlot<K, V>* keySlot = GetSlotByKey(dictSlotsRef, key, position);

    if (keySlot == NULL && !IsGrowUpAllowed()) {
      // Resize is prohibited.
      return false;
    }

    // Will resize dict if there were performance problems before.
    if (allow_resize && IsGrowUpAllowed() && !dictSlotsRef.IsPerformant()) {
      if (!GrowUp()) {
        return false;
      }
      // We now have new positions of slots, so we have to take the corrent slot again.
      keySlot = GetSlotByKey(dictSlotsRef, key, position);
    }

    if (keySlot == NULL && dictSlotsRef._num_used == ArraySize(dictSlotsRef.DictSlots)) {
      // No DictSlotsRef.DictSlots available.
      if (overflow_listener != NULL) {
        if (!overflow_listener(DICT_OVERFLOW_REASON_FULL, dictSlotsRef._num_used, 0)) {
          // Overwriting slot pointed exactly by key's position in the hash table (we don't check for possible
          // conflicts).
          keySlot = &dictSlotsRef.DictSlots[Hash(key) % ArraySize(dictSlotsRef.DictSlots)];
        }
      }

      if (keySlot == NULL) {
        // We need to expand array of DictSlotsRef.DictSlots.
        if (!GrowUp()) return false;
      }
    }

    if (keySlot == NULL) {
      position = Hash(key) % ArraySize(dictSlotsRef.DictSlots);

      unsigned int _starting_position = position;
      int _num_conflicts = 0;
      bool _overwrite_slot = false;

      // Searching for empty DictSlot<K, V> or used one with the matching key. It skips used, hashless DictSlots.
      while (dictSlotsRef.DictSlots[position].IsUsed() &&
             (!dictSlotsRef.DictSlots[position].HasKey() || dictSlotsRef.DictSlots[position].key != key)) {
        if (overflow_listener_max_conflicts != 0 && ++_num_conflicts == overflow_listener_max_conflicts) {
          if (overflow_listener != NULL) {
            if (!overflow_listener(DICT_OVERFLOW_REASON_TOO_MANY_CONFLICTS, dictSlotsRef._num_used, _num_conflicts)) {
              // Overflow listener returned false so we won't search for further empty slot.
              _overwrite_slot = true;
              break;
            }
          } else {
            // Even if there is no overflow listener function, we stop searching for further empty slot as maximum
            // number of conflicts has been reached.
            _overwrite_slot = true;
            break;
          }
        }

        // Position may overflow, so we will start from the beginning.
        position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
      }

      if (_overwrite_slot) {
        // Overwriting starting position for faster further lookup.
        position = _starting_position;
      } else {
        // Slot overwrite is not needed. Using empty slot.
        ++dictSlotsRef._num_used;
      }

      dictSlotsRef.AddConflicts(_num_conflicts);
    }

    dictSlotsRef.DictSlots[position].key = key;
    dictSlotsRef.DictSlots[position].value = value;
    dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_HAS_KEY | DICT_SLOT_IS_USED | DICT_SLOT_WAS_USED);
    return true;
  }

  /**
   * Inserts hashless value into given array of DictSlots.
   */
  bool InsertInto(DictSlotsRef<K, V>& dictSlotsRef, V& value) {
    if (_mode == DictModeUnknown)
      _mode = DictModeList;
    else if (_mode != DictModeList) {
      Alert("Warning: Dict already operates as a dictionary, not a list!");
      DebugBreak();
      return false;
    }

    if (dictSlotsRef._num_used == ArraySize(dictSlotsRef.DictSlots)) {
      // No DictSlotsRef.DictSlots available, we need to expand array of DictSlotsRef.DictSlots.
      if (!GrowUp()) return false;
    }

    unsigned int position = Hash((unsigned int)dictSlotsRef._list_index) % ArraySize(dictSlotsRef.DictSlots);

    // Searching for empty DictSlot<K, V>.
    while (dictSlotsRef.DictSlots[position].IsUsed()) {
      // Position may overflow, so we will start from the beginning.
      position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
    }

    dictSlotsRef.DictSlots[position].value = value;
    dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_IS_USED | DICT_SLOT_WAS_USED);

    ++dictSlotsRef._list_index;
    ++dictSlotsRef._num_used;
    return true;
  }

  /**
   * Expands array of DictSlots by given percentage value.
   */
  bool GrowUp(int percent = DICT_GROW_UP_PERCENT_DEFAULT) {
    return Resize(MathMax(10, (int)((float)ArraySize(_DictSlots_ref.DictSlots) * ((float)(percent + 100) / 100.0f))));
  }

  /**
   * Shrinks or expands array of DictSlots.
   */
  bool Resize(int new_size) {
    if (new_size <= MathMin(_DictSlots_ref._num_used, ArraySize(_DictSlots_ref.DictSlots))) {
      // We already use minimum number of slots possible.
      return true;
    }

    DictSlotsRef<K, V> new_DictSlots;

    int i;

    if (ArrayResize(new_DictSlots.DictSlots, new_size) == -1) return false;

    for (i = 0; i < new_size; ++i) {
      new_DictSlots.DictSlots[i].SetFlags(0);
    }

    // Copies entire array of DictSlots into new array of DictSlots. Hashes will be rehashed.
    for (i = 0; i < ArraySize(_DictSlots_ref.DictSlots); ++i) {
      if (!_DictSlots_ref.DictSlots[i].IsUsed()) continue;

      if (_DictSlots_ref.DictSlots[i].HasKey()) {
        if (!InsertInto(new_DictSlots, _DictSlots_ref.DictSlots[i].key, _DictSlots_ref.DictSlots[i].value, false))
          return false;
      } else {
        if (!InsertInto(new_DictSlots, _DictSlots_ref.DictSlots[i].value)) return false;
      }
    }
    // Freeing old DictSlots array.
    ArrayFree(_DictSlots_ref.DictSlots);

    _DictSlots_ref = new_DictSlots;

    return true;
  }

 public:
#ifdef __MQL__
  template <>
#endif
  SerializerNodeType Serialize(Serializer& s) {
    if (s.IsWriting()) {
      for (DictIteratorBase<K, V> i(Begin()); i.IsValid(); ++i)
        s.PassObject(this, GetMode() == DictModeDict ? i.KeyAsString() : "", i.Value());

      return (GetMode() == DictModeDict) ? SerializerNodeObject : SerializerNodeArray;
    } else {
      if (s.IsArray()) {
        unsigned int num_items = s.NumArrayItems();
        // Entering only if Dict has items.
        if (num_items > 0) {
          s.Enter();

          while (num_items-- != 0) {
            V child;
            child.Serialize(s);
            Push(child);
            s.Next();
          }

          s.Leave();
        }
        return SerializerNodeArray;
      } else {
        SerializerIterator<V> i;

        for (i = s.Begin<V>(); i.IsValid(); ++i) {
          if (i.HasKey()) {
            // Converting key to a string.
            K key;
            Convert::StringToType(i.Key(), key);

            // Note that we're retrieving value by a key (as we are in an
            // object!).
            Set(key, i.Struct(i.Key()));
          } else {
            Push(i.Struct());
          }
        }
        return i.ParentNodeType();
      }
    }
  }

  /**
   * Initializes object with given number of elements. Could be skipped for non-containers.
   */
  template <>
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
    V _child;

    _child.SerializeStub(_n2, _n3, _n4, _n5);

    while (_n1-- > 0) {
      Push(_child);
    }
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DictObject.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Serializer data conversion methods.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif




class SerializerConversions {
 public:
  static string ValueToString(datetime value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
#ifndef __MQL4__
    return (includeQuotes ? "\"" : "") + TimeToString(value) + (includeQuotes ? "\"" : "");
#else
    return (includeQuotes ? "\"" : "") + TimeToStr(value) + (includeQuotes ? "\"" : "");
#endif
  }

  static string ValueToString(bool value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    return string(includeQuotes ? "\"" : "") + (value ? "true" : "false") + (includeQuotes ? "\"" : "");
  }

  static string ValueToString(int value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    return string(includeQuotes ? "\"" : "") + IntegerToString(value) + (includeQuotes ? "\"" : "");
  }

  static string ValueToString(long value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    return string(includeQuotes ? "\"" : "") + IntegerToString(value) + (includeQuotes ? "\"" : "");
  }

  static string ValueToString(string value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    string output = includeQuotes ? "\"" : "";
    unsigned short _char;

    for (unsigned short i = 0; i < StringLen(value); ++i) {
#ifndef __MQL4__
      _char = StringGetCharacter(value, i);
#else
      _char = StringGetChar(value, i);
#endif
      if (escape) {
        switch (_char) {
          case '"':
            output += "\\\"";
            continue;
          case '/':
            output += "\\/";
            continue;
          case '\n':
            if (escape) output += "\\n";
            continue;
          case '\r':
            if (escape) output += "\\r";
            continue;
          case '\t':
            if (escape) output += "\\t";
            continue;
          case '\\':
            if (escape) output += "\\\\";
            continue;
        }
      }

#ifndef __MQL4__
      output += ShortToString(StringGetCharacter(value, i));
#else
      output += ShortToString(StringGetChar(value, i));
#endif
    }

    return output + (includeQuotes ? "\"" : "");
  }

  static string ValueToString(float value, bool includeQuotes = false, bool escape = true, int _fp_precision = 6) {
    return (includeQuotes ? "\"" : "") + StringFormat("%." + IntegerToString(_fp_precision) + "f", value) +
           (includeQuotes ? "\"" : "");
  }

  static string ValueToString(double value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    return (includeQuotes ? "\"" : "") + StringFormat("%." + IntegerToString(_fp_precision) + "f", value) +
           (includeQuotes ? "\"" : "");
  }

  static string ValueToString(Object& _obj, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    return (includeQuotes ? "\"" : "") + _obj.ToString() + (includeQuotes ? "\"" : "");
  }
  template <typename T>
  static string ValueToString(T value, bool includeQuotes = false, bool escape = true, int _fp_precision = 8) {
    return StringFormat("%s%s%s", (includeQuotes ? "\"" : ""), value, (includeQuotes ? "\"" : ""));
  }
  static string UnescapeString(string value) {
    string output = "";
    unsigned short _char1;
    unsigned short _char2;

    for (unsigned short i = 0; i < StringLen(value); ++i) {
#ifndef __MQL4__
      _char1 = StringGetCharacter(value, i);
      _char2 = (i + 1 < StringLen(value)) ? StringGetCharacter(value, i + 1) : 0;
#else
      _char1 = StringGetChar(value, i);
      _char2 = (i + 1 < StringLen(value)) ? StringGetChar(value, i + 1) : 0;
#endif

      if (_char1 == '\\') {
        switch (_char2) {
          case '"':
            output += "\"";
            i++;
            continue;
          case '/':
            output += "/";
            i++;
            continue;
          case 'n':
            output += "\n";
            i++;
            continue;
          case 'r':
            output += "\r";
            i++;
            continue;
          case 't':
            output += "\t";
            i++;
            continue;
          case '\\':
            output += "\\";
            i++;
            continue;
        }
      }

#ifndef __MQL4__
      output += ShortToString(StringGetCharacter(value, i));
#else
      output += ShortToString(StringGetChar(value, i));
#endif
    }

    return output;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerConversions.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.

#ifndef JSON_PARAM_MQH
#define JSON_PARAM_MQH

/**
 * Enumeration.
 */
enum SerializerNodeParamType {
  SerializerNodeParamBool,
  SerializerNodeParamLong,
  SerializerNodeParamDouble,
  SerializerNodeParamString
};

class SerializerNode;

/**
 * Key or value.
 */
class SerializerNodeParam {
 public:
  /**
   * Storing all integral values in a single union. We can't hold string here.
   */
  union USerializerNodeValue {
    bool _bool;
    long _long;
    double _double;
  } _integral;

  string _string;
  SerializerNodeParamType _type;

  // Floating-point precision.
  int fp_precision;

  /**
   * Returns floating-point precision.
   */
  int GetFloatingPointPrecision() { return fp_precision; }

  /**
   * Sets floating-point precision.
   */
  void SetFloatingPointPrecision(int _fp_precision) { fp_precision = _fp_precision; }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromBool(long value);

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromLong(long value);

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromDouble(double value);

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromString(string& value);

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(bool value) { return FromBool(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(char value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(color value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(datetime value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(double value) { return FromDouble(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(int value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(long value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(short value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(string& value) { return FromString(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(unsigned char value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(unsigned int value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(unsigned long value) { return FromLong(value); }

  /**
   * Returns new SerializerNodeParam object from given source value.
   */
  static SerializerNodeParam* FromValue(unsigned short value) { return FromLong(value); }

  /**
   * Returns stringified version of the value. Note "forceQuotesOnString" flag.
   */
  string AsString(bool includeQuotes = false, bool forceQuotesOnString = true, bool escapeString = true,
                  int _fp_precision = 8) {
    switch (_type) {
      case SerializerNodeParamBool:
        return SerializerConversions::ValueToString(_integral._bool, includeQuotes, escapeString, _fp_precision);
      case SerializerNodeParamLong:
        return SerializerConversions::ValueToString(_integral._long, includeQuotes, escapeString, _fp_precision);
      case SerializerNodeParamDouble:
        return SerializerConversions::ValueToString(_integral._double, includeQuotes, escapeString, _fp_precision);
      case SerializerNodeParamString:
        return SerializerConversions::ValueToString(_string, includeQuotes || forceQuotesOnString, escapeString,
                                                    _fp_precision);
    }

#ifdef __debug__
    PrintFormat("%s: Error: SerializerNodeParam.AsString() called for an unknown value type: %d!", __FUNCTION__, _type);
#endif
    return "<invalid param type " + IntegerToString(_type) + ">";
  }

  /**
   * Returns type of the param.
   */
  SerializerNodeParamType GetType() { return _type; }

  long ToBool() {
    switch (_type) {
      case SerializerNodeParamBool:
        return _integral._bool;
      case SerializerNodeParamLong:
        return _integral._long != 0;
      case SerializerNodeParamDouble:
        return _integral._double != 0;
      case SerializerNodeParamString:
        return _string != "" && _string != "0";
      default:
        Alert("Internal Error. Cannot convert source type to bool");
    }

    return false;
  }

  int ToInt() {
    switch (_type) {
      case SerializerNodeParamBool:
        return _integral._bool ? 1 : 0;
      case SerializerNodeParamLong:
        return (int)_integral._long;
      case SerializerNodeParamDouble:
        return (int)_integral._double;
      case SerializerNodeParamString:
        return (int)StringToInteger(_string);
      default:
        Alert("Internal Error. Cannot convert source type to int");
    }

    return 0;
  }

  long ToLong() {
    switch (_type) {
      case SerializerNodeParamBool:
        return _integral._bool ? 1 : 0;
      case SerializerNodeParamLong:
        return _integral._long;
      case SerializerNodeParamDouble:
        return (long)_integral._double;
      case SerializerNodeParamString:
        return StringToInteger(_string);
      default:
        Alert("Internal Error. Cannot convert source type to long");
    }

    return 0;
  }

  float ToFloat() {
    switch (_type) {
      case SerializerNodeParamBool:
        return _integral._bool ? 1.0f : 0.0f;
      case SerializerNodeParamLong:
        return (float)_integral._long;
      case SerializerNodeParamDouble:
        return (float)_integral._double;
      case SerializerNodeParamString:
        return (float)StringToDouble(_string);
      default:
        Alert("Internal Error. Cannot convert source type to float");
    }

    return 0;
  }

  double ToDouble() {
    switch (_type) {
      case SerializerNodeParamBool:
        return _integral._bool ? 1.0 : 0.0;
      case SerializerNodeParamLong:
        return (double)_integral._long;
      case SerializerNodeParamDouble:
        return _integral._double;
      case SerializerNodeParamString:
        return StringToDouble(_string);
      default:
        Alert("Internal Error. Cannot convert source type to double");
    }

    return 0;
  }

  string ToString() {
    switch (_type) {
      case SerializerNodeParamBool:
        return _integral._bool ? "1" : "0";
      case SerializerNodeParamLong:
        return IntegerToString(_integral._long);
      case SerializerNodeParamDouble:
        return DoubleToString(_integral._double);
      case SerializerNodeParamString:
        return _string;
      default:
        Alert("Internal Error. Cannot convert source type to string");
    }

    return "";
  }

  int ConvertTo(int) { return ToInt(); }

  long ConvertTo(long) { return ToInt(); }

  float ConvertTo(float) { return ToFloat(); }

  double ConvertTo(double) { return ToDouble(); }

  string ConvertTo(string) { return ToString(); }
};

/**
 * Returns new SerializerNodeParam object from given source value.
 */
SerializerNodeParam* SerializerNodeParam::FromBool(long value) {
  SerializerNodeParam* param = new SerializerNodeParam();
  PTR_ATTRIB(param, _type) = SerializerNodeParamBool;
  PTR_ATTRIB(param, _integral)._bool = value;
  return param;
}

/**
 * Returns new SerializerNodeParam object from given source value.
 */
SerializerNodeParam* SerializerNodeParam::FromLong(long value) {
  SerializerNodeParam* param = new SerializerNodeParam();
  PTR_ATTRIB(param, _type) = SerializerNodeParamLong;
  PTR_ATTRIB(param, _integral)._long = value;
  return param;
}

/**
 * Returns new SerializerNodeParam object from given source value.
 */
SerializerNodeParam* SerializerNodeParam::FromDouble(double value) {
  SerializerNodeParam* param = new SerializerNodeParam();
  PTR_ATTRIB(param, _type) = SerializerNodeParamDouble;
  PTR_ATTRIB(param, _integral)._double = value;
  return param;
}

/**
 * Returns new SerializerNodeParam object from given source value.
 */
SerializerNodeParam* SerializerNodeParam::FromString(string& value) {
  SerializerNodeParam* param = new SerializerNodeParam();
  PTR_ATTRIB(param, _type) = SerializerNodeParamString;
  PTR_ATTRIB(param, _string) = value;
  return param;
}



#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerNodeParam.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef JSON_NODE_MQH
#define JSON_NODE_MQH

// Includes.



class SerializerNode {
 protected:
  SerializerNodeType _type;

  SerializerNode* _parent;
  SerializerNodeParam* _key;
  SerializerNodeParam* _value;
  ARRAY(SerializerNode*, _children);
  unsigned int _numChildren;
  unsigned int _currentChildIndex;
  unsigned int _flags;
  int _index;

 public:
  /**
   * Constructor.
   */
  SerializerNode(SerializerNodeType type, SerializerNode* parent = NULL, SerializerNodeParam* key = NULL,
                 SerializerNodeParam* value = NULL, unsigned int flags = 0)
      : _type(type), _parent(parent), _key(key), _value(value), _numChildren(0), _currentChildIndex(0), _flags(flags) {}

  /**
   * Destructor.
   */
  ~SerializerNode() {
    if (_key) delete _key;

    if (_value) delete _value;

    for (unsigned int i = 0; i < _numChildren; ++i) delete _children[i];
  }

  void SetKey(string name) {
    if (_key != NULL) {
      delete _key;
    }

    _key = name != "" ? SerializerNodeParam::FromString(name) : NULL;
  }

  /**
   * Sets node flags.
   */
  void SetFlags(unsigned int flags) { _flags = flags; }

  /**
   * Returns node flags.
   */
  unsigned int GetFlags() { return _flags; }

  /**
   * Checks whether node has specified key.
   */
  bool HasKey() { return _key != NULL && PTR_ATTRIB(_key, _string) != ""; }

  /**
   * Checks whether node is an array.
   */
  bool IsArray() { return _type == SerializerNodeArray; }

  /**
   * Checks whether node is an objec with properties.
   */
  bool IsObject() { return _type == SerializerNodeObject; }

  /**
   * Checks whether node is a container.
   */
  bool IsContainer() { return _type == SerializerNodeArray || _type == SerializerNodeObject; }

  /**
   * Checks whether node is a container for values.
   */
  bool IsValuesContainer() {
    return (_type == SerializerNodeArray || _type == SerializerNodeObject) && _numChildren > 0 &&
           !PTR_ATTRIB(_children[0], IsContainer());
  }

  /**
   * Returns index of the current node in the parent.
   */
  int Index() { return _index; }

  /**
   * Returns key specified for a node or empty string (not a NULL).
   */
  string Key() { return _key != NULL ? PTR_ATTRIB(_key, AsString(false, false)) : ""; }

  /**
   * Returns tree size in bytes.
   */
  int BinarySize() {
    int _result = 0;

    if (!IsContainer()) {
      switch (PTR_ATTRIB(_value, GetType())) {
        case SerializerNodeParamBool:
          _result += 1;
          break;
        case SerializerNodeParamDouble:
          _result += 8;
          break;
        case SerializerNodeParamLong:
          _result += 4;
          break;
        case SerializerNodeParamString:
          _result += StringLen(PTR_ATTRIB(_value, _string)) + 1;
          break;
        default:
          Print("Error: Wrong value type ", EnumToString(GetType()), "!");
          DebugBreak();
      }
    }

    for (unsigned int i = 0; i < _numChildren; ++i) _result += PTR_ATTRIB(_children[i], BinarySize());

    return _result;
  }

  /**
   * Overrides floating-point precision for this node and all the children.
   */
  void OverrideFloatingPointPrecision(int _fp_precision) {
    SerializerNodeParam* _value_param = GetValueParam();

    if (_value_param != NULL) {
      PTR_ATTRIB(_value_param, SetFloatingPointPrecision(_fp_precision));
    }

    for (unsigned int i = 0; i < _numChildren; ++i) {
      PTR_ATTRIB(_children[i], OverrideFloatingPointPrecision(_fp_precision));
    }
  }

  /**
   * Returns total number of children and their children inside this node.
   */
  unsigned int TotalNumChildren() {
    if (!IsContainer()) return 1;

    unsigned int _result = 0;

    for (unsigned int i = 0; i < _numChildren; ++i) _result += PTR_ATTRIB(_children[i], TotalNumChildren());

    return _result;
  }

  /**
   * Returns maximum number of children in the last "dimension".
   */
  unsigned int MaximumNumChildrenInDeepEnd() {
    unsigned int _result = 0, i;

    if (GetParent() == NULL) {
      for (i = 0; i < _numChildren; ++i) {
        if (IsObject())
          _result += PTR_ATTRIB(_children[i], MaximumNumChildrenInDeepEnd());
        else
          _result = MathMax(_result, PTR_ATTRIB(_children[i], MaximumNumChildrenInDeepEnd()));
      }

      return _result;
    }

    if (IsObject() || IsArray()) {
      for (i = 0; i < _numChildren; ++i) {
        _result += PTR_ATTRIB(_children[i], MaximumNumChildrenInDeepEnd());
      }
      return _result;
    }

    return 1;
  }

  /**
   * Returns maximum number of containers before the last "dimension".
   */
  unsigned int MaximumNumContainersInDeepEnd() {
    unsigned int _result = 1, _sum = 0;

    if (GetType() == SerializerNodeArrayItem || GetType() == SerializerNodeObjectProperty) {
      return 1;
    }

    for (unsigned int i = 0; i < _numChildren; ++i) {
      if (PTR_ATTRIB(_children[i], GetType()) == SerializerNodeArray ||
          PTR_ATTRIB(_children[i], GetType()) == SerializerNodeObject) {
        _sum += PTR_ATTRIB(_children[i], MaximumNumContainersInDeepEnd());
      }
    }

    return _result * _sum;
  }

  /**
   * Returns pointer to SerializerNodeParam holding the key or NULL.
   */
  SerializerNodeParam* GetKeyParam() { return _key; }

  /**
   * Returns pointer to SerializerNodeParam holding the value or NULL.
   */
  SerializerNodeParam* GetValueParam() { return _value; }

  /**
   * Returns parent node or NULL.
   */
  SerializerNode* GetParent() { return _parent; }

  /**
   * Returns next child node (increments index each time the method is called).
   */
  SerializerNode* GetNextChild() {
    if (_currentChildIndex >= _numChildren) return _children[_numChildren - 1];

    return _children[_currentChildIndex++];
  }

  /**
   * Returns type of the node (object, array, object property, array item).
   */
  SerializerNodeType GetType() { return _type; }

  /**
   * Sets type of the node. Should be used only internally.
   */
  void SetType(SerializerNodeType type) { _type = type; }

  /**
   * Adds child to this node.
   */
  void AddChild(SerializerNode* child) {
    if (_numChildren == ArraySize(_children)) ArrayResize(_children, _numChildren + 10);

    PTR_ATTRIB(child, _index) = (int)_numChildren;
    _children[_numChildren++] = child;
  }

  /**
   * Checks whether node has children.
   */
  bool HasChildren() { return _numChildren > 0; }

  /**
   * Returns number of child nodes.
   */
  unsigned int NumChildren() { return _numChildren; }

  /**
   * Returns pointer to the child node at given index or NULL.
   */
  SerializerNode* GetChild(unsigned int index) { return index >= _numChildren ? NULL : _children[index]; }

  /**
   * Removes child with given index.
   */
  void RemoveChild(unsigned int index) {
    delete _children[index];

    for (unsigned int i = ArraySize(_children) - 2; i >= index; --i) {
      _children[i] = _children[i + 1];
    }
  }

  /**
   * Checks whether this node is last in its parent.
   */
  bool IsLast() {
    if (!_parent) return true;

    for (unsigned int i = 0; i < PTR_ATTRIB(_parent, NumChildren()); ++i) {
      if (PTR_ATTRIB(_parent, GetChild(i)) == THIS_PTR && i != PTR_ATTRIB(_parent, NumChildren() - 1)) return false;
    }

    return true;
  }

  /**
   * Serializes node and its children into string in generic format (JSON at now).
   */
  string ToString(bool trimWhitespaces = false, unsigned int indentSize = 2, unsigned int indent = 0) {
    string repr;
    string ident;

    if (!trimWhitespaces)
      for (unsigned int i = 0; i < indent * indentSize; ++i) ident += " ";

    repr += ident;

    if (GetKeyParam() != NULL && PTR_ATTRIB(GetKeyParam(), AsString(false, false)) != "")
      repr += PTR_ATTRIB(GetKeyParam(), AsString(false, true)) + ":" + (trimWhitespaces ? "" : " ");

    if (GetValueParam() != NULL) repr += PTR_ATTRIB(GetValueParam(), AsString(false, true));

    switch (GetType()) {
      case SerializerNodeObject:
        repr += string("{") + (trimWhitespaces ? "" : "\n");
        break;
      case SerializerNodeArray:
        repr += string("[") + (trimWhitespaces ? "" : "\n");
        break;
    }

    if (HasChildren()) {
      for (unsigned int j = 0; j < NumChildren(); ++j) {
        repr += PTR_ATTRIB(GetChild(j), ToString(trimWhitespaces, indentSize, indent + 1));
      }
    }

    switch (GetType()) {
      case SerializerNodeObject:
        repr += ident + "}";
        break;
      case SerializerNodeArray:
        repr += ident + "]";
        break;
    }

    if (!IsLast()) repr += ",";

    // Appending newline only when inside the root node.
    if (indent != 0) repr += (trimWhitespaces ? "" : "\n");

    return repr;
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerNode.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: File.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Terminal.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Terminal's defines.
 */

/* Defines */

// Custom user errors.
// @docs
// - https://docs.mql4.com/common/setusererror
// - https://www.mql5.com/en/docs/common/SetUserError
#define ERR_USER_ARRAY_IS_EMPTY 1
#define ERR_USER_INVALID_ARG 2
#define ERR_USER_INVALID_BUFF_NUM 3
#define ERR_USER_INVALID_HANDLE 4
#define ERR_USER_ITEM_NOT_FOUND 5
#define ERR_USER_NOT_SUPPORTED 6

// Return codes of the trade server.
#define ERR_NO_ERROR 0
#define ERR_NO_RESULT 1
#define ERR_COMMON_ERROR 2
#define ERR_INVALID_TRADE_PARAMETERS 3
#define ERR_SERVER_BUSY 4
#define ERR_OLD_VERSION 5
#define ERR_NO_CONNECTION 6
#define ERR_NOT_ENOUGH_RIGHTS 7
#define ERR_TOO_FREQUENT_REQUESTS 8
#define ERR_MALFUNCTIONAL_TRADE 9
#define ERR_ACCOUNT_DISABLED 64
#define ERR_INVALID_ACCOUNT 65
#define ERR_TRADE_TIMEOUT 128
#define ERR_INVALID_PRICE 129
#define ERR_INVALID_STOPS 130
#define ERR_INVALID_TRADE_VOLUME 131
#define ERR_MARKET_CLOSED 132
//#define ERR_TRADE_DISABLED                   133
#define ERR_NOT_ENOUGH_MONEY 134
#define ERR_PRICE_CHANGED 135
#define ERR_OFF_QUOTES 136
#define ERR_BROKER_BUSY 137
#define ERR_REQUOTE 138
#define ERR_ORDER_LOCKED 139
#define ERR_LONG_POSITIONS_ONLY_ALLOWED 140
#define ERR_TOO_MANY_REQUESTS 141
#define ERR_TRADE_MODIFY_DENIED 145
#define ERR_TRADE_CONTEXT_BUSY 146
#define ERR_TRADE_EXPIRATION_DENIED 147
#define ERR_TRADE_TOO_MANY_ORDERS 148
#define ERR_TRADE_HEDGE_PROHIBITED 149
#define ERR_TRADE_PROHIBITED_BY_FIFO 150

// Missing error handling constants in MQL4.
// @see: https://docs.mql4.com/constants/errorswarnings/errorcodes
// @see: https://www.mql5.com/en/docs/constants/errorswarnings
#ifndef __MQL5__
// Return codes of the trade server.
// ...
#define ERR_INVALID_PARAMETER 4003  // Wrong parameter when calling the system function.
#endif

// MQL defines.
#ifdef __MQL4__
#define MQL_VER 4
#else
#define MQL_VER 5
#endif
#define MQL_EXT ".ex" + (string)MQL_VER

#ifdef __MQL4__
// The resolution of display on the screen in a number of Dots in a line per Inch (DPI).
// By knowing the value, you can set the size of graphical objects,
// so they can look the same on monitors with different resolution characteristics.
#ifndef TERMINAL_SCREEN_DPI
#define TERMINAL_SCREEN_DPI 27
#endif

// The last known value of a ping to a trade server in microseconds.
// One second comprises of one million microseconds.
#ifndef TERMINAL_PING_LAST
#define TERMINAL_PING_LAST 28
#endif
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Terminal.define.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Terminal.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indicator.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Indicator's defines.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Defines macros.
#define COMMA ,
#define DUMMY

#define ICUSTOM_DEF(SET_HANDLE, PARAMS)                                        \
  double _res[];                                                               \
  if (_handle == NULL || _handle == INVALID_HANDLE) {                          \
    if ((_handle = ::iCustom(_symbol, _tf, _name PARAMS)) == INVALID_HANDLE) { \
      SetUserError(ERR_USER_INVALID_HANDLE);                                   \
      return EMPTY_VALUE;                                                      \
    }                                                                          \
    SET_HANDLE;                                                                \
  }                                                                            \
  if (Terminal::IsVisualMode()) {                                              \
    int _bars_calc = BarsCalculated(_handle);                                  \
    if (GetLastError() > 0) {                                                  \
      return EMPTY_VALUE;                                                      \
    } else if (_bars_calc <= 2) {                                              \
      SetUserError(ERR_USER_INVALID_BUFF_NUM);                                 \
      return EMPTY_VALUE;                                                      \
    }                                                                          \
  }                                                                            \
  if (::CopyBuffer(_handle, _mode, _shift, 1, _res) < 0) {                     \
    return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;                        \
  }                                                                            \
  return _res[0];

// Defines bitwise method macro.
#define METHOD(method, no) ((method & (1 << no)) == 1 << no)

#ifndef __MQL4__
// Defines macros (for MQL4 backward compatibility).
#define IndicatorDigits(_digits) IndicatorSetInteger(INDICATOR_DIGITS, _digits)
#define IndicatorShortName(name) IndicatorSetString(INDICATOR_SHORTNAME, name)
#endif

/* Common indicator line identifiers */

// @see: https://docs.mql4.com/constants/indicatorconstants/lines
// @see: https://www.mql5.com/en/docs/constants/indicatorconstants/lines

#ifndef __MQL__
// Indicator constants.
// @docs
// - https://www.mql5.com/en/docs/constants/indicatorconstants/lines
// Identifiers of indicator lines permissible when copying values of iMACD(), iRVI() and iStochastic().
#define MAIN_LINE 0    // Main line.
#define SIGNAL_LINE 1  // Signal line.
// Identifiers of indicator lines permissible when copying values of ADX() and ADXW().
#define MAIN_LINE 0     // Main line.
#define PLUSDI_LINE 1   // Line +DI.
#define MINUSDI_LINE 2  // Line -DI.
// Identifiers of indicator lines permissible when copying values of iBands().
#define BASE_LINE 0   // Main line.
#define UPPER_BAND 1  // Upper limit.
#define LOWER_BAND 2  // Lower limit.
// Identifiers of indicator lines permissible when copying values of iEnvelopes() and iFractals().
#define UPPER_LINE 0  // Upper line.
#define LOWER_LINE 1  // Bottom line.
#endif

// Forward declarations.
class DrawIndicator;

#ifndef __MQL__
//
// Empty value in an indicator buffer.
// @docs
// - https://docs.mql4.com/constants/namedconstants/otherconstants
// - https://www.mql5.com/en/docs/constants/namedconstants/otherconstants
#define EMPTY_VALUE DBL_MAX
#endif

#define INDICATOR_BUILTIN_CALL_AND_RETURN(NATIVE_METHOD_CALL, MODE, SHIFT)                                 \
  int _handle = Object::IsValid(_obj) ? _obj.Get<int>(IndicatorState::INDICATOR_STATE_PROP_HANDLE) : NULL; \
  double _res[];                                                                                           \
  ResetLastError();                                                                                        \
  if (_handle == NULL || _handle == INVALID_HANDLE) {                                                      \
    if ((_handle = NATIVE_METHOD_CALL) == INVALID_HANDLE) {                                                \
      SetUserError(ERR_USER_INVALID_HANDLE);                                                               \
      return EMPTY_VALUE;                                                                                  \
    } else if (Object::IsValid(_obj)) {                                                                    \
      _obj.SetHandle(_handle);                                                                             \
    }                                                                                                      \
  }                                                                                                        \
  if (Terminal::IsVisualMode()) {                                                                          \
    /* To avoid error 4806 (ERR_INDICATOR_DATA_NOT_FOUND), */                                              \
    /* we check the number of calculated data only in visual mode. */                                      \
    int _bars_calc = BarsCalculated(_handle);                                                              \
    if (GetLastError() > 0) {                                                                              \
      return EMPTY_VALUE;                                                                                  \
    } else if (_bars_calc <= 2) {                                                                          \
      SetUserError(ERR_USER_INVALID_BUFF_NUM);                                                             \
      return EMPTY_VALUE;                                                                                  \
    }                                                                                                      \
  }                                                                                                        \
  if (CopyBuffer(_handle, MODE, SHIFT, 1, _res) < 0) {                                                     \
    return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;                                                    \
  }                                                                                                        \
  return _res[0];

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indicator.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Terminal's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.


// Defines user error enumeration.
enum ENUM_USER_ERR { USER_ERR_INVALID_ARGUMENT };

// Terminal actions.
enum ENUM_TERMINAL_ACTION { TERMINAL_ACTION_CRASH, FINAL_ENUM_TERMINAL_ACTION };

// Terminal conditions.
enum ENUM_TERMINAL_CONDITION { TERMINAL_COND_IS_CONNECTED, FINAL_ENUM_TERMINAL_CONDITION_ENTRY };

#ifndef __MQL__
/**
 * Enumeration for the return codes.
 * @docs
 * https://www.mql5.com/en/docs/basis/function/events
 */
enum ENUM_INIT_RETCODE {
  INIT_SUCCEEDED = 0,         // Successful initialization.
  INIT_FAILED = 1,            // Initialization failed.
  INIT_PARAMETERS_INCORRECT,  // Incorrect set of input parameters.
  INIT_AGENT_NOT_SUITABLE,    // The agent is not suitable for testing.
};
#endif

#ifndef __MQL__

/**
 * Enumeration for the MQL program properties (integer type).
 *
 * @docs
 * - https://www.mql5.com/en/docs/constants/environment_state/mql5_programm_info
 */
enum ENUM_MQL_INFO_INTEGER {
  MQL_DEBUG,            // Indication that the program is running in the debugging mode (bool).
  MQL_DLLS_ALLOWED,     // The permission to use DLL for the given running program (bool).
  MQL_FORWARD,          // Indication that the program is running in the forward testing process (bool).
  MQL_FRAME_MODE,       // Indication that the program is running in gathering optimization result frames mode (bool).
  MQL_LICENSE_TYPE,     // Type of license of the EX module.
  MQL_MEMORY_LIMIT,     // Maximum possible amount of dynamic memory for MQL5 program in MB (int).
  MQL_MEMORY_USED,      // Memory used by MQL5 program in MB (int).
  MQL_OPTIMIZATION,     // Indication that the program is running in the optimization mode (bool).
  MQL_PROFILER,         // Indication that the program is running in the code profiling mode (bool).
  MQL_PROGRAM_TYPE,     // Type of the MQL5 program (ENUM_PROGRAM_TYPE).
  MQL_SIGNALS_ALLOWED,  // The permission to modify the Signals for the given running program (bool).
  MQL_TESTER,           // Indication that the program is running in the tester (bool).
  MQL_TRADE_ALLOWED,    // The permission to trade for the given running program (bool).
  MQL_VISUAL_MODE,      // Indication that the program is running in the visual testing mode (bool).
};

/**
 * Enumeration for the MQL program properties (string type).
 *
 * @docs
 * - https://www.mql5.com/en/docs/constants/environment_state/mql5_programm_info
 */
enum ENUM_MQL_INFO_STRING {
  MQL_PROGRAM_NAME,   // Name of the running mql5-program (string).
  MQL5_PROGRAM_PATH,  // Path for the given running program (string).
};

/**
 * Enumeration for the Terminal properties (double).
 *
 * @docs
 * - https://docs.mql4.com/constants/environment_state/terminalstatus
 * - https://www.mql5.com/en/docs/constants/environment_state/terminalstatus
 */
enum ENUM_TERMINAL_INFO_DOUBLE {
  TERMINAL_COMMUNITY_BALANCE = 0,  // Balance in community account (double).
  TERMINAL_RETRANSMISSION,         // Percentage of resent network packets in the TCP/IP protocol.
};

/**
 * Enumeration for the Terminal properties (integer).
 *
 * @docs
 * - https://docs.mql4.com/constants/environment_state/terminalstatus
 * - https://www.mql5.com/en/docs/constants/environment_state/terminalstatus
 */
enum ENUM_TERMINAL_INFO_INTEGER {
  TERMINAL_BOTTOM,                 // The bottom coordinate of the terminal relative to the virtual screen (int).
  TERMINAL_BUILD,                  // The client terminal build number (int).
  TERMINAL_CODEPAGE,               // Number of the code page of the language installed in the client terminal (int).
  TERMINAL_COMMUNITY_ACCOUNT,      // The flag indicates the presence of community account authorization data (bool).
  TERMINAL_COMMUNITY_CONNECTION,   // Connection to community account (bool).
  TERMINAL_CONNECTED,              // Connection to a trade server (bool).
  TERMINAL_CPU_CORES,              // The number of CPU cores in the system (int).
  TERMINAL_DISK_SPACE,             // Free disk space (in MB) for the MQL Files folder of the terminal (agent).
  TERMINAL_DLLS_ALLOWED,           // Permission to use DLL (bool).
  TERMINAL_EMAIL_ENABLED,          // Permission to send e-mails using SMTP-server and login (bool).
  TERMINAL_FTP_ENABLED,            // Permission to send reports using FTP-server and login (bool).
  TERMINAL_KEYSTATE_CAPSLOCK,      // State of the "CapsLock" key (int).
  TERMINAL_KEYSTATE_CONTROL,       // State of the "Ctrl" key (int).
  TERMINAL_KEYSTATE_DELETE,        // State of the "Delete" key (int).
  TERMINAL_KEYSTATE_DOWN,          // State of the "Down arrow" key (int).
  TERMINAL_KEYSTATE_END,           // State of the "End" key (int).
  TERMINAL_KEYSTATE_ENTER,         // State of the "Enter" key (int).
  TERMINAL_KEYSTATE_ESCAPE,        // State of the "Escape" key (int).
  TERMINAL_KEYSTATE_HOME,          // State of the "Home" key (int).
  TERMINAL_KEYSTATE_INSERT,        // State of the "Insert" key (int).
  TERMINAL_KEYSTATE_LEFT,          // State of the "Left arrow" key (int).
  TERMINAL_KEYSTATE_MENU,          // State of the "Windows" key (int).
  TERMINAL_KEYSTATE_NUMLOCK,       // State of the "NumLock" key (int).
  TERMINAL_KEYSTATE_PAGEDOWN,      // State of the "PageDown" key (int).
  TERMINAL_KEYSTATE_PAGEUP,        // State of the "PageUp" key (int).
  TERMINAL_KEYSTATE_RIGHT,         // State of the "Right arrow" key (int).
  TERMINAL_KEYSTATE_SCRLOCK,       // State of the "ScrollLock" key (int).
  TERMINAL_KEYSTATE_SHIFT,         // State of the "Shift" key (int).
  TERMINAL_KEYSTATE_TAB,           // State of the "Tab" key (int).
  TERMINAL_KEYSTATE_UP,            // State of the "Up arrow" key (int).
  TERMINAL_LEFT,                   // The left coordinate of the terminal relative to the virtual screen (int).
  TERMINAL_MAXBARS,                // The maximal bars count on the chart (int).
  TERMINAL_MEMORY_AVAILABLE,       // Free memory of the terminal (agent) process, MB (int).
  TERMINAL_MEMORY_PHYSICAL,        // Physical memory in the system, MB (int).
  TERMINAL_MEMORY_TOTAL,           // Memory available (in MB) to the process of the terminal (agent) (int).
  TERMINAL_MEMORY_USED,            // Memory used by the terminal (agent), MB (int).
  TERMINAL_MQID,                   // The flag indicates the presence of MQL ID data for Push notifications (bool).
  TERMINAL_NOTIFICATIONS_ENABLED,  // Permission to send notifications to smartphone (bool).
  TERMINAL_OPENCL_SUPPORT,         // The version of the supported OpenCL (int).
  TERMINAL_PING_LAST,              // The last known value of a ping (in micro ms) to a trade server in microseconds.
  TERMINAL_RIGHT,                  // The right coordinate of the terminal relative to the virtual screen (int).
  TERMINAL_SCREEN_DPI,             // The resolution of information display on the screen (DPI) (int).
  TERMINAL_SCREEN_HEIGHT,          // Terminal height (int).
  TERMINAL_SCREEN_LEFT,            // The left coordinate of the virtual screen (int).
  TERMINAL_SCREEN_TOP,             // The top coordinate of the virtual screen (int).
  TERMINAL_SCREEN_WIDTH,           // Terminal width (int).
  TERMINAL_TOP,                    // The top coordinate of the terminal relative to the virtual screen (int).
  TERMINAL_TRADE_ALLOWED,          // Permission to trade (bool).
  TERMINAL_VPS,                    // Indication that the terminal is launched on the VPS (bool).
  TERMINAL_X64,                    // Indication of the "64-bit terminal" (bool).
};

/**
 * Enumeration for the Terminal properties (string).
 *
 * @docs
 * - https://docs.mql4.com/constants/environment_state/terminalstatus
 * - https://www.mql5.com/en/docs/constants/environment_state/terminalstatus
 */
enum ENUM_TERMINAL_INFO_STRING {
  TERMINAL_COMMONDATA_PATH,  // Common path for all of the terminals installed on a computer (string).
  TERMINAL_COMPANY,          // Company name (string).
  TERMINAL_DATA_PATH,        // Folder in which terminal data are stored (string).
  TERMINAL_LANGUAGE,         // Language of the terminal (string).
  TERMINAL_NAME,             // Terminal name (string).
  TERMINAL_PATH,             // Folder from which the terminal is started (string).
};

/**
 * Uninitialization reason codes are returned by the UninitializeReason() function.
 *
 * @docs
 * - https://www.mql5.com/en/docs/constants/namedconstants/uninit
 */
enum ENUM_UNINIT_REASON {
  REASON_PROGRAM = 0,
  REASON_REMOVE = 1,
  REASON_RECOMPILE = 2,
  REASON_CHARTCHANGE = 3,
  REASON_CHARTCLOSE = 4,
  REASON_PARAMETERS = 5,
  REASON_ACCOUNT = 6,
  REASON_TEMPLATE = 7,
  REASON_INITFAILED = 8,
  REASON_CLOSE = 9,
};
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Terminal.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * File class to manage files.
 *
 * Notes:
 * - For security reasons, work with files is strictly controlled in the MQL language.
 * - Files with which file operations are conducted means cannot be outside the file sandbox.
 */

// Includes.



#ifndef __MQL__
enum ENUM_FILE_PROPERTY_INTEGER {
  FILE_EXISTS,
  FILE_CREATE_DATE,
  FILE_MODIFY_DATE,
  FILE_ACCESS_DATE,
  FILE_SIZE,
  FILE_POSITION,
  FILE_END,
  FILE_LINE_END,
  FILE_IS_COMMON,
  FILE_IS_TEXT,
  FILE_IS_BINARY,
  FILE_IS_CSV,
  FILE_IS_ANSI,
  FILE_IS_READABLE,
  FILE_IS_WRITABLE,
};
enum ENUM_FILE_OPEN_FLAGS {
  FILE_READ = 1,
  FILE_WRITE = 2,
  FILE_BIN = 4,
  FILE_CSV = 8,
  FILE_TXT = 16,
  FILE_ANSI = 32,
  FILE_UNICODE = 64,
  FILE_SHARE_READ = 128,
  FILE_SHARE_WRITE = 256,
  FILE_REWRITE = 512,
  FILE_COMMON = 4096,
};
#endif

/**
 * Class to provide a group of functions for working with files.
 */
class File {
 public:
  /**
   * Read file and return its content.
   *
   * @param string dlm
   *   Delimiter to separate the items.
   *
   * @return string
   *   Content of the file.
   */
  static string ReadContent(string file_name, int open_flags = FILE_TXT, short dlm = ';', bool verbose = true) {
    int file_handle = FileOpen(file_name, open_flags, dlm);
    int str_size;
    string str;
    if (file_handle < 0) {
      if (verbose) {
        PrintFormat("%s: Error: Failed to open %s file: %i", __FUNCTION__, C_STR(file_name), GetLastError());
      }
      return "";
    }
    ResetLastError();
    while (!FileIsEnding(file_handle)) {
      // Find out how many symbols are used for writing the time.
      str_size = FileReadInteger(file_handle, INT_VALUE);
      // Read the string.
      str += FileReadString(file_handle, str_size);
    }
    FileClose(file_handle);
    return str;
  }

  static bool FileIsExist(string file_name, int common_flag = 0) { return ::FileIsExist(file_name, common_flag); }

  /**
   * Loads file as ANSI string. Converts newlines to "\n".
   */
  static string ReadFile(string path) {
    int handle = FileOpen(path, FILE_READ | FILE_ANSI, 0);
    ResetLastError();

    if (handle == INVALID_HANDLE) {
      string terminalDataPath = TerminalInfoString(TERMINAL_DATA_PATH);
#ifdef __MQL5__
      string terminalSubfolder = "MQL5";
#else
      string terminalSubfolder = "MQL4";
#endif
      Print("Cannot open file \"", path, "\" for reading. Error code: ", GetLastError(),
            ". Consider using path relative to \"" + terminalDataPath + "\\" + terminalSubfolder +
                "\\Files\\\" as absolute paths may not work.");
      return NULL;
    }

    string data = "";

    while (!FileIsEnding(handle)) {
      data += FileReadString(handle) + "\n";
    }

    FileClose(handle);

    return data;
  }

  /**
   * Saves ANSI string into file.
   */
  static bool SaveFile(string path, string data, bool binary = false) {
    ResetLastError();

    int handle = FileOpen(path, FILE_WRITE | (binary ? FILE_BIN : FILE_ANSI));

    if (handle == INVALID_HANDLE) {
      string terminalDataPath = TerminalInfoString(TERMINAL_DATA_PATH);
#ifdef __MQL5__
      string terminalSubfolder = "MQL5";
#else
      string terminalSubfolder = "MQL4";
#endif
      Print("Cannot open file \"", path, "\" for writing. Error code: ", GetLastError(),
            ". Consider using path relative to \"" + terminalDataPath + "\\" + terminalSubfolder +
                "\\Files\\\" as absolute paths may not work.");
      return false;
    }

    FileWriteString(handle, data);

    FileClose(handle);

    return GetLastError() == ERR_NO_ERROR;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: File.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef SERIALIZER_CONVERTER_MQH
#define SERIALIZER_CONVERTER_MQH

// Forward declarations.
class SerializerNode;

// Includes.




class SerializerConverter {
 public:
  SerializerNode* root_node;
  int _serializer_flags;

  SerializerConverter(SerializerNode* _root = NULL, int serializer_flags = 0)
      : root_node(_root), _serializer_flags(serializer_flags) {}

  SerializerConverter(SerializerConverter& right) {
    root_node = right.root_node;
    _serializer_flags = right._serializer_flags;
  }

  SerializerNode* Node() { return root_node; }

  string ToDebugString(int _json_flags = 0) {
    if (root_node == NULL) {
      return "<NULL>";
    }

    return root_node.ToString(_json_flags);
  }

  template <typename X>
  static SerializerConverter FromObject(X& _value, int serializer_flags = SERIALIZER_FLAG_INCLUDE_ALL) {
    Serializer _serializer(NULL, Serialize, serializer_flags);
    _serializer.FreeRootNodeOwnership();
    _serializer.PassObject(_value, "", _value, SERIALIZER_FIELD_FLAG_VISIBLE);
    SerializerConverter _converter(_serializer.GetRoot(), serializer_flags);
#ifdef __debug__
    Print("FromObject(): serializer flags: ", serializer_flags);
    Print("FromObject(): result: ",
          _serializer.GetRoot() != NULL ? _serializer.GetRoot().ToString(SERIALIZER_JSON_NO_WHITESPACES) : "NULL");
#endif
    return _converter;
  }

  template <typename X>
  static SerializerConverter FromObject(X* _value, int serializer_flags = SERIALIZER_FLAG_INCLUDE_ALL) {
    Serializer _serializer(NULL, Serialize, serializer_flags);
    _serializer.FreeRootNodeOwnership();
    _serializer.PassObject(_value, "", _value, SERIALIZER_FIELD_FLAG_VISIBLE);
    SerializerConverter _converter(_serializer.GetRoot(), serializer_flags);
#ifdef __debug__
    Print("FromObject(): serializer flags: ", serializer_flags);
    Print("FromObject(): result: ",
          _serializer.GetRoot() != NULL ? _serializer.GetRoot().ToString(SERIALIZER_JSON_NO_WHITESPACES) : "NULL");
#endif
    return _converter;
  }

  /**
   * Overrides floating-point precision for all fields.
   */
  SerializerConverter* Precision(int _fp_precision) {
    if (root_node == NULL) {
      return THIS_PTR;
    }
    PTR_ATTRIB(root_node, OverrideFloatingPointPrecision(_fp_precision));
    return THIS_PTR;
  }

  template <typename X>
  static SerializerConverter FromStruct(X _value, int serializer_flags = SERIALIZER_FLAG_INCLUDE_ALL) {
    Serializer _serializer(NULL, Serialize, serializer_flags);
    _serializer.FreeRootNodeOwnership();
    _serializer.PassStruct(_value, "", _value, SERIALIZER_FIELD_FLAG_VISIBLE);
    SerializerConverter _converter(_serializer.GetRoot(), serializer_flags);
    return _converter;
  }

  template <typename C>
  static SerializerConverter FromString(string arg) {
    SerializerConverter _converter(((C*)NULL).Parse(arg), 0);
    return _converter;
  }

  template <typename C>
  static SerializerConverter FromFile(string path) {
    string data = File::ReadFile(path);
    SerializerConverter _converter(((C*)NULL).Parse(data), 0);
    return _converter;
  }

  template <typename R>
  string ToString(unsigned int stringify_flags = 0, void* stringify_aux_arg = NULL) {
    string result = ((R*)NULL).Stringify(root_node, stringify_flags, stringify_aux_arg);
    if ((_serializer_flags & SERIALIZER_FLAG_REUSE_OBJECT) == 0) {
      Clean();
    }
    return result;
  }

  template <typename X>
  bool ToObject(X& obj, unsigned int serializer_flags = 0) {
    Serializer _serializer(root_node, Unserialize, serializer_flags);
    _serializer.PassObject(obj, "", obj, SERIALIZER_FIELD_FLAG_VISIBLE);
    if ((_serializer_flags & SERIALIZER_FLAG_REUSE_OBJECT) == 0) {
      // We don't want serializer and converter to delete the same root node.
      _serializer.FreeRootNodeOwnership();
      Clean();
    }
    return true;
  }

  template <typename X>
  bool ToStruct(X& obj, unsigned int serializer_flags = 0) {
    Serializer _serializer(root_node, Unserialize, serializer_flags);
    _serializer.PassStruct(obj, "", obj, SERIALIZER_FIELD_FLAG_VISIBLE);
    if ((_serializer_flags & SERIALIZER_FLAG_REUSE_OBJECT) == 0) {
      // We don't want serializer and converter to delete the same root node.
      _serializer.FreeRootNodeOwnership();
      Clean();
    }
    return true;
  }

  template <typename C>
  bool ToFile(string path, unsigned int stringify_flags = 0, void* aux_target_arg = NULL) {
    string data = ToString<C>(stringify_flags, aux_target_arg);
    return File::SaveFile(path, data);
  }

  template <typename C>
  bool ToFileBinary(string path, unsigned int stringify_flags = 0, void* aux_target_arg = NULL) {
    string data = ToString<C>(stringify_flags, aux_target_arg);
    return File::SaveFile(path, data, true);
  }

  template <typename X, typename V>
  bool ToDict(X& obj, unsigned int extractor_flags = 0) {
    SerializerDict::Extract<X, V>(root_node, obj, extractor_flags);
    if ((_serializer_flags & SERIALIZER_FLAG_REUSE_OBJECT) == 0) {
      Clean();
    }
    return true;
  }

#ifdef SERIALIZER_CSV_MQH

  /**
   * Converts object into CSV and then SQL. Thus way we don't duplicate CSV serializer's code.
   */
  string ToSQL(unsigned int _stringify_flags = 0, void* _stub = NULL);

  /**
   * Converts object into CSV and then SQL. Thus way we don't duplicate CSV serializer's code.
   */
  bool ToSQLFile(string _path, unsigned int _stringify_flags = 0, void* _stub = NULL) {
    string _data = ToSQL(_stringify_flags, _stub);
    return File::SaveFile(_path, _data);
  }

#endif

  void Clean() {
    if (root_node != NULL) {
      delete root_node;
      root_node = NULL;
    }
  }

  template <typename X>
  static SerializerConverter MakeStubObject(int _serializer_flags = 0, int _n1 = 1, int _n2 = 1, int _n3 = 1,
                                            int _n4 = 1, int _n5 = 1) {
    X stub;
    stub.SerializeStub(_n1, _n2, _n3, _n4, _n5);
    return SerializerConverter::FromObject(stub, _serializer_flags);
  }

  template <typename X>
  static SerializerConverter MakeStubObject(X& stub, int _serializer_flags = 0, int _n1 = 1, int _n2 = 1, int _n3 = 1,
                                            int _n4 = 1, int _n5 = 1) {
    stub.SerializeStub(_n1, _n2, _n3, _n4, _n5);
    return SerializerConverter::FromObject(stub, _serializer_flags);
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerConverter.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Database.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: MiniMatrix.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef MINIMATRIX_MQH
#define MINIMATRIX_MQH

template <typename T>
class MiniMatrix2d {
 public:
  T data[];
  int size_x;
  int size_y;

  MiniMatrix2d() {}
  MiniMatrix2d(int _size_x, int _size_y) : size_x(_size_x), size_y(_size_y) { Resize(_size_x, _size_y); }

  void Resize(int _size_x, int _size_y) {
    ArrayResize(data, _size_x * _size_y);
    size_x = _size_x;
    size_y = _size_y;
  }

  T Get(int _x, int _y) { return data[(size_x * _y) + _x]; }

  void Set(int _x, int _y, T _value) {
    int index = (size_x * _y) + _x;

    if (index < 0 || index >= (size_x * size_y)) {
      Alert("Array out of range!");
    }

    data[index] = _value;
  }

  int SizeX() { return size_x; }

  int SizeY() { return size_y; }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: MiniMatrix.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DictStruct.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictBase.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictIteratorBase.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef DICT_STRUCT_MQH
#define DICT_STRUCT_MQH

// Forward declarations.
class Dynamic;
class Log;





// DictIterator could be used as DictStruct iterator.
#define DictStructIterator DictIteratorBase

/**
 * Hash-table based dictionary.
 */
template <typename K, typename V>
class DictStruct : public DictBase<K, V> {
 public:
  /**
   * Constructor. You may specifiy intial number of DictSlots that holds values or just leave it as it is.
   */
  DictStruct(unsigned int _initial_size = 0) {
    if (_initial_size > 0) {
      Resize(_initial_size);
    }
  }

  /**
   * Copy constructor.
   */
  DictStruct(const DictStruct<K, V>& right) {
    Clear();
    Resize(right.GetSlotCount());
    for (unsigned int i = 0; i < (unsigned int)ArraySize(right._DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i] = right._DictSlots_ref.DictSlots[i];
    }
    _DictSlots_ref._num_used = right._DictSlots_ref._num_used;
    _current_id = right._current_id;
    _mode = right._mode;
  }

  void operator=(const DictStruct<K, V>& right) {
    Clear();
    Resize(right.GetSlotCount());
    for (unsigned int i = 0; i < (unsigned int)ArraySize(right._DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i] = right._DictSlots_ref.DictSlots[i];
    }
    _DictSlots_ref._num_used = right._DictSlots_ref._num_used;
    _current_id = right._current_id;
    _mode = right._mode;
  }

  void Clear() {
    for (unsigned int i = 0; i < (unsigned int)ArraySize(_DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i].SetFlags(0);
    }

    _DictSlots_ref._num_used = 0;
  }

  DictStructIterator<K, V> Begin() {
    // Searching for first item index.
    for (unsigned int i = 0; i < (unsigned int)ArraySize(_DictSlots_ref.DictSlots); ++i) {
      if (_DictSlots_ref.DictSlots[i].IsValid() && _DictSlots_ref.DictSlots[i].IsUsed()) {
        DictStructIterator<K, V> iter(this, i);
        return iter;
      }
    }
    // No items found.
    DictStructIterator<K, V> invalid;
    return invalid;
  }

  /**
   * Inserts value using hashless key.
   */
  bool Push(V& value) {
    if (!InsertInto(_DictSlots_ref, value)) return false;
    return true;
  }

  /**
   * Inserts value using hashless key.
   */
  bool operator+=(V& value) { return Push(value); }

/**
 * Inserts value using hashless key.
 */
#ifdef __MQL__
  template <>
#endif
  bool Push(Dynamic* value) {
    V ptr = value;

    if (!InsertInto(_DictSlots_ref, ptr)) return false;
    return true;
  }

  /**
   * Inserts or replaces value for a given key.
   */
  bool Set(K key, V& value) {
    if (!InsertInto(_DictSlots_ref, key, value, true)) return false;
    return true;
  }

  /**
   * Index operator. Returns value for a given key.
   */
  V operator[](K key) {
    DictSlot<K, V>* slot;

    int position;

    if (_mode == DictModeList)
      slot = GetSlot((unsigned int)key);
    else
      slot = GetSlotByKey(_DictSlots_ref, key, position);

    if (slot == NULL || !slot.IsUsed()) {
      Alert("Invalid DictStruct key \"", key, "\" (called by [] operator). Returning empty structure.");
      DebugBreak();
      static V _empty;
      return _empty;
    }

    return slot.value;
  }

  /**
   * Returns value for a given key.
   */
  V GetByKey(const K _key) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, _key, position);

    if (!slot) {
      static V _empty;
      return _empty;
    }

    return slot.value;
  }

  /**
   * Returns value for a given key.
   *
   * @return
   *   Returns value for a given key, otherwise the default value.
   */
  V GetByKey(const K _key, V& _default) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, _key, position);

    if (!slot) {
      return _default;
    }

    return slot.value;
  }

  /**
   * Returns value for a given position.
   */
  V GetByPos(unsigned int _position) {
    DictSlot<K, V>* slot = GetSlotByPos(_DictSlots_ref, _position);

    if (!slot) {
      Alert("Invalid DictStruct position \"", _position, "\" (called by GetByPos()). Returning empty structure.");
      DebugBreak();
      static V _empty;
      return _empty;
    }

    return slot.value;
  }

/**
 * Checks whether dictionary contains given key => value pair.
 */
#ifdef __MQL__
  template <>
#endif
  /**
   * Checks whether dictionary contains given value.
   */
  bool Contains(const V& value) {
    for (DictStructIterator<K, V> i = Begin(); i.IsValid(); ++i) {
      if (i.Value() == value) {
        return true;
      }
    }

    return false;
  }

  /**
   * Checks whether dictionary contains given key and value.
   */
  template <>
  bool Contains(const K key, const V& value) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, key, position);

    if (!slot) return false;

    return slot.value == value;
  }

  /**
   * Returns index of dictionary's value or -1 if value doesn't exist.
   */
  template <>
  int IndexOf(const V& value) {
    for (DictIteratorBase<K, V> i(Begin()); i.IsValid(); ++i) {
      if (i.Value() == value) {
        return (int)i.Index();
      }
    }

    return -1;
  }

 protected:
  /**
   * Inserts value into given array of DictSlots.
   */
  bool InsertInto(DictSlotsRef<K, V>& dictSlotsRef, const K key, V& value, bool allow_resize) {
    if (_mode == DictModeUnknown)
      _mode = DictModeDict;
    else if (_mode != DictModeDict) {
      Alert("Warning: Dict already operates as a list, not a dictionary!");
      return false;
    }

    unsigned int position;
    DictSlot<K, V>* keySlot = GetSlotByKey(dictSlotsRef, key, position);

    if (keySlot == NULL && !IsGrowUpAllowed()) {
      // Resize is prohibited.
      return false;
    }

    // Will resize dict if there were performance problems before.
    if (allow_resize && IsGrowUpAllowed() && !dictSlotsRef.IsPerformant()) {
      if (!GrowUp()) {
        return false;
      }
      // We now have new positions of slots, so we have to take the corrent slot again.
      keySlot = GetSlotByKey(dictSlotsRef, key, position);
    }

    if (keySlot == NULL && dictSlotsRef._num_used == ArraySize(dictSlotsRef.DictSlots)) {
      // No DictSlotsRef.DictSlots available.
      if (overflow_listener != NULL) {
        if (!overflow_listener(DICT_OVERFLOW_REASON_FULL, dictSlotsRef._num_used, 0)) {
          // Overwriting slot pointed exactly by key's position in the hash table (we don't check for possible
          // conflicts).
          keySlot = &dictSlotsRef.DictSlots[Hash(key) % ArraySize(dictSlotsRef.DictSlots)];
        }
      }

      if (keySlot == NULL) {
        // We need to expand array of DictSlotsRef.DictSlots.
        if (!GrowUp()) return false;
      }
    }

    if (keySlot == NULL) {
      position = Hash(key) % ArraySize(dictSlotsRef.DictSlots);

      unsigned int _starting_position = position;
      int _num_conflicts = 0;
      bool _overwrite_slot = false;

      // Searching for empty DictSlot<K, V> or used one with the matching key. It skips used, hashless DictSlots.
      while (dictSlotsRef.DictSlots[position].IsUsed() &&
             (!dictSlotsRef.DictSlots[position].HasKey() || dictSlotsRef.DictSlots[position].key != key)) {
        if (overflow_listener_max_conflicts != 0 && ++_num_conflicts == overflow_listener_max_conflicts) {
          if (overflow_listener != NULL) {
            if (!overflow_listener(DICT_OVERFLOW_REASON_TOO_MANY_CONFLICTS, dictSlotsRef._num_used, _num_conflicts)) {
              // Overflow listener returned false so we won't search for further empty slot.
              _overwrite_slot = true;
              break;
            }
          } else {
            // Even if there is no overflow listener function, we stop searching for further empty slot as maximum
            // number of conflicts has been reached.
            _overwrite_slot = true;
            break;
          }
        }

        // Position may overflow, so we will start from the beginning.
        position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
      }

      if (_overwrite_slot) {
        // Overwriting starting position for faster further lookup.
        position = _starting_position;
      } else {
        // Slot overwrite is not needed. Using empty slot.
        ++dictSlotsRef._num_used;
      }

      dictSlotsRef.AddConflicts(_num_conflicts);
    }

    dictSlotsRef.DictSlots[position].key = key;
    dictSlotsRef.DictSlots[position].value = value;
    dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_HAS_KEY | DICT_SLOT_IS_USED | DICT_SLOT_WAS_USED);
    return true;
  }

  /**
   * Inserts hashless value into given array of DictSlots.
   */
  bool InsertInto(DictSlotsRef<K, V>& dictSlotsRef, V& value) {
    if (_mode == DictModeUnknown)
      _mode = DictModeList;
    else if (_mode != DictModeList) {
      Alert("Warning: Dict already operates as a dictionary, not a list!");
      return false;
    }

    if (dictSlotsRef._num_used == ArraySize(dictSlotsRef.DictSlots)) {
      // No DictSlotsRef.DictSlots available, we need to expand array of DictSlotsRef.DictSlots.
      if (!GrowUp()) return false;
    }

    unsigned int position = Hash((unsigned int)dictSlotsRef._list_index) % ArraySize(dictSlotsRef.DictSlots);

    // Searching for empty DictSlot<K, V>.
    while (dictSlotsRef.DictSlots[position].IsUsed()) {
      // Position may overflow, so we will start from the beginning.
      position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
    }

    dictSlotsRef.DictSlots[position].value = value;
    dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_IS_USED | DICT_SLOT_WAS_USED);

    ++dictSlotsRef._list_index;
    ++dictSlotsRef._num_used;
    return true;
  }

  /**
   * Expands array of DictSlots by given percentage value.
   */
  bool GrowUp(int percent = DICT_GROW_UP_PERCENT_DEFAULT) {
    return Resize(MathMax(10, (int)((float)ArraySize(_DictSlots_ref.DictSlots) * ((float)(percent + 100) / 100.0f))));
  }

  /**
   * Shrinks or expands array of DictSlots.
   */
  bool Resize(int new_size) {
    if (new_size <= MathMin(_DictSlots_ref._num_used, ArraySize(_DictSlots_ref.DictSlots))) {
      // We already use minimum number of slots possible.
      return true;
    }

    DictSlotsRef<K, V> new_DictSlots;

    if (ArrayResize(new_DictSlots.DictSlots, new_size) == -1) return false;

    int i;

    for (i = 0; i < new_size; ++i) {
      new_DictSlots.DictSlots[i].SetFlags(0);
    }

    // Copies entire array of DictSlots into new array of DictSlots. Hashes will be rehashed.
    for (i = 0; i < ArraySize(_DictSlots_ref.DictSlots); ++i) {
      if (!_DictSlots_ref.DictSlots[i].IsUsed()) continue;

      if (_DictSlots_ref.DictSlots[i].HasKey()) {
        if (!InsertInto(new_DictSlots, _DictSlots_ref.DictSlots[i].key, _DictSlots_ref.DictSlots[i].value, false))
          return false;
      } else {
        if (!InsertInto(new_DictSlots, _DictSlots_ref.DictSlots[i].value)) return false;
      }
    }
    // Freeing old DictSlots array.
    ArrayFree(_DictSlots_ref.DictSlots);

    _DictSlots_ref = new_DictSlots;

    return true;
  }

 public:
#ifdef __MQL__
  template <>
#endif
  SerializerNodeType Serialize(Serializer& s) {
    if (s.IsWriting()) {
      for (DictIteratorBase<K, V> i(Begin()); i.IsValid(); ++i)
        s.PassObject(this, GetMode() == DictModeDict ? i.KeyAsString() : "", i.Value());

      return (GetMode() == DictModeDict) ? SerializerNodeObject : SerializerNodeArray;
    } else {
      if (s.IsArray()) {
        unsigned int num_items = s.NumArrayItems();
        // Entering only if Dict has items.
        if (num_items > 0) {
          s.Enter();

          while (num_items-- != 0) {
            V child;
            child.Serialize(s);
            Push(child);
            s.Next();
          }

          s.Leave();
        }
        return SerializerNodeArray;
      } else {
        SerializerIterator<V> i;

        for (i = s.Begin<V>(); i.IsValid(); ++i) {
          if (i.HasKey()) {
            // Converting key to a string.
            K key;
            Convert::StringToType(i.Key(), key);

            // Note that we're retrieving value by a key (as we are in an
            // object!).
            Set(key, i.Struct(i.Key()));
          } else {
            Push(i.Struct());
          }
        }
        return i.ParentNodeType();
      }
    }
  }

/**
 * Initializes object with given number of elements. Could be skipped for non-containers.
 */
#ifdef __MQL__
  template <>
#endif
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
    V _child;

    _child.SerializeStub(_n2, _n3, _n4, _n5);

    while (_n1-- > 0) {
      Push(_child);
    }
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DictStruct.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/*
 * Implements Database class.
 *
 * The methods for working with databases uses SQLite engine.
 *
 * @docs https://www.mql5.com/en/docs/database
 */

// Prevents processing this includes file for the second time.
#ifndef DATABASE_MQH
#define DATABASE_MQH

// Includes.



// Enums.
enum DATABASE_COLUMN_FLAGS {
  DATABASE_COLUMN_FLAG_NONE = 0,
  DATABASE_COLUMN_FLAG_IS_KEY = 1,
  DATABASE_COLUMN_FLAG_IS_NULL = 2,
};

// Structs.
struct DatabaseTableColumnEntry {
  string name;
  ENUM_DATATYPE type;
  unsigned short flags;
  unsigned short char_size;
  // Getter methods;
  string GetDatatype() {
    switch (type) {
      case TYPE_BOOL:
        return "BOOL";
      case TYPE_CHAR:
        return StringFormat("CHAR(%d)", char_size);
      case TYPE_DOUBLE:
        return "REAL";
      case TYPE_INT:
        return "INT";
      case TYPE_LONG:
        return "LONG";
      case TYPE_STRING:
        return "TEXT";
    }
    return "UNKNOWN";
  }
  string GetFlags() { return GetKey() + " " + GetNull(); }
  string GetName() { return name; }
  string GetNull() { return !IsNull() ? "NOT NULL" : ""; }
  string GetKey() { return IsKey() ? "KEY" : ""; }
  // State methods.
  bool IsKey() { return bool(flags & DATABASE_COLUMN_FLAG_IS_KEY); }
  bool IsNull() { return bool(flags & DATABASE_COLUMN_FLAG_IS_NULL); }
};
struct DatabaseTableSchema {
  DictStruct<short, DatabaseTableColumnEntry> columns;
  // Constructor.
  DatabaseTableSchema() {}
  DatabaseTableSchema(DatabaseTableColumnEntry &_columns[]) {
    for (int i = 0; i < ArraySize(_columns); i++) {
      columns.Push(_columns[i]);
    }
  }
  // Methods.
  bool AddColumn(DatabaseTableColumnEntry &column) { return columns.Push(column); }
};
// Struct table entry for SymbolInfo.
#ifdef SYMBOLINFO_MQH
struct DbSymbolInfoEntry : public SymbolInfoEntry {
  DatabaseTableSchema schema;
  // Constructors.
  DbSymbolInfoEntry() { DefineSchema(); }
  DbSymbolInfoEntry(const MqlTick &_tick, const string _symbol = NULL) : SymbolInfoEntry(_tick, _symbol) {
    DefineSchema();
  }
  // Methods.
  void DefineSchema() {
    DatabaseTableColumnEntry _columns[] = {
        {"bid", TYPE_DOUBLE},    {"ask", TYPE_DOUBLE}, {"last", TYPE_DOUBLE},
        {"spread", TYPE_DOUBLE}, {"volume", TYPE_INT},
    };
    for (int i = 0; i < ArraySize(_columns); i++) {
      schema.columns.Push(_columns[i]);
    }
  }
};
#endif

class Database {
 private:
  int handle;
  DictStruct<string, DatabaseTableSchema> tables;

 public:
  /**
   * Class constructor.
   */
#ifndef __MQL4__
  Database(string _filename, unsigned int _flags = DATABASE_OPEN_CREATE){
#else
  Database(string _filename, unsigned int _flags = 0) {
#endif
#ifndef __MQL4__
      handle = DatabaseOpen(_filename, _flags);
#else
    handle = -1;
    SetUserError(ERR_USER_NOT_SUPPORTED);
#endif
}

/**
 * Class deconstructor.
 */
~Database() {
#ifndef __MQL4__
  DatabaseClose(handle);
#endif
}

/* Table methods */

/**
 * Checks if table exists.
 */
bool TableExists(string _name) {
#ifndef __MQL4__
  return DatabaseTableExists(handle, _name);
#else
    SetUserError(ERR_USER_NOT_SUPPORTED);
    return false;
#endif
}

/**
 * Creates table if not yet exist.
 */
bool CreateTableIfNotExist(string _name, DatabaseTableSchema &_schema) {
  if (TableExists(_name)) {
    return true;
  }
  return CreateTable(_name, _schema);
}

/**
 * Creates table.
 */
bool CreateTable(string _name, DatabaseTableSchema &_schema) {
  bool _result = false;
#ifndef __MQL4__
  if (DatabaseTableExists(handle, _name)) {
    // Generic error (ERR_DATABASE_ERROR).
    SetUserError(5601);
    return _result;
  }

  string query = "", subquery = "";

  if (_schema.columns.Size() == 0) {
    // SQLite does'nt allow tables without columns;
    subquery = "`dummy` INTEGER";
  } else {
    for (DictStructIterator<short, DatabaseTableColumnEntry> iter = _schema.columns.Begin(); iter.IsValid(); ++iter) {
      subquery +=
          StringFormat("`%s` %s %s,", iter.Value().GetName(), iter.Value().GetDatatype(), iter.Value().GetFlags());
    }
    subquery = StringSubstr(subquery, 0, StringLen(subquery) - 1);  // Removes extra comma.
  }

  query = StringFormat("CREATE TABLE `%s`(%s);", _name, subquery);

#ifdef __debug__
  Print("Database: Executing query:\n", query);
#endif

  if (_result = DatabaseExecute(handle, query)) {
    ResetLastError();
    SetTableSchema(_name, _schema);
  } else {
#ifdef __debug__
    Print("Database: Query failed with error ", _LastError);
    DebugBreak();
#endif
  }
#endif
  return _result;
}

/**
 * Drops table.
 */
bool DropTable(string _name) {
  tables.Unset(_name);
#ifndef __MQL4__
  return DatabaseExecute(handle, "DROP TABLE IF EXISTS `" + _name + "`");
#else
    return false;
#endif
}

/* Import methods */

/**
 * Imports data into table. First row must contain column names. Strings must be enclosed with double quotes.
 */
bool ImportData(const string _name, MiniMatrix2d<string> &data) {
  if (data.SizeY() < 2 || data.SizeX() == 0) {
    // No data to import or there are no columns in input data (Serialize() serialized no fields).
    return true;
  }
  int x;
  bool _result = true;
  DatabaseTableSchema _schema = GetTableSchema(_name);
  string _query = "", _cols = "", _vals = "";
  for (x = 0; x < data.SizeX(); ++x) {
    const string key = data.Get(x, 0);
    _cols += "`" + StringSubstr(key, 1, StringLen(key) - 2) + "`,";
  }
  _cols = StringSubstr(_cols, 0, StringLen(_cols) - 1);  // Removes extra comma.
#ifndef __MQL4__
  if (DatabaseTransactionBegin(handle)) {
    _query = StringFormat("INSERT INTO `%s`(%s) VALUES\n", _name, _cols);
    for (int y = 1; y < data.SizeY(); ++y) {
      _query += "(";
      for (x = 0; x < data.SizeX(); ++x) {
        _query += data.Get(x, y) + (x < data.SizeX() - 1 ? ", " : "");
      }
      _query += ")" + (y < data.SizeY() - 1 ? ",\n" : "");
    }

#ifdef __debug__
    Print("Database: Executing query:\n", _query);
#endif

    _result &= DatabaseExecute(handle, _query);
  }
  if (_result) {
    DatabaseTransactionCommit(handle);
  } else {
    Print("Database: Query failed with error ", _LastError);
    DebugBreak();
    DatabaseTransactionRollback(handle);
  }
#else
    return false;
#endif
  return _result;
}

#ifdef BUFFER_STRUCT_MQH
/**
 * Imports BufferStruct records into a table.
 */
template <typename TStruct>
bool Import(const string _name, BufferStruct<TStruct> &_bstruct) {
  bool _result = true;
  DatabaseTableSchema _schema = GetTableSchema(_name);
  string _query = "", _cols = "", _vals = "";
  for (DictStructIterator<short, DatabaseTableColumnEntry> iter = _schema.columns.Begin(); iter.IsValid(); ++iter) {
    _cols += iter.Value().name + ",";
  }
  _cols = StringSubstr(_cols, 0, StringLen(_cols) - 1);  // Removes extra comma.
#ifndef __MQL4__
  if (DatabaseTransactionBegin(handle)) {
    for (DictStructIterator<long, TStruct> iter = _bstruct.Begin(); iter.IsValid(); ++iter) {
      _query = StringFormat("INSERT INTO %s(%s) VALUES (%s)", _name, _cols, iter.Value().ToCSV());
      _result &= DatabaseExecute(handle, _query);
    }
  }
  if (_result) {
    DatabaseTransactionCommit(handle);
  } else {
    DatabaseTransactionRollback(handle);
  }
#else
  return false;
#endif
  return _result;
}
#endif

/* Getters */

/**
 * Gets database handle.
 */
int GetHandle() { return handle; }

/**
 * Gets table schema.
 */
DatabaseTableSchema GetTableSchema(string _name) { return tables.GetByKey(_name); }

/**
 * Checks if table schema exists.
 */
bool SchemaExists(string _name) { return tables.KeyExists(_name); }

/* Setters */

/**
 * Sets table schema.
 */
bool SetTableSchema(string _name, DatabaseTableSchema &_schema) { return tables.Set(_name, _schema); }
}
;
#endif  // DATABASE_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Database.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerCsv.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: MiniMatrix.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictStruct.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Matrix.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Math.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Data.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Data.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Data's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

#ifndef __MQL__
/**
 * Enumeration for the Data type identifiers.
 *
 * @docs
 * - https://www.mql5.com/en/docs/constants/indicatorconstants/enum_datatype
 */
enum ENUM_DATATYPE {
  TYPE_BOOL,      // bool
  TYPE_CHAR,      // char
  TYPE_COLOR,     // color
  TYPE_DATETIME,  // datetime
  TYPE_DOUBLE,    // double
  TYPE_FLOAT,     // float
  TYPE_INT,       // int
  TYPE_LONG,      // long
  TYPE_SHORT,     // short
  TYPE_STRING,    // string
  TYPE_UCHAR,     // uchar
  TYPE_UINT,      // uint
  TYPE_ULONG,     // ulong
  TYPE_USHORT,    // ushort
};
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Data.enum.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Data's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward class declaration.
class Serializer;
struct MqlParam;
struct MqlRates;

// Includes.





#ifndef __MQL__
/**
 * Struct to provide input parameters.
 *
 * For example input parameters for technical indicators.
 *
 * @see: https://www.mql5.com/en/docs/constants/structures/mqlparam
 */
struct MqlParam {
  ENUM_DATATYPE type;  // Type of the input parameter, value of ENUM_DATATYPE.
  union {
    long integer_value;   // Field to store an integer type.
    double double_value;  // Field to store a double type.
    string string_value;  // Field to store a string type.
  };
  MqlParam() { type = (ENUM_DATATYPE)WRONG_VALUE; }

  MqlParam(const MqlParam &_r) { THIS_REF = _r; }

  MqlParam &operator=(const MqlParam &_r) {
    type = _r.type;
    switch (type) {
      case TYPE_BOOL:
      case TYPE_CHAR:
      case TYPE_INT:
      case TYPE_LONG:
      case TYPE_SHORT:
      case TYPE_UINT:
      case TYPE_ULONG:
      case TYPE_USHORT:
      case TYPE_UCHAR:
      case TYPE_COLOR:
      case TYPE_DATETIME:
        integer_value = _r.integer_value;
        break;
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        double_value = _r.double_value;
        break;
      case TYPE_STRING:
        string_value = _r.string_value;
    }
  }

  MqlParam(long _value) {
    type = ENUM_DATATYPE::TYPE_LONG;
    integer_value = _value;
  }
  MqlParam(int _value) {
    type = ENUM_DATATYPE::TYPE_INT;
    integer_value = _value;
  }
  MqlParam(bool _value) {
    type = ENUM_DATATYPE::TYPE_BOOL;
    integer_value = _value ? 1 : 0;
  }
  MqlParam(float _value) {
    type = ENUM_DATATYPE::TYPE_FLOAT;
    double_value = (double)_value;
  }
  MqlParam(double _value) {
    type = ENUM_DATATYPE::TYPE_DOUBLE;
    double_value = _value;
  }
  ~MqlParam() {}
};
#endif

/**
 * Struct to provide multitype data parameters.
 *
 * For example input parameters for technical indicators.
 *
 * @see: https://www.mql5.com/en/docs/constants/structures/mqlparam
 */
struct DataParamEntry : public MqlParam {
 public:
  DataParamEntry() { type = (ENUM_DATATYPE)WRONG_VALUE; }
  DataParamEntry(ENUM_DATATYPE _type, long _integer_value, double _double_value, string _string_value) {
    type = _type;
    integer_value = _integer_value;
    double_value = _double_value;
    string_value = _string_value;
  }
  DataParamEntry(const DataParamEntry &_r) { ASSIGN_TO_THIS(MqlParam, _r); }
  // Struct operators.
  void operator=(const bool _value) {
    type = TYPE_BOOL;
    integer_value = _value;
  }
  void operator=(const datetime _value) {
    type = TYPE_DATETIME;
    integer_value = _value;
  }
  void operator=(const double _value) {
    type = TYPE_DOUBLE;
    double_value = _value;
  }
  void operator=(const int _value) {
    type = TYPE_INT;
    integer_value = _value;
  }
  void operator=(const string _value) {
    type = TYPE_STRING;
    string_value = _value;
  }
  void operator=(const unsigned int _value) {
    type = TYPE_UINT;
    integer_value = _value;
  }
  template <typename T>
  void operator=(const T _value) {
    type = TYPE_INT;
    integer_value = (int)_value;
  }
  bool operator==(const DataParamEntry &_s) {
    return type == _s.type && double_value == _s.double_value && integer_value == _s.integer_value &&
           string_value == _s.string_value;
  }

  /* Constructors */

  /*
  DataParamEntry() {}
  DataParamEntry(ENUM_DATATYPE _type, long _int, double _dbl, string _str) {
    type = _type;
    integer_value = _int;
    double_value = _dbl;
    string = _str;
  }
  DataParamEntry(ENUM_DATATYPE _type) { type = _type; }
  */

  /* Getters */

  /**
   * Gets a value of the given type.
   *
   */
  template <typename T>
  T ToValue() {
    switch (type) {
      case TYPE_CHAR:
      case TYPE_STRING:
      case TYPE_UCHAR:
        return (T)::StringToDouble(string_value);
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        return (T)ToDouble(this);
      default:
      case TYPE_BOOL:
      case TYPE_INT:
      case TYPE_LONG:
      case TYPE_UINT:
      case TYPE_ULONG:
        return (T)ToInteger(this);
    }
  }

  /* Static methods */

  /**
   * Gets DataParamEntry struct based on the value of double type.
   *
   */
  static DataParamEntry FromValue(double _value) {
    DataParamEntry _dpe;
    _dpe.type = TYPE_DOUBLE;
    _dpe.double_value = _value;
    return _dpe;
  }

  /**
   * Gets DataParamEntry struct based on the value of float type.
   *
   */
  static DataParamEntry FromValue(float _value) {
    DataParamEntry _dpe;
    _dpe.type = TYPE_FLOAT;
    _dpe.double_value = _value;
    return _dpe;
  }

  /**
   * Gets DataParamEntry struct based on the value of integer type.
   *
   */
  static DataParamEntry FromValue(int _value) {
    DataParamEntry _dpe;
    _dpe.type = TYPE_INT;
    _dpe.integer_value = _value;
    return _dpe;
  }

  /**
   * Gets DataParamEntry struct based on the value of long type.
   *
   */
  static DataParamEntry FromValue(long _value) {
    DataParamEntry _dpe;
    _dpe.type = TYPE_LONG;
    _dpe.integer_value = _value;
    return _dpe;
  }

  /**
   * Gets DataParamEntry struct based on the value of unknown type.
   *
   * Warning: You'll get an infinite loop, if the typename is unknown.
   *
   */
  template <typename T>
  static DataParamEntry FromValue(T _value) {
    DataParamEntry _dpe = FromValue((T)_value);
    return _dpe;
  }

  /**
   * Converts MqlParam struct to double.
   *
   */
  static double ToDouble(MqlParam &param) {
    switch (param.type) {
      case TYPE_BOOL:
        return param.integer_value ? 1 : 0;
      case TYPE_INT:
      case TYPE_LONG:
      case TYPE_UINT:
      case TYPE_ULONG:
        return (double)param.integer_value;
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        return param.double_value;
      case TYPE_CHAR:
      case TYPE_STRING:
      case TYPE_UCHAR:
        return ::StringToDouble(param.string_value);
    }
    return DBL_MIN;
  }

  /**
   * Converts MqlParam struct to integer.
   *
   */
  static long ToInteger(MqlParam &param) {
    switch (param.type) {
      case TYPE_BOOL:
        return param.integer_value ? 1 : 0;
      case TYPE_DATETIME:
      case TYPE_INT:
      case TYPE_LONG:
      case TYPE_UINT:
      case TYPE_ULONG:
      case TYPE_SHORT:
        return param.integer_value;
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        return (int)param.double_value;
      case TYPE_CHAR:
      case TYPE_COLOR:
      case TYPE_STRING:
      case TYPE_UCHAR:
        return ::StringToInteger(param.string_value);
    }
    return INT_MIN;
  }

  /* Serializers */

  /**
   * Initializes object with given number of elements. Could be skipped for non-containers.
   */
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
    type = TYPE_INT;
    integer_value = 0;
  }
  SerializerNodeType Serialize(Serializer &s);
};



/* Method to serialize DataParamEntry struct. */
SerializerNodeType DataParamEntry::Serialize(Serializer &s) {
  s.PassEnum(THIS_REF, "type", type, SERIALIZER_FIELD_FLAG_HIDDEN);
  string aux_string;

  switch (type) {
    case TYPE_BOOL:
    case TYPE_UCHAR:
    case TYPE_CHAR:
    case TYPE_USHORT:
    case TYPE_SHORT:
    case TYPE_UINT:
    case TYPE_INT:
    case TYPE_ULONG:
    case TYPE_LONG:
      s.Pass(THIS_REF, "value", integer_value);
      break;

    case TYPE_DOUBLE:
      s.Pass(THIS_REF, "value", double_value);
      break;

    case TYPE_STRING:
      s.Pass(THIS_REF, "value", string_value);
      break;

    case TYPE_DATETIME:
      if (s.IsWriting()) {
        aux_string = TimeToString(integer_value);
        s.Pass(THIS_REF, "value", aux_string);
      } else {
        s.Pass(THIS_REF, "value", aux_string);
        integer_value = StringToTime(aux_string);
      }
      break;

    default:
      // Unknown type. Serializing anyway.
      s.Pass(THIS_REF, "value", aux_string);
  }
  return SerializerNodeObject;
}

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Data.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Math.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Includes Math's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Prevents processing this includes file for the second time.
#ifndef MATH_ENUM_H
#define MATH_ENUM_H

/* Enumeration for Math comparison operators. */
enum ENUM_MATH_CONDITION {
  MATH_COND_EQ = 1,  // Argument values are equal.
  MATH_COND_GT = 2,  // First value is greater than second.
  MATH_COND_LE = 3,  // First value is lesser than second.
  FINAL_MATH_ENTRY = 4
};

/* Enumeration for Math operations. */
enum ENUM_MATH_OP {
  MATH_OP_ADD,
  MATH_OP_SUB,
  MATH_OP_MUL,
  MATH_OP_DIV,
  MATH_OP_SIN,
  MATH_OP_COS,
  MATH_OP_TAN,
  MATH_OP_MIN,
  MATH_OP_MAX,
  MATH_OP_AVG,
  MATH_OP_RELU,
  MATH_OP_ABS,
  MATH_OP_ABS_DIFF
};

#endif  // MATH_ENUM_H

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Math.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Math.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Includes Math's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif



// Prevents processing this includes file for the second time.
#ifndef MATH_STRUCT_H
#define MATH_STRUCT_H

struct MathEquation {
  // STRUCT_MATH_CONDITION op;
  MqlParam args[2];
};

#endif  // MATH_STRUCT_H

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Math.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Math.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Defines macros.
#define fmax2(_v1, _v2) fmax(_v1, _v2)
#define fmax3(_v1, _v2, _v3) fmax(fmax(_v1, _v2), _v3)
#define fmax4(_v1, _v2, _v3, _v4) fmax(fmax(fmax(_v1, _v2), _v3), _v4)
#define fmax5(_v1, _v2, _v3, _v4, _v5) fmax(fmax(fmax(fmax(_v1, _v2), _v3), _v4), _v5)
#define fmax6(_v1, _v2, _v3, _v4, _v5, _v6) fmax(fmax(fmax(fmax(fmax(_v1, _v2), _v3), _v4), _v5), _v6)
#define fmin2(_v1, _v2) fmin(_v1, _v2)
#define fmin3(_v1, _v2, _v3) fmin(fmin(_v1, _v2), _v3)
#define fmin4(_v1, _v2, _v3, _v4) fmin(fmin(fmin(_v1, _v2), _v3), _v4)
#define fmin5(_v1, _v2, _v3, _v4, _v5) fmin(fmin(fmin(fmin(_v1, _v2), _v3), _v4), _v5)
#define fmin6(_v1, _v2, _v3, _v4, _v5, _v6) fmin(fmin(fmin(fmin(fmin(_v1, _v2), _v3), _v4), _v5), _v6)

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Math.define.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indicator.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indicator.enum.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indicator.define.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Indicator's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.


/* Indicator actions. */
enum ENUM_INDICATOR_ACTION {
  INDI_ACTION_CLEAR_CACHE,  // Clear cache.
  INDI_ACTION_SET_VALUE,    // Sets buffers' values (from second argument to the last one).
  FINAL_INDICATOR_ACTION_ENTRY
};

/* Define type of indicators. */
enum ENUM_INDICATOR_TYPE {
  INDI_NONE = 0,             // (None)
  INDI_AC,                   // Accelerator Oscillator
  INDI_AD,                   // Accumulation/Distribution
  INDI_ADX,                  // Average Directional Index
  INDI_ADXW,                 // ADX by Welles Wilder
  INDI_ALLIGATOR,            // Alligator
  INDI_AMA,                  // Adaptive Moving Average
  INDI_APPLIED_PRICE,        // Applied Price over OHLC Indicator
  INDI_AO,                   // Awesome Oscillator
  INDI_ASI,                  // Accumulation Swing Index
  INDI_ATR,                  // Average True Range
  INDI_BANDS,                // Bollinger Bands
  INDI_BANDS_ON_PRICE,       // Bollinger Bands (on Price)
  INDI_BEARS,                // Bears Power
  INDI_BULLS,                // Bulls Power
  INDI_BWMFI,                // Market Facilitation Index
  INDI_BWZT,                 // Bill Williams' Zone Trade
  INDI_CANDLE,               // Candle Pattern Detector
  INDI_CCI,                  // Commodity Channel Index
  INDI_CCI_ON_PRICE,         // Commodity Channel Index (CCI) (on Price)
  INDI_CHAIKIN,              // Chaikin Oscillator
  INDI_CHAIKIN_V,            // Chaikin Volatility
  INDI_COLOR_BARS,           // Color Bars
  INDI_COLOR_CANDLES_DAILY,  // Color Candles Daily
  INDI_COLOR_LINE,           // Color Line
  INDI_CUSTOM,               // Custom indicator
  INDI_CUSTOM_MOVING_AVG,    // Custom Moving Average
  INDI_DEMA,                 // Double Exponential Moving Average
  INDI_DEMARKER,             // DeMarker
  INDI_DEMO,                 // Demo/Dummy Indicator
  INDI_DETRENDED_PRICE,      // Detrended Price Oscillator
  INDI_DRAWER,               // Drawer (Socket-based) Indicator
  INDI_ENVELOPES,            // Envelopes
  INDI_ENVELOPES_ON_PRICE,   // Evelopes (on Price)
  INDI_FORCE,                // Force Index
  INDI_FRACTALS,             // Fractals
  INDI_FRAMA,                // Fractal Adaptive Moving Average
  INDI_GATOR,                // Gator Oscillator
  INDI_HEIKENASHI,           // Heiken Ashi
  INDI_ICHIMOKU,             // Ichimoku Kinko Hyo
  INDI_KILLZONES,            // Killzones
  INDI_MA,                   // Moving Average
  INDI_MACD,                 // MACD
  INDI_MA_ON_PRICE,          // Moving Average (on Price).
  INDI_MARKET_FI,            // Market Facilitation Index
  INDI_MASS_INDEX,           // Mass Index
  INDI_MFI,                  // Money Flow Index
  INDI_MOMENTUM,             // Momentum
  INDI_MOMENTUM_ON_PRICE,    // Momentum (on Price)
  INDI_OBV,                  // On Balance Volume
  INDI_OHLC,                 // OHLC (Open-High-Low-Close)
  INDI_OSMA,                 // OsMA
  INDI_PATTERN,              // Pattern Detector
  INDI_PIVOT,                // Pivot Detector
  INDI_PRICE,                // Price
  INDI_PRICE_CHANNEL,        // Price Channel
  INDI_PRICE_FEEDER,         // Indicator which returns prices from custom array
  INDI_PRICE_VOLUME_TREND,   // Price and Volume Trend
  INDI_RATE_OF_CHANGE,       // Rate of Change
  INDI_RS,                   // Indi_Math-based RSI indicator.
  INDI_RSI,                  // Relative Strength Index
  INDI_RSI_ON_PRICE,         // Relative Strength Index (RSI) (on Price)
  INDI_RVI,                  // Relative Vigor Index
  INDI_SAR,                  // Parabolic SAR
  INDI_SPECIAL_MATH,         // Math operations over given indicator.
  INDI_STDDEV,               // Standard Deviation
  INDI_STDDEV_ON_MA_SMA,     // Standard Deviation on Moving Average in SMA mode
  INDI_STDDEV_ON_PRICE,      // Standard Deviation (on Price)
  INDI_STDDEV_SMA_ON_PRICE,  // Standard Deviation in SMA mode (on Price)
  INDI_STOCHASTIC,           // Stochastic Oscillator
  INDI_SVE_BB,               // SVE Bollinger Bands
  INDI_TEMA,                 // Triple Exponential Moving Average
  INDI_TICK,                 // Tick
  INDI_TMA_TRUE,             // Triangular Moving Average True
  INDI_TRIX,                 // Triple Exponential Moving Averages Oscillator
  INDI_ULTIMATE_OSCILLATOR,  // Ultimate Oscillator
  INDI_VIDYA,                // Variable Index Dynamic Average
  INDI_VOLUMES,              // Volumes
  INDI_VROC,                 // Volume Rate of Change
  INDI_WILLIAMS_AD,          // Larry Williams' Accumulation/Distribution
  INDI_WPR,                  // Williams' Percent Range
  INDI_ZIGZAG,               // ZigZag
  INDI_ZIGZAG_COLOR,         // ZigZag Color
  FINAL_INDICATOR_TYPE_ENTRY
};

/* Defines type of source data for indicator. */
enum ENUM_IDATA_SOURCE_TYPE {
  IDATA_BUILTIN = 0,     // Platform built-in
  IDATA_CHART,           // Chart calculation
  IDATA_ICUSTOM,         // iCustom: Custom indicator file
  IDATA_ICUSTOM_LEGACY,  // iCustom: Custom, legacy, provided by MT indicator file
  IDATA_INDICATOR,       // OnIndicator: Another indicator as a source of data
  IDATA_ONCALCULATE,     // OnCalculate: Custom calculation function
  IDATA_MATH             // Math-based indicator
};

/* Defines range value data type for indicator storage. */
enum ENUM_IDATA_VALUE_RANGE {
  IDATA_RANGE_ARROW,    // Value is non-zero on signal.
  IDATA_RANGE_BINARY,   // E.g. 0 or 1.
  IDATA_RANGE_BITWISE,  // Bitwise
  IDATA_RANGE_MIXED,
  IDATA_RANGE_PRICE,  // Values represent price.
  IDATA_RANGE_RANGE,  // E.g. 0 to 100.
  IDATA_RANGE_UNKNOWN
};

// Indicator line identifiers used in ADX and ADXW indicators.
enum ENUM_INDI_ADX_LINE {
#ifdef __MQL4__
  LINE_MAIN_ADX = MODE_MAIN,    // Base indicator line.
  LINE_PLUSDI = MODE_PLUSDI,    // +DI indicator line.
  LINE_MINUSDI = MODE_MINUSDI,  // -DI indicator line.
#else
  LINE_MAIN_ADX = MAIN_LINE,    // Base indicator line.
  LINE_PLUSDI = PLUSDI_LINE,    // +DI indicator line.
  LINE_MINUSDI = MINUSDI_LINE,  // -DI indicator line.
#endif
  FINAL_INDI_ADX_LINE_ENTRY,
};

/* Define indicator index. */
enum ENUM_INDICATOR_INDEX {
  CURR = 0,
  PREV = 1,
  PPREV = 2,
  FINAL_ENUM_INDICATOR_INDEX = 3  // Should be the last one. Used to calculate the number of enum items.
};

/* Indicator line identifiers used in Envelopes and Fractals indicators. */
enum ENUM_LO_UP_LINE {
#ifdef __MQL4__
  LINE_UPPER = MODE_UPPER,  // Upper line.
  LINE_LOWER = MODE_LOWER,  // Bottom line.
#else
  LINE_UPPER = UPPER_LINE,      // Upper line.
  LINE_LOWER = LOWER_LINE,      // Bottom line.
#endif
  FINAL_LO_UP_LINE_ENTRY,
};

/**
 * Indicator line identifiers used in MACD, RVI and Stochastic indicators.
 *
 * @see:
 * - https://docs.mql4.com/constants/indicatorconstants/lines
 * - https://www.mql5.com/en/docs/constants/indicatorconstants/lines
 */
enum ENUM_SIGNAL_LINE {
#ifdef __MQL4__
  LINE_MAIN = MODE_MAIN,      // Main line.
  LINE_SIGNAL = MODE_SIGNAL,  // Signal line.
#else
  LINE_MAIN = MAIN_LINE,        // Main line.
  LINE_SIGNAL = SIGNAL_LINE,    // Signal line.
#endif
  FINAL_SIGNAL_LINE_ENTRY,
};

#ifdef __MQL4__
/**
 * The volume type is used in calculations.
 *
 * Notes:
 * - For MT4, we define it for backward compatibility.
 *
 * @see:
 * - https://www.mql5.com/en/docs/constants/indicatorconstants/prices#enum_applied_price_enum
 */
enum ENUM_APPLIED_VOLUME { VOLUME_TICK = 0, VOLUME_REAL = 1 };
#endif

/* Indicator entry flags. */
enum INDICATOR_ENTRY_FLAGS {
  INDI_ENTRY_FLAG_NONE = 0 << 0,
  INDI_ENTRY_FLAG_IS_BITWISE = 1 << 0,
  INDI_ENTRY_FLAG_IS_DOUBLED = 1 << 1,  // Type is doubled in size (e.g. double or long).
  INDI_ENTRY_FLAG_IS_EXPIRED = 1 << 2,
  INDI_ENTRY_FLAG_IS_REAL = 1 << 3,  // Type is real (float or double).
  INDI_ENTRY_FLAG_IS_PRICE = 1 << 4,
  INDI_ENTRY_FLAG_IS_UNSIGNED = 1 << 5,  // Type is unsigned (uint or ulong).
  INDI_ENTRY_FLAG_IS_VALID = 1 << 6,
  INDI_ENTRY_FLAG_INSUFFICIENT_DATA = 1 << 7,  // Entry has missing value for that shift and probably won't ever have.
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indicator.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DateTime.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DateTime.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes DateTime's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Defines datetime conditions. */
enum ENUM_DATETIME_CONDITION {
  DATETIME_COND_IS_PEAK_HOUR = 1,  // On peak hour
  DATETIME_COND_NEW_HOUR,          // On new hour
  DATETIME_COND_NEW_DAY,           // On new day
  DATETIME_COND_NEW_WEEK,          // On new week
  DATETIME_COND_NEW_MONTH,         // On new month
  DATETIME_COND_NEW_YEAR,          // On new year
  FINAL_ENUM_DATETIME_CONDITION_ENTRY
};

/* Defines datetime units. */
enum ENUM_DATETIME_UNIT {
  DATETIME_NONE = 0 << 0,    // None
  DATETIME_SECOND = 1 << 0,  // Second
  DATETIME_MINUTE = 1 << 1,  // Minute
  DATETIME_HOUR = 1 << 2,    // Hour
  DATETIME_DAY = 1 << 3,     // Day
  DATETIME_WEEK = 1 << 4,    // Week
  DATETIME_MONTH = 1 << 5,   // Month
  DATETIME_YEAR = 1 << 6,    // Year
  DATETIME_HMS = DATETIME_HOUR | DATETIME_MINUTE | DATETIME_SECOND,
  DATETIME_YMD = DATETIME_YEAR | DATETIME_MONTH | DATETIME_DAY,
  DATETIME_ALL = DATETIME_HMS | DATETIME_WEEK | DATETIME_YMD,
};

#ifndef __MQL__
enum ENUM_TIME {
  TIME_NONE = 0 << 0,     // None.
  TIME_DATE = 1 << 0,     // Formats date as yyyy.mm.dd.
  TIME_MINUTES = 1 << 1,  // Formats date as hh:mi.
  TIME_SECONDS = 1 << 2,  // Formats date as hh:mi:ss.
};
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DateTime.enum.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes DateTime's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward declarations.
struct DateTimeStatic;

// Includes.



#ifndef __MQLBUILD__
/**
 * The date type structure.
 *
 * @see:
 * - https://docs.mql4.com/constants/structures/mqldatetime
 * - https://www.mql5.com/en/docs/constants/structures/mqldatetime
 */
struct MqlDateTime {
  int year;         // Year.
  int mon;          // Month.
  int day;          // Day of month.
  int hour;         // Hour.
  int min;          // Minute.
  int sec;          // Second.
  int day_of_week;  // Zero-based day number of week (0-Sunday, 1-Monday, ... ,6-Saturday).
  int day_of_year;  // Zero-based day number of the year (1st Jan = 0).
};
#endif

/*
 * Struct to provide static date and time methods.
 */
struct DateTimeStatic {
  /**
   * Returns the current day of the month (e.g. the day of month of the last known server time).
   */
  static int Day(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::TimeDay(dt);
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.day;
#endif
  }

  /**
   * Returns the current zero-based day of the week of the last known server time.
   */
  static int DayOfWeek(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::DayOfWeek();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.day_of_week;
#endif
  }

  /**
   * Returns the current day of the year (e.g. the day of year of the last known server time).
   */
  static int DayOfYear(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::DayOfYear();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.day_of_year + 1;
#endif
  }

  /**
   * Returns the hour of the last known server time by the moment of the program start.
   */
  static int Hour(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::Hour();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.hour;
#endif
  }

  /**
   * Check whether market is within peak hours.
   */
  static bool IsPeakHour() {
    MqlDateTime dt;
    TimeToStruct(::TimeGMT(), dt);
    return dt.hour >= 8 && dt.hour <= 16;
  }

  /**
   * Returns the current minute of the last known server time by the moment of the program start.
   */
  static int Minute(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::Minute();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.min;
#endif
  }

  /**
   * Returns the current month as number (e.g. the number of month of the last known server time).
   */
  static int Month(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::Month();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.mon;
#endif
  }

  /**
   * Returns the amount of seconds elapsed from the beginning of the current minute of the last known server time.
   */
  static int Seconds(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::Seconds();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.sec;
#endif
  }

  /**
   * Converts a time stamp into a string of "yyyy.mm.dd hh:mi" format.
   */
  static string TimeToStr(datetime value, int mode = TIME_DATE | TIME_MINUTES | TIME_SECONDS) {
#ifdef __MQL4__
    return ::TimeToStr(value, mode);
#else  // __MQL5__
    // #define TimeToStr(value, mode) DateTime::TimeToStr(value, mode)
    return ::TimeToString(value, mode);
#endif
  }
  static string TimeToStr(int mode = TIME_DATE | TIME_MINUTES | TIME_SECONDS) { return TimeToStr(TimeCurrent(), mode); }

  /**
   * Returns the current time of the trade server.
   */
  static datetime TimeTradeServer() {
#ifdef __MQL4__
    // Unlike MQL5 TimeTradeServer(),
    // TimeCurrent() returns the last known server time.
    return ::TimeCurrent();
#else
    // The calculation of the time value is performed in the client terminal
    // and depends on the time settings of your computer.
    return ::TimeTradeServer();
#endif
  }

  /**
   * Returns the current year (e.g. the year of the last known server time).
   */
  static int Year(datetime dt = NULL) {
    if (dt == 0) {
      dt = TimeCurrent();
    }
#ifdef __MQL4__
    return ::Year();
#else
    MqlDateTime _dt;
    TimeToStruct(dt, _dt);
    return _dt.year;
#endif
  }
};

struct DateTimeEntry : MqlDateTime {
  int week_of_year;
  // Struct constructors.
  DateTimeEntry() { Set(); }
  DateTimeEntry(datetime _dt) { Set(_dt); }
  DateTimeEntry(MqlDateTime& _dt) {
    Set(_dt);
#ifndef __MQL__
    throw NotImplementedException();
#endif
  }
  // Getters.
  int GetDayOfMonth() { return day; }
  int GetDayOfWeek() {
    // Returns the zero-based day of week.
    // (0-Sunday, 1-Monday, ... , 6-Saturday).
    return day_of_week;
  }
  int GetDayOfYear() { return day_of_year + 1; }  // Zero-based day of year (1st Jan = 0).
  int GetHour() { return hour; }
  int GetMinute() { return min; }
  int GetMonth() { return mon; }
  int GetSeconds() { return sec; }
  // int GetWeekOfYear() { return week_of_year; } // @todo
  int GetValue(ENUM_DATETIME_UNIT _unit) {
    int _result = -1;
    switch (_unit) {
      case DATETIME_SECOND:
        return GetSeconds();
      case DATETIME_MINUTE:
        return GetMinute();
      case DATETIME_HOUR:
        return GetHour();
      case DATETIME_DAY:
        return GetDayOfMonth();
      case DATETIME_WEEK:
        return -1;  // return WeekOfYear(); // @todo
      case DATETIME_MONTH:
        return GetMonth();
      case DATETIME_YEAR:
        return GetYear();
      default:
        break;
    }
    return _result;
  }
  unsigned int GetValue(unsigned int _unit) {
    if ((_unit & (DATETIME_DAY | DATETIME_WEEK)) != 0) {
      return GetDayOfWeek();
    } else if ((_unit & (DATETIME_DAY | DATETIME_MONTH)) != 0) {
      return GetDayOfMonth();
    } else if ((_unit & (DATETIME_DAY | DATETIME_YEAR)) != 0) {
      return GetDayOfYear();
    }
    return GetValue((ENUM_DATETIME_UNIT)_unit);
  }
  int GetYear() { return year; }
  datetime GetTimestamp() { return StructToTime(THIS_REF); }
  // Setters.
  void Set() {
    TimeToStruct(::TimeCurrent(), THIS_REF);
    // @fixit Should also set day of week.
  }
  void SetGMT() {
    TimeToStruct(::TimeGMT(), THIS_REF);
    // @fixit Should also set day of week.
  }
  // Set date and time.
  void Set(datetime _time) {
    TimeToStruct(_time, THIS_REF);
    // @fixit Should also set day of week.
  }
  // Set date and time.
  void Set(MqlDateTime& _time) {
    THIS_REF = _time;
    // @fixit Should also set day of week.
  }
  void SetDayOfMonth(int _value) {
    day = _value;
    day_of_week = DateTimeStatic::DayOfWeek();  // Zero-based day of week.
    day_of_year = DateTimeStatic::DayOfYear();  // Zero-based day of year.
  }
  void SetDayOfYear(int _value) {
    day_of_year = _value - 1;                   // Sets zero-based day of year.
    day = DateTimeStatic::Month();              // Sets day of month (1..31).
    day_of_week = DateTimeStatic::DayOfWeek();  // Zero-based day of week.
  }
  void SetHour(int _value) { hour = _value; }
  void SetMinute(int _value) { min = _value; }
  void SetMonth(int _value) { mon = _value; }
  void SetSeconds(int _value) { sec = _value; }
  void SetWeekOfYear(int _value) {
    week_of_year = _value;
    // day = @todo;
    // day_of_week = @todo;
    // day_of_year = @todo;
  }
  void SetValue(ENUM_DATETIME_UNIT _unit, int _value) {
    switch (_unit) {
      case DATETIME_SECOND:
        SetSeconds(_value);
        break;
      case DATETIME_MINUTE:
        SetMinute(_value);
        break;
      case DATETIME_HOUR:
        SetHour(_value);
        break;
      case DATETIME_DAY:
        SetDayOfMonth(_value);
        break;
      case DATETIME_WEEK:
        SetWeekOfYear(_value);
        break;
      case DATETIME_MONTH:
        SetMonth(_value);
        break;
      case DATETIME_YEAR:
        SetYear(_value);
        break;
      default:
        break;
    }
  }
  void SetValue(unsigned short _unit, int _value) {
    if ((_unit & (DATETIME_DAY | DATETIME_MONTH)) != 0) {
      SetDayOfMonth(_value);
    } else if ((_unit & (DATETIME_DAY | DATETIME_YEAR)) != 0) {
      SetDayOfYear(_value);
    } else {
      SetValue((ENUM_DATETIME_UNIT)_unit, _value);
    }
  }
  void SetYear(int _value) { year = _value; }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DateTime.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: ValueStorage.indicator.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: ValueStorage.history.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: IValueStorage.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Value storage interface.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

class IValueStorage {
 public:
  /**
   * Destructor.
   */
  virtual ~IValueStorage() {}

  /**
   * Returns number of values available to fetch (size of the values buffer).
   */
  virtual int Size() const {
    Alert(__FUNCSIG__, " does not implement Size()!");
    DebugBreak();
    return 0;
  }

  /**
   * Resizes storage to given size.
   */
  virtual void Resize(int _size, int _reserve) {
    Alert(__FUNCSIG__, " does not implement Resize()!");
    DebugBreak();
  }

  /**
   * Checks whether storage operates in as-series mode.
   */
  virtual bool IsSeries() const {
    Alert(__FUNCSIG__, " does not implement IsSeries()!");
    DebugBreak();
    return false;
  }

  /**
   * Sets storage's as-series mode on or off.
   */
  virtual bool SetSeries(bool _value) {
    Alert(__FUNCSIG__, " does not implement SetSeries()!");
    DebugBreak();
    return false;
  }
};

/**
 * ValueStorage-compatible wrapper for ArrayGetAsSeries.
 */
bool ArrayGetAsSeries(const IValueStorage& _storage) { return _storage.IsSeries(); }

/**
 * ValueStorage-compatible wrapper for ArraySetAsSeries.
 */
bool ArraySetAsSeries(IValueStorage& _storage, bool _value) { return _storage.SetSeries(_value); }

/**
 * ValueStorage-compatible wrapper for ArrayResize.
 */
int ArrayResize(IValueStorage& _storage, int _size, int _reserve = 100) {
  _storage.Resize(_size, _reserve);
  return _size;
}

/**
 * ValueStorage-compatible wrapper for ArraySize.
 */
int ArraySize(const IValueStorage& _storage) { return _storage.Size(); }

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: IValueStorage.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Indicator's mode buffer version of ValueStorage.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.


// Forward declarations.
template <typename C>
class ValueStorage;

/**
 * Storage for direct access to indicator's buffer for a given mode.
 */
template <typename C>
class HistoryValueStorage : public ValueStorage<C> {
 protected:
  // Symbol to fetch history for.
  string symbol;

  // Time-frame to fetch history for.
  ENUM_TIMEFRAMES tf;

  // Time of the first bar possible to fetch.
  datetime start_bar_time;

  // Whether storage operates in as-series mode.
  bool is_series;

 public:
  /**
   * Constructor.
   */
  HistoryValueStorage(string _symbol, ENUM_TIMEFRAMES _tf, bool _is_series = false)
      : symbol(_symbol), tf(_tf), is_series(_is_series) {
    start_bar_time = ChartStatic::iTime(_symbol, _tf, BarsFromStart() - 1);
  }

  /**
   * Initializes storage with given value.
   */
  virtual void Initialize(C _value) {
    Print("HistoryValueStorage does not implement Initialize()!");
    DebugBreak();
  }

  /**
   * Calculates shift from the given value index.
   */
  int RealShift(int _shift) {
    if (is_series) {
      return _shift;
    } else {
      return BarsFromStart() - _shift - 1;
    }
  }

  /**
   * Number of bars passed from the start. There will be a single bar at the start.
   */
  int BarsFromStart() const { return Bars(symbol, tf); }

  /**
   * Returns number of values available to fetch (size of the values buffer).
   */
  virtual int Size() const { return BarsFromStart(); }

  /**
   * Resizes storage to given size.
   */
  virtual void Resize(int _size, int _reserve) {
    Print("HistoryValueStorage does not implement Resize()!");
    DebugBreak();
  }

  /**
   * Checks whether storage operates in as-series mode.
   */
  virtual bool IsSeries() const { return is_series; }

  /**
   * Sets storage's as-series mode on or off.
   */
  virtual bool SetSeries(bool _value) {
    is_series = _value;
    return true;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: ValueStorage.history.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Indicator's mode buffer version of ValueStorage.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward declarations.
class IndicatorBase;

// Includes.


/**
 * Storage for direct access to indicator's buffer for a given mode.
 */
template <typename C>
class IndicatorBufferValueStorage : public HistoryValueStorage<C> {
  // Pointer to indicator to access data from.
  IndicatorBase *indicator;

  // Mode of the target indicator.
  int mode;

 public:
  /**
   * Constructor.
   */
  IndicatorBufferValueStorage(IndicatorBase *_indi, int _mode = 0, bool _is_series = false)
      : indicator(_indi), mode(_mode), HistoryValueStorage(_indi.GetSymbol(), _indi.GetTf()) {}

  /**
   * Fetches value from a given shift. Takes into consideration as-series flag.
   */
  virtual C Fetch(int _shift) { return indicator.GetValue<C>(RealShift(_shift), mode); }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: ValueStorage.indicator.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indicator.struct.cache.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: ValueStorage.h
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Util.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: IValueStorage.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Array.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Objects.h
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../DictStruct.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Refs.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Objects cache per key.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.



/**
 * Stores objects to be reused using a string-based key.
 */
template <typename C>
class Objects {
  // Dictionary of key => reference to object.
  static DictStruct<string, Ref<C>>* GetObjects() {
    static DictStruct<string, Ref<C>> objects;
    return &objects;
  }

 public:
  /**
   * Tries to retrieve pointer to object for a given key. Returns true if object did exist.
   */
  static bool TryGet(string& key, C*& out_ptr) {
    int position;
    if (!GetObjects().KeyExists(key, position)) {
      out_ptr = NULL;
      return false;
    } else {
      out_ptr = GetObjects().GetByPos(position).Ptr();
      return true;
    }
  }

  /**
   * Stores object pointer with a given key.
   */
  static C* Set(string& key, C* ptr) {
    Ref<C> _ref(ptr);
    GetObjects().Set(key, _ref);
    return ptr;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Objects.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: ValueStorage.accessor.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * ValueStorage value accessor.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward declarations.
template <typename C>
class ValueStorage;

template <typename C>
class ValueStorageAccessor {
  // Target storage to access data from.
  ValueStorage<C>* storage;

  // Index of storage value to store/fetch.
  int index;

 public:
  /**
   * Constructor.
   */
  ValueStorageAccessor(const ValueStorageAccessor<C>& _r) : storage(_r.storage), index(_r.index) {}

  /**
   * Constructor.
   */
  ValueStorageAccessor(ValueStorage<C>* _storage, int _index) : storage(_storage), index(_index) {}

  /**
   * Constructor.
   */
  ValueStorageAccessor(C _value) { THIS_REF = _value; }

  /**
   * Assignment operator.
   */
  void operator=(C _value) { Set(_value); }

  /**
   * Assignment operator.
   */
  void operator=(const ValueStorageAccessor& _accessor) { Set(_accessor.Get()); }

  /**
   * Fetches value from the storage.
   */
  const C Get() const { return storage.Fetch(index); }

  /**
   * Stores value in the storage.
   */
  void Set(C value) { storage.Store(index, value); }

#define VALUE_STORAGE_ACCESSOR_OP(TYPE, OP)                                                          \
  TYPE operator OP(const ValueStorageAccessor& _accessor) const { return Get() OP _accessor.Get(); } \
  TYPE operator OP(C _value) const { return Get() OP _value; }

  /**
   * Operators.
   */
  VALUE_STORAGE_ACCESSOR_OP(C, +)
  VALUE_STORAGE_ACCESSOR_OP(C, -)
  VALUE_STORAGE_ACCESSOR_OP(C, *)
  VALUE_STORAGE_ACCESSOR_OP(C, /)
  VALUE_STORAGE_ACCESSOR_OP(bool, ==)
  VALUE_STORAGE_ACCESSOR_OP(bool, !=)
  VALUE_STORAGE_ACCESSOR_OP(bool, >)
  VALUE_STORAGE_ACCESSOR_OP(bool, >=)
  VALUE_STORAGE_ACCESSOR_OP(bool, <)
  VALUE_STORAGE_ACCESSOR_OP(bool, <=)

#undef VALUE_STORAGE_ACCESSOR_OP_A_V

#define VALUE_STORAGE_ACCESSOR_INP_OP(OP, OP2)                                                \
  void operator OP(const ValueStorageAccessor& _accessor) { Set(Get() OP2 _accessor.Get()); } \
  void operator OP(C _value) { Set(Get() OP2 _value); }

  /**
   * In-place operators.
   */
  VALUE_STORAGE_ACCESSOR_INP_OP(+=, +)
  VALUE_STORAGE_ACCESSOR_INP_OP(-=, -)
  VALUE_STORAGE_ACCESSOR_INP_OP(*=, *)
  VALUE_STORAGE_ACCESSOR_INP_OP(/=, /)

#undef VALUE_STORAGE_ACCESSOR_INP_OP
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: ValueStorage.accessor.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Stores values fetchable and storeable in native arrays or custom data storages.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Prevents processing this includes file multiple times.
#ifndef VALUE_STORAGE_H
#define VALUE_STORAGE_H

// Includes.


// Enumeration for iPeak().
enum ENUM_IPEAK { IPEAK_LOWEST, IPEAK_HIGHEST };

// Defines.
#define INDICATOR_BUFFER_VALUE_STORAGE_HISTORY \
  300  // Number of entries the value storage buffer will be initialized with.

#define INDICATOR_CALCULATE_PARAMS_LONG                                                                                \
  ValueStorage<datetime> &_time, ValueStorage<double> &_open, ValueStorage<double> &_high, ValueStorage<double> &_low, \
      ValueStorage<double> &_close, ValueStorage<long> &_tick_volume, ValueStorage<long> &_volume,                     \
      ValueStorage<long> &_spread

#define INDICATOR_CALCULATE_PARAMS_SHORT ValueStorage<double> &_price

#define INDICATOR_CALCULATE_METHOD_PARAMS_LONG                                                                \
  const int rates_total, const int prev_calculated, ValueStorage<datetime> &time, ValueStorage<double> &open, \
      ValueStorage<double> &high, ValueStorage<double> &low, ValueStorage<double> &close,                     \
      ValueStorage<long> &tick_volume, ValueStorage<long> &volume, ValueStorage<long> &spread

#define INDICATOR_CALCULATE_METHOD_PARAMS_SHORT \
  const int rates_total, const int prev_calculated, const int begin, ValueStorage<double> &price

#define INDICATOR_CALCULATE_GET_PARAMS_LONG                                                                    \
  _cache.GetTotal(), _cache.GetPrevCalculated(), _time, _cache.GetPriceBuffer(PRICE_OPEN),                     \
      _cache.GetPriceBuffer(PRICE_HIGH), _cache.GetPriceBuffer(PRICE_LOW), _cache.GetPriceBuffer(PRICE_CLOSE), \
      _tick_volume, _volume, _spread

#define INDICATOR_CALCULATE_GET_PARAMS_SHORT _cache.GetTotal(), _cache.GetPrevCalculated(), 0, _cache.GetPriceBuffer()

#define INDICATOR_CALCULATE_POPULATE_CACHE(SYMBOL, TF, KEY)                                              \
  IndicatorCalculateCache<double> *_cache;                                                               \
  string _key = Util::MakeKey(SYMBOL, (int)TF, KEY);                                                     \
  if (!Objects<IndicatorCalculateCache<double>>::TryGet(_key, _cache)) {                                 \
    _cache = Objects<IndicatorCalculateCache<double>>::Set(_key, new IndicatorCalculateCache<double>()); \
  }

#define INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_LONG(SYMBOL, TF, KEY)                     \
  ValueStorage<datetime> *_time = TimeValueStorage::GetInstance(SYMBOL, TF);                    \
  ValueStorage<long> *_tick_volume = TickVolumeValueStorage::GetInstance(SYMBOL, TF);           \
  ValueStorage<long> *_volume = VolumeValueStorage::GetInstance(SYMBOL, TF);                    \
  ValueStorage<long> *_spread = SpreadValueStorage::GetInstance(SYMBOL, TF);                    \
  ValueStorage<double> *_price_open = PriceValueStorage::GetInstance(SYMBOL, TF, PRICE_OPEN);   \
  ValueStorage<double> *_price_high = PriceValueStorage::GetInstance(SYMBOL, TF, PRICE_HIGH);   \
  ValueStorage<double> *_price_low = PriceValueStorage::GetInstance(SYMBOL, TF, PRICE_LOW);     \
  ValueStorage<double> *_price_close = PriceValueStorage::GetInstance(SYMBOL, TF, PRICE_CLOSE); \
  INDICATOR_CALCULATE_POPULATE_CACHE(SYMBOL, TF, KEY)

#define INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_SHORT(SYMBOL, TF, APPLIED_PRICE, KEY) \
  ValueStorage<double> *_price = PriceValueStorage::GetInstance(SYMBOL, TF, APPLIED_PRICE); \
  INDICATOR_CALCULATE_POPULATE_CACHE(SYMBOL, TF, KEY)

#define INDICATOR_CALCULATE_POPULATED_PARAMS_LONG \
  _time, _price_open, _price_high, _price_low, _price_close, _tick_volume, _volume, _spread

#define INDICATOR_CALCULATE_POPULATED_PARAMS_SHORT _price

// Includes.





/**
 * Value storage settable/gettable via indexation operator.
 */
template <typename C>
class ValueStorage : public IValueStorage {
 public:
  /**
   * Indexation operator.
   */
  ValueStorageAccessor<C> operator[](int _index) {
    ValueStorageAccessor<C> _accessor(THIS_PTR, _index);
    return _accessor;
  }

  /**
   * Destructor.
   */
  virtual ~ValueStorage() {}

  /**
   * Initializes storage with given value.
   */
  virtual void Initialize(C _value) {}

  /**
   * Fetches value from a given shift. Takes into consideration as-series flag.
   */
  virtual C Fetch(int _shift) {
    Alert(__FUNCSIG__, " is not supported!");
    DebugBreak();
    return (C)0;
  }

  /**
   * Fetches value from the end of the array (assumes as-series storage).
   */
  virtual C FetchSeries(int _shift) { return Fetch(ArraySize(THIS_REF) - _shift - 1); }

  /**
   * Stores value at a given shift. Takes into consideration as-series flag.
   */
  virtual void Store(int _shift, C _value) {
    Alert(__FUNCSIG__, " is not supported!");
    DebugBreak();
  }

  /**
   * Sets buffer drawing attributes. Currently does nothing.
   */
  bool PlotIndexSetInteger(int prop_id, int prop_modifier_or_value, int prop_value) {
    // @todo Implementation.
    return true;
  }
};

/**
 * ValueStorage-compatible wrapper for ArrayInitialize.
 */
template <typename C>
void ArrayInitialize(ValueStorage<C> &_storage, C _value) {
  _storage.Initialize(_value);
}

/**
 * ValueStorage-compatible wrapper for ArrayCopy.
 */
template <typename C, typename D>
int ArrayCopy(D &_target[], ValueStorage<C> &_source, int _dst_start = 0, int _src_start = 0, int count = WHOLE_ARRAY) {
  if (count == WHOLE_ARRAY) {
    count = ArraySize(_source);
  }

  if (ArrayGetAsSeries(_target)) {
    if ((ArraySize(_target) == 0 && _dst_start != 0) ||
        (ArraySize(_target) != 0 && ArraySize(_target) < _dst_start + count)) {
      // The receiving array is declared as AS_SERIES, and it is of insufficient size.
      SetUserError(ERR_SMALL_ASSERIES_ARRAY);
      ArrayResize(_target, 0);
      return 0;
    }
  }

  int _pre_fill = _dst_start;

  count = MathMin(count, ArraySize(_source) - _src_start);

  int _dst_required_size = _dst_start + count;

  if (ArraySize(_target) < _dst_required_size) {
    ArrayResize(_target, _dst_required_size, 32);
  }

  int _num_copied, t, s;

  for (_num_copied = 0, t = _dst_start, s = _src_start; _num_copied < count; ++_num_copied, ++t, ++s) {
    if (s >= ArraySize(_source)) {
      // No more data to copy.
      break;
    }

    bool _reverse = ArrayGetAsSeries(_target) != ArrayGetAsSeries(_source);

    int _source_idx = _reverse ? (ArraySize(_source) - s - 1 + _src_start) : s;

    _target[t] = _source[_source_idx].Get();
  }

  return _num_copied;
}

/**
 * iHigest() version working on ValueStorage.
 */
int iHighest(ValueStorage<double> &_price, int _count = WHOLE_ARRAY, int _start = 0) {
  return iPeak(_price, _count, _start, IPEAK_HIGHEST);
}

/**
 * iLowest() version working on ValueStorage.
 */
int iLowest(ValueStorage<double> &_price, int _count = WHOLE_ARRAY, int _start = 0) {
  return iPeak(_price, _count, _start, IPEAK_LOWEST);
}

/**
 * iLowest() version working on ValueStorage.
 */
int iPeak(ValueStorage<double> &_price, int _count, int _start, ENUM_IPEAK _type) {
  int _price_size = ArraySize(_price);

  if (_count == WHOLE_ARRAY) {
    _count = _price_size;
  }

  int _peak_idx = _start;
  double _peak_val = 0;

  switch (_type) {
    case IPEAK_LOWEST:
      _peak_val = DBL_MAX;
      break;
    case IPEAK_HIGHEST:
      _peak_val = -DBL_MAX;
      break;
  }

  for (int i = _start; (i < _start + _count) && (i < _price_size); ++i) {
    double _value = _price.FetchSeries(i);

    bool _cond = false;

    switch (_type) {
      case IPEAK_LOWEST:
        _cond = _value < _peak_val;
        break;
      case IPEAK_HIGHEST:
        _cond = _value > _peak_val;
        break;
    }

    if (_cond) {
      _peak_val = _value;
      _peak_idx = i;
    }
  }

  return _price_size - _peak_idx - 1;
}

#endif  // STRATEGY_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: ValueStorage.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Refs.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Refs.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef REFS_MQH
#define REFS_MQH

// Includes.



/**
 * For explanation about difference between strong(Ref) and weak(WeakRef) references please look at:
 * @see https://medium.com/@elliotchance/strong-vs-weak-references-70356d37dfd2
 *
 *
 *
 * Usage:
 *
 * class Node : public Dynamic {
 *
 * protected:
 *
 *   WeakRef<Node> parentNode;
 *   Dict<Ref<Node>> childNodes;
 *
 * public:
 *
 *   void AddChild(Node* _node) {
 *     _node.parentNode = this;
 *
 *     Ref<Node> ref = _node;
 *     childNodes.Push(ref);
 *   }
 * };
 *
 *
 * Ref<Node> root = new Node();
 *
 * Ref<Node> child1 = new Node();
 * Ref<Node> child2 = new Node();
 *
 * root.childNodes.Push(child1);
 * root.childNodes.Push(child2);
 */

// Forward class declaration.
class Dynamic;

class ReferenceCounter {
 public:
  /**
   * Number of weak references to target object.
   */
  unsigned int num_weak_refs;

  /**
   * Number of strong references to target object.
   */
  unsigned int num_strong_refs;

  /**
   * Target object pointer.
   */
  Dynamic* ptr_object;

  /**
   * Whether object has been deleted (but still have weak references).
   */
  bool deleted;

  /**
   * Constructor.
   */
  ReferenceCounter() {
    num_weak_refs = 0;
    num_strong_refs = 0;
    ptr_object = NULL;
    deleted = false;
  }

  string Debug() { return StringFormat("%d: %d strong, %d weak", ptr_object, num_strong_refs, num_weak_refs); }

  /**
   * ReferenceCounter class allocator.
   */
  static ReferenceCounter* alloc();
};

/**
 * ReferenceCounter class allocator.
 */
ReferenceCounter* ReferenceCounter::alloc() {
  // @todo Enhance with linked-list object reuse.
  return new ReferenceCounter();
}

/**
 * Base class for reference-counted objects.
 */
class Dynamic {
 public:
  /**
   * Pointer to object holding reference counts.
   */
  ReferenceCounter* ptr_ref_counter;

  /**
   * Constructor.
   */
  Dynamic() {
#ifdef __MQL__
    if (CheckPointer(GetPointer(this)) == POINTER_DYNAMIC) {
#else
    // For other languages we just assume that user knows what he does and creates all Dynamic instances on the heap.
    if (true) {
#endif
      // Only dynamic objects are reference-counted.
      ptr_ref_counter = ReferenceCounter::alloc();
      PTR_ATTRIB(ptr_ref_counter, ptr_object) = THIS_PTR;
    } else {
      // For objects allocated on the stack we don't use reference counting.
      ptr_ref_counter = NULL;
    }
  }

  /**
   * Destructor.
   */
  ~Dynamic() {
    if (ptr_ref_counter != NULL && PTR_ATTRIB(ptr_ref_counter, num_strong_refs) == 0 &&
        PTR_ATTRIB(ptr_ref_counter, num_weak_refs) == 0) {
#ifdef __MQL__
      if (CheckPointer(ptr_ref_counter) == POINTER_DYNAMIC) {
#else
      // For other languages we just assume that user knows what he does and creates all Dynamic instances on the heap.
      if (true) {
#endif
        // Object never been referenced.
        if (ptr_ref_counter != NULL) {
          delete ptr_ref_counter;
        }
      }
    }
  }

  Dynamic(const Dynamic& right) {
    ptr_ref_counter = NULL;
#ifdef __MQL__
    if (CheckPointer(THIS_PTR) != POINTER_DYNAMIC && CheckPointer(&right) == POINTER_DYNAMIC) {
      Print(
          "Dynamic object misuse: Invoking copy constructor: STACK OBJECT = HEAP OBJECT. Remember that you can only "
          "assign heap-allocated objects to heap-allocated objects!");
    }
#endif
  }

  void operator=(const Dynamic& right) {
    if (right.ptr_ref_counter != NULL /*&& CheckPointer(&right) == POINTER_DYNAMIC*/) {
      Print(
          "Dynamic class misuse: Invoking assignment operator for stack object with heap-allocated object on the right "
          "side.");
    }
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Refs.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * IndicatorBufferValueStorage class.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.



/**
 * Holds buffers used to cache values calculated via OnCalculate methods.
 */
template <typename C>
class IndicatorCalculateCache : public Dynamic {
 public:
  // Total number of calculated values.
  int prev_calculated;

  // Number of prices to use.
  int total;

  // Whether cache was initialized with price buffer.
  bool initialized;

  // Buffer to store input prices. Won't be deleted!
  ValueStorage<C> *price_buffer;

  // Buffer to store input open prices. Won't be deleted!
  ValueStorage<C> *price_open_buffer;

  // Buffer to store input high prices. Won't be deleted!
  ValueStorage<C> *price_high_buffer;

  // Buffer to store input low prices. Won't be deleted!
  ValueStorage<C> *price_low_buffer;

  // Buffer to store input close prices. Won't be deleted!
  ValueStorage<C> *price_close_buffer;

  // Buffers used for OnCalculate calculations.
  ARRAY(IValueStorage *, buffers);

  // Auxiliary caches related to this one.
  ARRAY(IndicatorCalculateCache<C> *, subcaches);

  /**
   * Constructor.
   */
  IndicatorCalculateCache(int _buffers_size = 0) {
    prev_calculated = 0;
    total = 0;
    initialized = false;
    Resize(_buffers_size);
  }

  /**
   * Destructor.
   */
  ~IndicatorCalculateCache() {
    int i;

    for (i = 0; i < ArraySize(buffers); ++i) {
      if (buffers[i] != NULL) {
        delete buffers[i];
      }
    }

    for (i = 0; i < ArraySize(subcaches); ++i) {
      if (subcaches[i] != NULL) {
        delete subcaches[i];
      }
    }
  }

  /**
   * Returns size of the current price buffer.
   */
  int GetTotal() { return price_buffer != NULL ? ArraySize(price_buffer) : ArraySize(price_open_buffer); }

  /**
   * Returns number of already calculated prices (bars).
   */
  int GetPrevCalculated() { return prev_calculated; }

  /**
   * Whether cache have any buffer.
   */
  bool HasBuffers() { return ArraySize(buffers) != 0; }

  /**
   * Returns number of added buffers.
   */
  int NumBuffers() { return ArraySize(buffers); }

  /**
   * Returns existing or new cache as a child of current one. Useful when indicator uses other indicators and requires
   * unique caches for them.
   */
  IndicatorCalculateCache<C> *GetSubCache(int index) {
    if (index >= ArraySize(subcaches)) {
      ArrayResize(subcaches, index + 1, 10);
    }

    if (subcaches[index] == NULL) {
      subcaches[index] = new IndicatorCalculateCache();
    }

    return subcaches[index];
  }

  /**
   * Add buffer of the given type. Usage: AddBuffer<NativeBuffer>()
   */
  template <typename T>
  int AddBuffer(int _num_buffers = 1) {
    IValueStorage *_ptr;

    while (_num_buffers-- > 0) {
      _ptr = new T();
      ArrayPushObject(buffers, _ptr);
    }

    return ArraySize(buffers) - 1;
  }

  /**
   * Returns given calculation buffer.
   */
  template <typename D>
  ValueStorage<D> *GetBuffer(int _index) {
    return (ValueStorage<D> *)buffers[_index];
  }

  /**
   * Returns main price buffer.
   */
  ValueStorage<C> *GetPriceBuffer() { return price_buffer; }

  /**
   * Returns given price buffer.
   */
  ValueStorage<C> *GetPriceBuffer(ENUM_APPLIED_PRICE _applied_price) {
    switch (_applied_price) {
      case PRICE_OPEN:
        return price_open_buffer;
      case PRICE_HIGH:
        return price_high_buffer;
      case PRICE_LOW:
        return price_low_buffer;
      case PRICE_CLOSE:
        return price_close_buffer;
    }
    return NULL;
  }

  /**
   * Sets price buffer for later use.
   */
  void SetPriceBuffer(ValueStorage<C> &_price, int _total = 0) {
    price_buffer = &_price;

    if (_total == 0) {
      _total = _price.Size();
    }

    total = _total;

    // Cache is ready to be used.
    initialized = true;
  }

  /**
   * Sets price buffers for later use.
   */
  void SetPriceBuffer(ValueStorage<C> &_price_open, ValueStorage<C> &_price_high, ValueStorage<C> &_price_low,
                      ValueStorage<C> &_price_close, int _total = 0) {
    price_open_buffer = &_price_open;
    price_high_buffer = &_price_high;
    price_low_buffer = &_price_low;
    price_close_buffer = &_price_close;

    if (_total == 0) {
      _total = _price_open.Size();
    }

    total = _total;

    // Cache is ready to be used.
    initialized = true;
  }

  /**
   * Resizes all buffers.
   */
  void Resize(int _buffers_size) {
    for (int i = 0; i < ArraySize(buffers); ++i) {
      buffers[i].Resize(_buffers_size, 65535);
    }
  }

  /**
   * Retrieves cached value from the given buffer.
   */
  template <typename D>
  D GetValue(int _buffer_index, int _shift) {
    return GetBuffer<D>(_buffer_index).Fetch(_shift).Get();
  }

  /**
   *
   */
  template <typename D>
  D GetTailValue(int _buffer_index, int _shift) {
    ValueStorage<D> *_buff = GetBuffer<D>(_buffer_index);
    int _index = _buff.IsSeries() ? _shift : (ArraySize(_buff) - _shift - 1);
    return _buff[_index].Get();
  }

  /**
   * Updates prev_calculated value used by indicator's OnCalculate method.
   */
  void SetPrevCalculated(int _prev_calculated) {
    if (_prev_calculated == 0) {
      ResetPrevCalculated();
    } else {
      prev_calculated = _prev_calculated;
    }
  }

  /**
   * Resets prev_calculated value used by indicator's OnCalculate method.
   */
  void ResetPrevCalculated() { prev_calculated = 0; }

  /**
   * Returns prev_calculated value used by indicator's OnCalculate method.
   */
  int GetPrevCalculated(int _prev_calculated) { return prev_calculated; }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indicator.struct.cache.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.struct.tf.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Chart's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

#ifndef __MQL__
// Defines enumeration for price price base calculations.
// Define: In MQL4 enum values starts from 0, where in MQL5 from 1.
// https://www.mql5.com/en/docs/constants/indicatorconstants/prices
// https://docs.mql4.com/constants/indicatorconstants/prices
enum ENUM_APPLIED_PRICE {
  PRICE_CLOSE = 0,  // Close price
  PRICE_OPEN,       // Open price
  PRICE_HIGH,       // The maximum price for the period
  PRICE_LOW,        // The minimum price for the period
  PRICE_MEDIAN,     // Median price (H+L)/2
  PRICE_TYPICAL,    // Typical price, (H+L+C)/3
  PRICE_WEIGHTED,   // Weighted close price (H+L+C+C)/4
};
#endif

// Defines enumeration for chart parameters.
enum ENUM_CHART_PARAM {
  CHART_PARAM_NONE = 0,  // None
  CHART_PARAM_ID,        // Chart ID
  CHART_PARAM_SYMBOL,    // Symbol
  CHART_PARAM_TF,        // Timeframe
  CHART_PARAM_TFI,       // Timeframe index
  FINAL_ENUM_CHART_PARAM
};

/**
 * Define type of periods.
 *
 * @see: https://docs.mql4.com/constants/chartconstants/enum_timeframes
 */
enum ENUM_TIMEFRAMES_INDEX {
  M1 = 0,    // 1 minute
  M2 = 1,    // 2 minutes (non-standard)
  M3 = 2,    // 3 minutes (non-standard)
  M4 = 3,    // 4 minutes (non-standard)
  M5 = 4,    // 5 minutes
  M6 = 5,    // 6 minutes (non-standard)
  M10 = 6,   // 10 minutes (non-standard)
  M12 = 7,   // 12 minutes (non-standard)
  M15 = 8,   // 15 minutes
  M20 = 9,   // 20 minutes (non-standard)
  M30 = 10,  // 30 minutes
  H1 = 11,   // 1 hour
  H2 = 12,   // 2 hours (non-standard)
  H3 = 13,   // 3 hours (non-standard)
  H4 = 14,   // 4 hours
  H6 = 15,   // 6 hours (non-standard)
  H8 = 16,   // 8 hours (non-standard)
  H12 = 17,  // 12 hours (non-standard)
  D1 = 18,   // Daily
  W1 = 19,   // Weekly
  MN1 = 20,  // Monthly
  // This item should be the last one.
  // Used to calculate the number of enum items.
  FINAL_ENUM_TIMEFRAMES_INDEX = 21
};

#ifndef __MQLBUILD__
/**
 * Defines chart timeframes.
 *
 * @see:
 * - https://docs.mql4.com/constants/chartconstants/enum_timeframes
 * - https://www.mql5.com/en/docs/constants/chartconstants/enum_timeframes
 */
enum ENUM_TIMEFRAMES {
  PERIOD_CURRENT = 0,  // Current timeframe.
  PERIOD_M1 = 1,       // 1 minute.
  PERIOD_M2 = 2,       // 2 minutes.
  PERIOD_M3 = 3,       // 3 minutes.
  PERIOD_M4 = 4,       // 4 minutes.
  PERIOD_M5 = 5,       // 5 minutes.
  PERIOD_M6 = 6,       // 6 minutes.
  PERIOD_M10 = 10,     // 10 minutes.
  PERIOD_M12 = 12,     // 12 minutes.
  PERIOD_M15 = 15,     // 15 minutes.
  PERIOD_M20 = 20,     // 20 minutes.
  PERIOD_M30 = 30,     // 30 minutes.
  PERIOD_H1 = 60,      // 1 hour.
  PERIOD_H2 = 120,     // 2 hours.
  PERIOD_H3 = 180,     // 3 hours.
  PERIOD_H4 = 240,     // 4 hours.
  PERIOD_H6 = 360,     // 6 hours.
  PERIOD_H8 = 480,     // 8 hours.
  PERIOD_H12 = 720,    // 12 hours.
  PERIOD_D1 = 1440,    // 1 day.
  PERIOD_W1 = 10080,   // 1 week.
  PERIOD_MN1 = 43200   // 1 month.
};

#endif

// Define type of periods.
// @see: https://docs.mql4.com/constants/chartconstants/enum_timeframes
#define TFS 21
const ENUM_TIMEFRAMES TIMEFRAMES_LIST[TFS] = {PERIOD_M1,  PERIOD_M2,  PERIOD_M3,  PERIOD_M4,  PERIOD_M5,  PERIOD_M6,
                                              PERIOD_M10, PERIOD_M12, PERIOD_M15, PERIOD_M20, PERIOD_M30, PERIOD_H1,
                                              PERIOD_H2,  PERIOD_H3,  PERIOD_H4,  PERIOD_H6,  PERIOD_H8,  PERIOD_H12,
                                              PERIOD_D1,  PERIOD_W1,  PERIOD_MN1};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Chart's timeframe structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.


/* Defines struct for chart timeframe. */
struct ChartTf {
 protected:
  ENUM_TIMEFRAMES tf;
  ENUM_TIMEFRAMES_INDEX tfi;

 public:
  // Constructors.
  ChartTf(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT) : tf(_tf), tfi(ChartTf::TfToIndex(_tf)){};
  ChartTf(ENUM_TIMEFRAMES_INDEX _tfi) : tfi(_tfi), tf(ChartTf::IndexToTf(_tfi)){};
  ChartTf(const ChartTf& _ctf) : tf(_ctf.tf), tfi(_ctf.tfi){};

  // Struct operators.
  void operator=(ENUM_TIMEFRAMES _tf) { SetTf(_tf); }
  void operator=(ENUM_TIMEFRAMES_INDEX _tfi) { SetIndex(_tfi); }

  /* Getters */

  /**
   * Returns timeframe's period in number of hours.
   */
  double GetInHours() const { return ChartTf::TfToHours(tf); }

  /**
   * Returns timeframe's period in number of minutes.
   */
  double GetInMinutes() const { return ChartTf::TfToMinutes(tf); }

  /**
   * Returns timeframe's period in number of seconds.
   */
  unsigned int GetInSeconds() const { return ChartTf::TfToSeconds(tf); }

  /**
   * Returns chart's timeframe index.
   *
   * @return ENUM_TIMEFRAMES_INDEX
   *   Returns enum representing chart's timeframe index.
   */
  ENUM_TIMEFRAMES_INDEX GetIndex() const { return tfi; }

  /**
   * Returns chart's timeframe value.
   *
   * @return ENUM_TIMEFRAMES
   *   Returns enum representing chart's timeframe value.
   */
  ENUM_TIMEFRAMES GetTf() const { return tf; }

  /**
   * Returns chart's textual represention.
   *
   * @return string
   *   Returns string represention.
   */
  string GetString() const { return TfToString(tf); }

  /* Setters */

  /**
   * Sets chart's timeframe.
   *
   * @param _tf
   *   Timeframe enum.
   */
  void SetTf(ENUM_TIMEFRAMES _tf) {
    tf = _tf;
    tfi = ChartTf::TfToIndex(_tf);
  }

  /**
   * Sets chart's timeframe.
   *
   * @param _tf
   *   Timeframe enum.
   */
  void SetIndex(ENUM_TIMEFRAMES_INDEX _tfi) {
    tf = ChartTf::IndexToTf(_tfi);
    tfi = _tfi;
  }

  /* Static methods */

  /**
   * Converts number of seconds per bar to chart's timeframe.
   *
   * @param _secs
   *   Number of seconds per one bar chart (OHLC).
   *
   * @return ENUM_TIMEFRAMES
   *   Returns enum representing chart's timeframe value.
   */
  static ENUM_TIMEFRAMES SecsToTf(uint _secs = 0) {
    switch (_secs) {
      case 0:
        return PERIOD_CURRENT;
      case 60:
        return PERIOD_M1;  // 1 minute.
      case 60 * 2:
        return PERIOD_M2;  // 2 minutes (non-standard).
      case 60 * 3:
        return PERIOD_M3;  // 3 minutes (non-standard).
      case 60 * 4:
        return PERIOD_M4;  // 4 minutes (non-standard).
      case 60 * 5:
        return PERIOD_M5;  // 5 minutes.
      case 60 * 6:
        return PERIOD_M6;  // 6 minutes (non-standard).
      case 60 * 10:
        return PERIOD_M10;  // 10 minutes (non-standard).
      case 60 * 12:
        return PERIOD_M12;  // 12 minutes (non-standard).
      case 60 * 15:
        return PERIOD_M15;  // 15 minutes.
      case 60 * 20:
        return PERIOD_M20;  // 20 minutes (non-standard).
      case 60 * 30:
        return PERIOD_M30;  // 30 minutes.
      case 60 * 60:
        return PERIOD_H1;  // 1 hour.
      case 60 * 60 * 2:
        return PERIOD_H2;  // 2 hours (non-standard).
      case 60 * 60 * 3:
        return PERIOD_H3;  // 3 hours (non-standard).
      case 60 * 60 * 4:
        return PERIOD_H4;  // 4 hours.
      case 60 * 60 * 6:
        return PERIOD_H6;  // 6 hours (non-standard).
      case 60 * 60 * 8:
        return PERIOD_H8;  // 8 hours (non-standard).
      case 60 * 60 * 12:
        return PERIOD_H12;  // 12 hours (non-standard).
      case 60 * 60 * 24:
        return PERIOD_D1;  // Daily.
      case 60 * 60 * 24 * 7:
        return PERIOD_W1;  // Weekly.
      default:
        break;
    }
    if (_secs >= 60 * 60 * 24 * 28 && _secs <= 60 * 60 * 24 * 31) {
      return PERIOD_MN1;  // Monthly range.
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return PERIOD_CURRENT;
  }

  /**
   * Convert period to proper chart timeframe value.
   *
   * @param
   * _tf ENUM_TIMEFRAMES_INDEX Specify timeframe index enum.
   */
  static ENUM_TIMEFRAMES const IndexToTf(ENUM_TIMEFRAMES_INDEX index) {
    // @todo: Convert it into a loop and using tf constant, see: TfToIndex().
    switch (index) {
      case M1:
        return PERIOD_M1;  // 1 minute.
      case M2:
        return PERIOD_M2;  // 2 minutes (non-standard).
      case M3:
        return PERIOD_M3;  // 3 minutes (non-standard).
      case M4:
        return PERIOD_M4;  // 4 minutes (non-standard).
      case M5:
        return PERIOD_M5;  // 5 minutes.
      case M6:
        return PERIOD_M6;  // 6 minutes (non-standard).
      case M10:
        return PERIOD_M10;  // 10 minutes (non-standard).
      case M12:
        return PERIOD_M12;  // 12 minutes (non-standard).
      case M15:
        return PERIOD_M15;  // 15 minutes.
      case M20:
        return PERIOD_M20;  // 20 minutes (non-standard).
      case M30:
        return PERIOD_M30;  // 30 minutes.
      case H1:
        return PERIOD_H1;  // 1 hour.
      case H2:
        return PERIOD_H2;  // 2 hours (non-standard).
      case H3:
        return PERIOD_H3;  // 3 hours (non-standard).
      case H4:
        return PERIOD_H4;  // 4 hours.
      case H6:
        return PERIOD_H6;  // 6 hours (non-standard).
      case H8:
        return PERIOD_H8;  // 8 hours (non-standard).
      case H12:
        return PERIOD_H12;  // 12 hours (non-standard).
      case D1:
        return PERIOD_D1;  // Daily.
      case W1:
        return PERIOD_W1;  // Weekly.
      case MN1:
        return PERIOD_MN1;  // Monthly.
      default:
        return (ENUM_TIMEFRAMES)-1;
    }
  }

  /**
   * Convert timeframe period to hours.
   *
   * @param
   * _tf ENUM_TIMEFRAMES Specify timeframe enum.
   */
  static double TfToHours(const ENUM_TIMEFRAMES _tf) { return ChartTf::TfToSeconds(_tf) / (60 * 60); }

  /**
   * Convert timeframe constant to index value.
   *
   * @param
   * _tf ENUM_TIMEFRAMES Specify timeframe enum.
   */
  static ENUM_TIMEFRAMES_INDEX TfToIndex(ENUM_TIMEFRAMES _tf) {
    _tf = (_tf == 0 || _tf == PERIOD_CURRENT) ? (ENUM_TIMEFRAMES)_Period : _tf;
    for (int i = 0; i < ArraySize(TIMEFRAMES_LIST); i++) {
      if (TIMEFRAMES_LIST[i] == _tf) {
        return (ENUM_TIMEFRAMES_INDEX)i;
      }
    }
    return FINAL_ENUM_TIMEFRAMES_INDEX;
  }

  /**
   * Convert timeframe period to minutes.
   *
   * @param
   * _tf ENUM_TIMEFRAMES Specify timeframe enum.
   */
  static double TfToMinutes(const ENUM_TIMEFRAMES _tf) { return ChartTf::TfToSeconds(_tf) / 60; }

  /**
   * Convert timeframe period to seconds.
   *
   * @param
   * _tf ENUM_TIMEFRAMES Specify timeframe enum.
   */
  static unsigned int TfToSeconds(const ENUM_TIMEFRAMES _tf) { return ::PeriodSeconds(_tf); }

  /**
   * Returns text representation of the timeframe constant.
   *
   * @param
   * _tf ENUM_TIMEFRAMES Specify timeframe enum.
   *
   * @return
   * Returns string representation of the timeframe.
   */
  static string TfToString(const ENUM_TIMEFRAMES _tf) {
    switch (_tf) {
      case PERIOD_CURRENT:
        return "Current";
      case PERIOD_M1:
        return "M1";
      case PERIOD_M2:
        return "M2";
      case PERIOD_M3:
        return "M3";
      case PERIOD_M4:
        return "M4";
      case PERIOD_M5:
        return "M5";
      case PERIOD_M6:
        return "M6";
      case PERIOD_M10:
        return "M10";
      case PERIOD_M12:
        return "M12";
      case PERIOD_M15:
        return "M15";
      case PERIOD_M20:
        return "M20";
      case PERIOD_M30:
        return "M30";
      case PERIOD_H1:
        return "H1";
      case PERIOD_H2:
        return "H2";
      case PERIOD_H3:
        return "H3";
      case PERIOD_H4:
        return "H4";
      case PERIOD_H6:
        return "H6";
      case PERIOD_H8:
        return "H8";
      case PERIOD_H12:
        return "H12";
      case PERIOD_D1:
        return "D1";
      case PERIOD_W1:
        return "W1";
      case PERIOD_MN1:
        return "MN1";
      default:
        break;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return "Unknown";
  }

  /**
   * Returns text representation of the timeframe index.
   */
  static string IndexToString(const ENUM_TIMEFRAMES_INDEX _tfi) { return TfToString(IndexToTf(_tfi)); }

  // Serializers.
  SerializerNodeType Serialize(Serializer& s);
};



/* Method to serialize ChartTf structure. */
SerializerNodeType ChartTf::Serialize(Serializer& s) {
  s.PassEnum(THIS_REF, "tf", tf);
  s.PassEnum(THIS_REF, "tfi", tfi);
  return SerializerNodeObject;
}

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.struct.tf.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Array.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Indicator's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward declaration.
template <typename TS>
class Indicator;
struct ChartParams;

// Includes.









// Type-less value for IndicatorDataEntryValue structure.
union IndicatorDataEntryTypelessValue {
  double vdbl;
  float vflt;
  int vint;
  long vlong;
};

// Type-aware value for IndicatorDataEntry class.
struct IndicatorDataEntryValue {
  unsigned char flags;
  IndicatorDataEntryTypelessValue value;

  // Returns type of the value.
  ENUM_DATATYPE GetDataType() { return (ENUM_DATATYPE)((flags & 0xF0) >> 4); }

  // Sets type of the value.
  void SetDataType(ENUM_DATATYPE _type) {
    // Clearing type.
    flags &= 0x0F;

    // Setting type.
    flags |= (unsigned char)_type << 4;
  }

  // Union operators.
  template <typename T>
  T operator*(const T _value) {
    return Get<T>() * _value;
  }
  template <typename T>
  T operator+(const T _value) {
    return Get<T>() + _value;
  }
  template <typename T>
  T operator-(const T _value) {
    return Get<T>() - _value;
  }
  template <typename T>
  T operator/(const T _value) {
    return Get<T>() / _value;
  }
  template <typename T>
  bool operator!=(const T _value) {
    return Get<T>() != _value;
  }
  template <typename T>
  bool operator<(const T _value) {
    return Get<T>() < _value;
  }
  template <typename T>
  bool operator<=(const T _value) {
    return Get<T>() <= _value;
  }
  template <typename T>
  bool operator==(const T _value) {
    return Get<T>() == _value;
  }
  template <typename T>
  bool operator>(const T _value) {
    return Get<T>() > _value;
  }
  template <typename T>
  bool operator>=(const T _value) {
    return Get<T>() >= _value;
  }
  template <typename T>
  void operator=(const T _value) {
    Set(_value);
  }
  // Checkers.
  template <typename T>
  bool IsGt(T _value) {
    return Get<T>() > _value;
  }
  template <typename T>
  bool IsLt(T _value) {
    return Get<T>() < _value;
  }
  // Getters.
  double GetDbl() { return value.vdbl; }
  float GetFloat() { return value.vflt; }
  int GetInt() { return value.vint; }
  long GetLong() { return value.vlong; }
  template <typename T>
  void Get(T &_out) {
    _out = Get<T>();
  }
  template <typename T>
  T Get() {
    T _v;
    Get(_v);
    return _v;
  }
  void Get(double &_out) { _out = value.vdbl; }
  void Get(float &_out) { _out = value.vflt; }
  void Get(int &_out) { _out = value.vint; }
  void Get(unsigned int &_out) { _out = (unsigned int)value.vint; }
  void Get(long &_out) { _out = value.vlong; }
  void Get(unsigned long &_out) { _out = (unsigned long)value.vint; }
  // Setters.
  template <typename T>
  void Set(T _value) {
    Set(_value);
  }
  void Set(double _value) {
    value.vdbl = _value;
    SetDataType(TYPE_DOUBLE);
  }
  void Set(float _value) {
    value.vflt = _value;
    SetDataType(TYPE_FLOAT);
  }
  void Set(int _value) {
    value.vint = _value;
    SetDataType(TYPE_INT);
  }
  void Set(unsigned int _value) {
    value.vint = (int)_value;
    SetDataType(TYPE_UINT);
  }
  void Set(long _value) {
    value.vlong = _value;
    SetDataType(TYPE_LONG);
  }
  void Set(unsigned long _value) {
    value.vlong = (long)_value;
    SetDataType(TYPE_ULONG);
  }
  // Serializers.
  // SERIALIZER_EMPTY_STUB
  SerializerNodeType Serialize(Serializer &_s);
  // To string
  template <typename T>
  string ToString() {
    return (string)Get<T>();
  }
};

/* Structure for indicator data entry. */
struct IndicatorDataEntry {
  long timestamp;        // Timestamp of the entry's bar.
  unsigned short flags;  // Indicator entry flags.
  ARRAY(IndicatorDataEntryValue, values);

  // Constructors.
  IndicatorDataEntry(int _size = 1) : flags(INDI_ENTRY_FLAG_NONE), timestamp(0) { Resize(_size); }
  IndicatorDataEntry(IndicatorDataEntry &_entry) { THIS_REF = _entry; }
  int GetSize() { return ArraySize(values); }
  // Operator overloading methods.
  template <typename T>
  T operator*(const T _value) {
    return values[0].Get<T>() * _value;
  }
  template <typename T>
  T operator+(const T _value) {
    return values[0].Get<T>() + _value;
  }
  template <typename T>
  T operator-(const T _value) {
    return values[0].Get<T>() - _value;
  }
  template <typename T>
  T operator/(const T _value) {
    return values[0].Get<T>() / _value;
  }
  template <typename T, typename I>
  T operator[](I _index) {
    return values[(int)_index].Get<T>();
  }
  template <>
  double operator[](int _index) {
    if (_index >= ArraySize(values)) {
      return 0;
    }
    double _value;
    values[_index].Get(_value);
    return _value;
  }
  // Checkers.
  template <typename T>
  bool HasValue(T _value) {
    bool _result = false;
    int _asize = ArraySize(values);
    T _value2;
    for (int i = 0; i < _asize; i++) {
      values[i].Get(_value2);
      if (_value == _value2) {
        _result = true;
        break;
      }
    }
    return _result;
  }
  template <typename T>
  bool IsGe(T _value) {
    return GetMin<T>() >= _value;
  }
  template <typename T>
  bool IsGt(T _value) {
    return GetMin<T>() > _value;
  }
  template <typename T>
  bool IsLe(T _value) {
    return GetMax<T>() <= _value;
  }
  template <typename T>
  bool IsLt(T _value) {
    return GetMax<T>() < _value;
  }
  template <typename T>
  bool IsWithinRange(T _min, T _max) {
    return GetMin<T>() >= _min && GetMax<T>() <= _max;
  }
  // Getters.
  template <typename T>
  void GetArray(ARRAY_REF(T, _out), int _size = 0) {
    int _asize = _size > 0 ? _size : ArraySize(_out);
    for (int i = 0; i < _asize; i++) {
      values[i].Get(_out[i]);
    }
  };
  template <typename T>
  T GetAvg(int _size = 0) {
    int _asize = _size > 0 ? _size : ArraySize(values);
    T _avg = GetSum<T>() / _asize;
    return _avg;
  };
  template <typename T>
  T GetMin(int _size = 0) {
    int _asize = _size > 0 ? _size : ArraySize(values);
    int _index = 0;
    for (int i = 1; i < _asize; i++) {
      _index = values[i].Get<T>() < values[_index].Get<T>() ? i : _index;
    }
    return values[_index].Get<T>();
  };
  template <typename T>
  T GetMax(int _size = 0) {
    int _asize = _size > 0 ? _size : ArraySize(values);
    int _index = 0;
    for (int i = 1; i < _asize; i++) {
      _index = values[i].Get<T>() > values[_index].Get<T>() ? i : _index;
    }
    return values[_index].Get<T>();
  };
  template <typename T>
  T GetSum(int _size = 0) {
    int _asize = _size > 0 ? _size : ArraySize(values);
    T _sum = 0;
    for (int i = 1; i < _asize; i++) {
      _sum = +values[i].Get<T>();
    }
    return _sum;
  };
  template <typename T>
  T GetValue(int _index = 0) {
    return values[_index].Get<T>();
  };
  template <typename T>
  void GetValues(T &_out1, T &_out2) {
    values[0].Get(_out1);
    values[1].Get(_out2);
  };
  template <typename T>
  void GetValues(T &_out1, T &_out2, T &_out3) {
    values[0].Get(_out1);
    values[1].Get(_out2);
    values[2].Get(_out3);
  };
  template <typename T>
  void GetValues(T &_out1, T &_out2, T &_out3, T &_out4) {
    values[0].Get(_out1);
    values[1].Get(_out2);
    values[2].Get(_out3);
    values[3].Get(_out4);
  };

  // Getters.
  int GetDayOfYear() { return DateTimeStatic::DayOfYear(timestamp); }
  int GetMonth() { return DateTimeStatic::Month(timestamp); }
  int GetYear() { return DateTimeStatic::Year(timestamp); }
  long GetTime() { return timestamp; };
  ENUM_DATATYPE GetDataType(int _mode) { return values[_mode].GetDataType(); }
  ushort GetDataTypeFlags(ENUM_DATATYPE _dt) {
    switch (_dt) {
      case TYPE_BOOL:
      case TYPE_CHAR:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
      case TYPE_INT:
        return INDI_ENTRY_FLAG_NONE;
      case TYPE_LONG:
        return INDI_ENTRY_FLAG_IS_DOUBLED;
      case TYPE_UINT:
        return INDI_ENTRY_FLAG_IS_UNSIGNED;
      case TYPE_ULONG:
        return INDI_ENTRY_FLAG_IS_UNSIGNED | INDI_ENTRY_FLAG_IS_DOUBLED;
      case TYPE_DOUBLE:
        return INDI_ENTRY_FLAG_IS_REAL | INDI_ENTRY_FLAG_IS_DOUBLED;
      case TYPE_FLOAT:
        return INDI_ENTRY_FLAG_IS_REAL;
      case TYPE_STRING:
      case TYPE_UCHAR:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return INDI_ENTRY_FLAG_NONE;
  }
  // Setters.
  bool Resize(int _size = 0) { return _size > 0 ? ArrayResize(values, _size) > 0 : true; }
  // Value flag methods for bitwise operations.
  bool CheckFlag(INDICATOR_ENTRY_FLAGS _prop) { return CheckFlags(_prop); }
  bool CheckFlags(unsigned short _flags) { return (flags & _flags) != 0; }
  bool CheckFlagsAll(unsigned short _flags) { return (flags & _flags) == _flags; }
  void AddFlags(unsigned short _flags) { flags |= _flags; }
  void RemoveFlags(unsigned short _flags) { flags &= ~_flags; }
  void SetFlag(INDICATOR_ENTRY_FLAGS _flag, bool _value) {
    if (_value) {
      AddFlags(_flag);
    } else {
      RemoveFlags(_flag);
    }
  }
  void SetFlags(unsigned short _flags) { flags = _flags; }
  unsigned short GetFlags() { return flags; }
  // Converters.
  // State checkers.
  bool IsValid() { return CheckFlags(INDI_ENTRY_FLAG_IS_VALID); }
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
    ArrayResize(values, _n1);
    for (int i = 0; i < _n1; ++i) {
      values[i] = (int)1;
    }
  }
  SerializerNodeType Serialize(Serializer &_s);
  template <typename T>
  string ToCSV() {
    int _asize = ArraySize(values);
    string _result = "";
    for (int i = 0; i < _asize; i++) {
      _result += StringFormat("%s%s", (string)values[i].Get<T>(), i < _asize ? "," : "");
    }
    return _result;
  }
  template <typename T>
  string ToString() {
    return ToCSV<T>();
  }
};

/* Structure for indicator parameters. */
struct IndicatorParams {
 public:                            // @todo: Change it to protected.
  string name;                      // Name of the indicator.
  int shift;                        // Shift (relative to the current bar, 0 - default).
  unsigned int max_buffers;         // Max buffers to store.
  unsigned int max_modes;           // Max supported indicator modes (values per entry).
  unsigned int max_params;          // Max supported input params.
  ChartTf tf;                       // Chart's timeframe.
  ENUM_INDICATOR_TYPE itype;        // Indicator type (e.g. INDI_RSI).
  ENUM_IDATA_SOURCE_TYPE idstype;   // Indicator's data source type (e.g. IDATA_BUILTIN, IDATA_ICUSTOM).
  ENUM_IDATA_VALUE_RANGE idvrange;  // Indicator's range value data type.
  // ENUM_IDATA_VALUE_TYPE idvtype;    // Indicator's data value type (e.g. TDBL1, TDBL2, TINT1).
  ENUM_DATATYPE dtype;                  // Type of basic data to store values (DTYPE_DOUBLE, DTYPE_INT).
  color indi_color;                     // Indicator color.
  int indi_data_source_id;              // Id of the indicator to be used as data source.
  int indi_data_source_mode;            // Mode used as input from data source.
  ARRAY(DataParamEntry, input_params);  // Indicator input params.
  bool is_draw;                         // Draw active.
  int draw_window;                      // Drawing window.
  string custom_indi_name;              // Name of the indicator passed to iCustom() method.
 public:
  /* Special methods */
  // Constructor.
  IndicatorParams(ENUM_INDICATOR_TYPE _itype = INDI_NONE, unsigned int _max_modes = 1,
                  ENUM_DATATYPE _dtype = TYPE_DOUBLE, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT,
                  ENUM_IDATA_SOURCE_TYPE _idstype = IDATA_BUILTIN, string _name = "")
      : custom_indi_name(""),
        dtype(_dtype),
        name(_name),
        shift(0),
        max_modes(_max_modes),
        max_buffers(10),
        idstype(_idstype),
        idvrange(IDATA_RANGE_UNKNOWN),
        indi_data_source_id(-1),
        indi_data_source_mode(0),
        itype(_itype),
        is_draw(false),
        indi_color(clrNONE),
        draw_window(0),
        tf(_tf) {
    Init();
  };
  IndicatorParams(string _name, ENUM_IDATA_SOURCE_TYPE _idstype = IDATA_BUILTIN)
      : custom_indi_name(""),
        name(_name),
        shift(0),
        max_modes(1),
        max_buffers(10),
        idstype(_idstype),
        idvrange(IDATA_RANGE_UNKNOWN),
        indi_data_source_id(-1),
        indi_data_source_mode(0),
        is_draw(false),
        indi_color(clrNONE),
        draw_window(0) {
    Init();
  };
  // Copy constructor.
  IndicatorParams(IndicatorParams &_params, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT) {
    THIS_REF = _params;
    if (_tf != PERIOD_CURRENT) {
      tf.SetTf(_tf);
    }
  }
  void Init() {}
  /* Getters */
  string GetCustomIndicatorName() const { return custom_indi_name; }
  int GetDataSourceId() const { return indi_data_source_id; }
  int GetDataSourceMode() const { return indi_data_source_mode; }
  color GetIndicatorColor() const { return indi_color; }
  int GetMaxModes() const { return (int)max_modes; }
  int GetMaxParams() const { return (int)max_params; }
  int GetShift() const { return shift; }
  ENUM_DATATYPE GetDataValueType() const { return dtype; }
  ENUM_IDATA_SOURCE_TYPE GetDataSourceType() const { return idstype; }
  ENUM_IDATA_VALUE_RANGE GetIDataValueRange() const { return idvrange; }
  ENUM_TIMEFRAMES GetTf() const { return tf.GetTf(); }
  template <typename T>
  T GetInputParam(int _index, T _default) const {
    DataParamEntry _param = input_params[_index];
    switch (_param.type) {
      case TYPE_BOOL:
        return (T)param.integer_value;
      case TYPE_INT:
      case TYPE_LONG:
      case TYPE_UINT:
      case TYPE_ULONG:
        return param.integer_value;
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        return (T)param.double_value;
      case TYPE_CHAR:
      case TYPE_STRING:
      case TYPE_UCHAR:
        return (T)param.string_value;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }
  /* Setters */
  void SetCustomIndicatorName(string _name) { custom_indi_name = _name; }
  void SetDataSourceMode(int _mode) { indi_data_source_mode = _mode; }
  void SetDataSourceType(ENUM_IDATA_SOURCE_TYPE _idstype) { idstype = _idstype; }
  void SetDataValueRange(ENUM_IDATA_VALUE_RANGE _idvrange) { idvrange = _idvrange; }
  void SetDataValueType(ENUM_DATATYPE _dtype) { dtype = _dtype; }
  void SetDraw(bool _draw = true, int _window = 0) {
    is_draw = _draw;
    draw_window = _window;
  }
  void SetDraw(color _clr, int _window = 0) {
    is_draw = true;
    indi_color = _clr;
    draw_window = _window;
  }
  void SetIndicatorColor(color _clr) { indi_color = _clr; }
  void SetDataSource(int _id, int _input_mode = -1) {
    indi_data_source_id = _id;
    indi_data_source_mode = _input_mode;
    idstype = IDATA_INDICATOR;
  }
  void SetIndicatorType(ENUM_INDICATOR_TYPE _itype) { itype = _itype; }
  void SetInputParams(ARRAY_REF(DataParamEntry, _params)) {
    int _asize = ArraySize(_params);
    SetMaxParams(ArraySize(_params));
    for (int i = 0; i < _asize; i++) {
      input_params[i] = _params[i];
    }
  }
  void SetMaxModes(int _value) { max_modes = _value; }
  void SetMaxParams(int _value) {
    max_params = _value;
    ArrayResize(input_params, max_params);
  }
  void SetName(string _name) { name = _name; };
  void SetShift(int _shift) { shift = _shift; }
  void SetSize(int _size) { max_buffers = _size; };
  void SetTf(ENUM_TIMEFRAMES _tf) { tf.SetTf(_tf); }
  // Serializers.
  // SERIALIZER_EMPTY_STUB;
  // template <>
  SerializerNodeType Serialize(Serializer &s);
};

/* Structure for indicator state. */
struct IndicatorState {
  enum ENUM_INDICATOR_STATE_PROP {
    INDICATOR_STATE_PROP_HANDLE,
    INDICATOR_STATE_PROP_IS_CHANGED,
    INDICATOR_STATE_PROP_IS_READY,
  };
  int handle;       // Indicator handle (MQL5 only).
  bool is_changed;  // Set when params has been recently changed.
  bool is_ready;    // Set when indicator is ready (has valid values).
  // Constructor.
  IndicatorState() : handle(INVALID_HANDLE), is_changed(true), is_ready(false) {}
  // Getters.
  template <typename T>
  T Get(STRUCT_ENUM(IndicatorState, ENUM_INDICATOR_STATE_PROP) _prop) {
    switch (_prop) {
      case INDICATOR_STATE_PROP_HANDLE:
        return (T)handle;
      case INDICATOR_STATE_PROP_IS_CHANGED:
        return (T)is_changed;
      case INDICATOR_STATE_PROP_IS_READY:
        return (T)is_ready;
    };
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }
  // Setters.
  template <typename T>
  void Set(STRUCT_ENUM(IndicatorState, ENUM_INDICATOR_STATE_PROP) _prop, T _value) {
    switch (_prop) {
      case INDICATOR_STATE_PROP_HANDLE:
        handle = (T)_value;
        break;
      case INDICATOR_STATE_PROP_IS_CHANGED:
        is_changed = (T)_value;
        break;
      case INDICATOR_STATE_PROP_IS_READY:
        is_ready = (T)_value;
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
    };
  }
  // State checkers.
  bool IsChanged() { return is_changed; }
  bool IsReady() { return is_ready; }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indicator.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.






/**
 * Class to provide math related methods.
 */
class Math {
 protected:
 public:
  Math() {}

  /* Calculation */

  template <typename X>
  static X ReLU(X _value) {
    return (X)fmax(0, _value);
  }

  /**
   * Returns value changed by the given percentage.
   *
   * @param double _value
   *   Base value to change.
   * @param float _pct
   *   Percentage to change (1 is 100%).
   *
   * @return
   *   Returns value after the change.
   */
  static double ChangeByPct(double _v, float _pct) { return _v != 0 ? _v + (fabs(_v) * _pct) : 0; }

  /**
   * Calculates change between 2 values in percentage.
   *
   * @docs: https://stackoverflow.com/a/65511594/55075
   *
   * @param double _v1
   *   First value.
   * @param double _v2
   *   Second value.
   * @param bool _hundreds
   *   When true, 100% is 100, otherwise 1.
   * @return
   *   Returns percentage change.
   */
  static double ChangeInPct(double _v1, double _v2, bool _hundreds = false) {
    double _result = 0;
    if (_v1 != 0 && _v2 != 0) {
      // If values are non-zero, use the standard formula.
      _result = (_v2 / _v1) - 1;
    } else if (_v1 == 0 || _v2 == 0) {
      // Change is zero when both values are zeros, otherwise it's 1 (100%).
      _result = _v1 == 0 && _v2 == 0 ? 0 : 1;
    }
    _result = _v2 > _v1 ? fabs(_result) : -fabs(_result);
    return _hundreds ? _result * 100 : _result;
  }

  /**
   * Checks condition for 2 values based on the given comparison operator.
   */
  template <typename T1, typename T2>
  static bool Compare(T1 _v1, T2 _v2, ENUM_MATH_CONDITION _op = MATH_COND_EQ) {
    switch (_op) {
      case MATH_COND_EQ:
        return _v1 == _v2;
      case MATH_COND_GT:
        return _v1 > _v2;
      case MATH_COND_LE:
        return _v1 < _v2;
      default:
        break;
    }
    return false;
  }

  /**
   * Gets number of digits after decimal in a floating point number.
   */
  template <typename V>
  static short FloatDigits(V _value) {
    short _cnt = 0;
    while ((int)_value != _value) {
      _value *= 10;
      _cnt++;
    }
    return _cnt;
  }

  /**
   * Returns a non-zero value.
   *
   * @return
   *   Returns a non-zero value.
   */
  static double NonZero(double _v) { return _v == 0 ? DBL_MIN : _v; }

  /* Conditions */

  /**
   * Checks for math condition.
   *
   * @param ENUM_MATH_CONDITION _cond
   *   Math condition.
   * @param MqlParam[] _args
   *   Condition arguments.
   * @return
   *   Returns true when the condition is met.
   */
  /*
    bool CheckCondition(ENUM_MATH_CONDITION _cond, DataParamEntry &_args[]) {
      switch (_cond) {
        case MATH_COND_EQ:
          // @todo
          return false;
        case MATH_COND_GT:
          // @todo
          return false;
        case MATH_COND_LE:
          // @todo
          return false;
        default:
          // logger.Error(StringFormat("Invalid math condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
          return false;
      }
    }
    bool CheckCondition(ENUM_MATH_CONDITION _cond) {
      DataParamEntry _args[] = {};
      return Math::CheckCondition(_cond, _args);
    }
  */

  template <typename T>
  static T Add(T a, T b) {
    return a + b;
  }
  template <typename T>
  static T Sub(T a, T b) {
    return a - b;
  }
  template <typename T>
  static T Mul(T a, T b) {
    return a * b;
  }
  template <typename T>
  static T Div(T a, T b) {
    return a / b;
  }
  template <typename T>
  static T Sin(T a) {
    return sin(a);
  }
  template <typename T>
  static T Cos(T a) {
    return cos(a);
  }
  template <typename T>
  static T Tang(T a) {
    return tan(a);
  }
  template <typename T>
  static T Min(T a, T b) {
    return MathMin(a, b);
  }
  template <typename T>
  static T Min(T a, T b, T c) {
    return MathMin(MathMin(a, b), c);
  }
  template <typename T>
  static T Min(T a, T b, T c, T d) {
    return MathMin(MathMin(MathMin(a, b), c), d);
  }
  template <typename T>
  static T Max(T a, T b) {
    return MathMax(a, b);
  }
  template <typename T>
  static T Max(T a, T b, T c) {
    return MathMax(MathMax(a, b), c);
  }
  template <typename T>
  static T Max(T a, T b, T c, T d) {
    return MathMax(MathMax(MathMax(a, b), c), d);
  }
  template <typename T>
  static T Avg(T a, T b) {
    return (a + b) / 2;
  }
  template <typename T>
  static T Avg(T a, T b, T c) {
    return (a + b + c) / 3;
  }
  template <typename T>
  static T Avg(T a, T b, T c, T d) {
    return (a + b + c + d) / 4;
  }
  template <typename T>
  static T Abs(T a) {
    return MathAbs(a);
  }

  template <typename T>
  static T Op(ENUM_MATH_OP _op, T _val_1, T _val_2 = 0) {
    switch (_op) {
      case MATH_OP_ADD:
        return Add(_val_1, _val_2);
      case MATH_OP_SUB:
        return Sub(_val_1, _val_2);
      case MATH_OP_MUL:
        return Mul(_val_1, _val_2);
      case MATH_OP_DIV:
        return Div(_val_1, _val_2);
      case MATH_OP_SIN:
        return Sin(_val_1);
      case MATH_OP_COS:
        return Cos(_val_2);
      case MATH_OP_TAN:
        return Tang(_val_2);
      case MATH_OP_MIN:
        return Min(_val_1, _val_2);
      case MATH_OP_MAX:
        return Max(_val_1, _val_2);
      case MATH_OP_AVG:
        return Avg(_val_1, _val_2);
      case MATH_OP_RELU:
        return ReLU(_val_1);
      case MATH_OP_ABS:
        return Abs(_val_1);
      case MATH_OP_ABS_DIFF:
        return Abs(_val_1 - _val_2);
      default:
        return EMPTY_VALUE;
    }
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Math.h
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: Math/Stat/Normal.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef MATRIX_MQH
#define MATRIX_MQH

#ifdef USE_MQL_MATH_STAT
#ifdef __MQL5__

#endif
#endif



#define MATRIX_DIMENSIONS 6
#define MATRIX_VALUES_ARRAY_INCREMENT 500

// Forward declarations.
template <typename X>
class MatrixDimension;

template <typename X>
class Matrix;

#define MATRIX_STRIDE_AS_POOL -1

enum ENUM_MATRIX_VECTOR_REDUCE { MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY, MATRIX_VECTOR_REDUCE_HINGE_LOSS };

// Types of matrix pool padding.
// @see https://keras.io/api/layers/pooling_layers/average_pooling2d/
enum ENUM_MATRIX_PADDING {
  // No padding.
  MATRIX_PADDING_VALID,

  // Results in padding evenly to the left/right or up/down of the input such that output has the same height/width
  // dimension as the input.
  MATRIX_PADDING_SAME
};

// Types of matrix dimensions.
enum ENUM_MATRIX_DIMENSION_TYPE {
  MATRIX_DIMENSION_TYPE_UNKNOWN,
  MATRIX_DIMENSION_TYPE_CONTAINERS,
  MATRIX_DIMENSION_TYPE_VALUES
};

// Matrix operation types.
enum ENUM_MATRIX_OPERATION {
  MATRIX_OPERATION_ADD,
  MATRIX_OPERATION_SUBTRACT,
  MATRIX_OPERATION_MULTIPLY,
  MATRIX_OPERATION_DIVIDE,
  MATRIX_OPERATION_ABS,
  MATRIX_OPERATION_FILL,
  MATRIX_OPERATION_FILL_RANDOM,
  MATRIX_OPERATION_FILL_RANDOM_RANGE,
  MATRIX_OPERATION_FILL_POS_ADD,
  MATRIX_OPERATION_FILL_POS_MUL,
  MATRIX_OPERATION_POWER,
  MATRIX_OPERATION_SUM,
  MATRIX_OPERATION_MIN,
  MATRIX_OPERATION_MAX,
  MATRIX_OPERATION_AVG,
  MATRIX_OPERATION_MED,
  MATRIX_OPERATION_POISSON,   // b - a * log(b)
  MATRIX_OPERATION_LOG_COSH,  // log((exp((b-a)) + exp(-(b-a)))/2)
  MATRIX_OPERATION_ABS_DIFF,
  MATRIX_OPERATION_ABS_DIFF_SQUARE,
  MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG,
  MATRIX_OPERATION_RELU,
};

/**
 * Return minimum value of double.
 */
double MinOf(double value) { return -DBL_MAX; }

/**
 * Return minimum value of double.
 */
float MinOf(float value) { return -FLT_MAX; }

/**
 * Return minimum value of integer.
 */
int MinOf(int value) { return INT_MIN; }

/**
 * Return maximum value of double.
 */
double MaxOf(double value) { return DBL_MAX; }

/**
 * Return maximum value of double.
 */
float MaxOf(float value) { return FLT_MAX; }

/**
 * Return minimum value of integer.
 */
int MaxOf(int value) { return INT_MAX; }

/**
 * Matrix's dimension accessor. Used by matrix's index operator.
 */
template <typename X>
struct MatrixDimensionAccessor {
  // Pointer to matrix instance.
  Matrix<X>* ptr_matrix;

  // Pointer to matrix's dimension instance.
  MatrixDimension<X>* ptr_dimension;

  // Index of container or value pointed by accessor.
  int index;

  /**
   * Constructor.
   */
  MatrixDimensionAccessor(Matrix<X>* _ptr_matrix = NULL, MatrixDimension<X>* _ptr_dimension = NULL, int _index = 0)
      : ptr_matrix(_ptr_matrix), ptr_dimension(_ptr_dimension), index(_index) {}

  /**
   * Index operator. Returns container or value accessor.
   */
  MatrixDimensionAccessor<X> operator[](int _index) {
    return MatrixDimensionAccessor(ptr_matrix, ptr_dimension.containers[index], _index);
  }

  /**
   * Returns target dimension type.
   */
  ENUM_MATRIX_DIMENSION_TYPE Type() const { return ptr_dimension.type; }

#define MATRIX_ACCESSOR_OPERATOR(OP)                                                   \
  void operator OP(X _value) {                                                         \
    if (ptr_dimension.type != MATRIX_DIMENSION_TYPE_VALUES) {                          \
      Print("Error: Trying to use matrix", ptr_matrix.Repr(),                          \
            "'s value operator " #OP " in a dimension which doesn't contain values!"); \
      return;                                                                          \
    }                                                                                  \
                                                                                       \
    ptr_dimension.values[index] OP _value;                                             \
  }

  MATRIX_ACCESSOR_OPERATOR(+=)
  MATRIX_ACCESSOR_OPERATOR(-=)
  MATRIX_ACCESSOR_OPERATOR(*=)
  MATRIX_ACCESSOR_OPERATOR(/=)

  /**
   * Assignment operator. Sets value for this dimensions.
   */
  void operator=(X _value) {
    if (ptr_dimension.type != MATRIX_DIMENSION_TYPE_VALUES) {
      Print("Error: Trying to set matrix", ptr_matrix.Repr(), "'s value in a dimension which doesn't contain values!");
      return;
    }

    ptr_dimension.values[index] = _value;
  }

  /**
   * Returns value pointed by this accessor.
   */
  X Val() {
    if (ptr_dimension.type != MATRIX_DIMENSION_TYPE_VALUES) {
      Print("Error: Trying to get value from matrix", ptr_matrix.Repr(), "'s dimension which doesn't contain values!");
      return (X)EMPTY_VALUE;
    }

    return ptr_dimension.values[index];
  }

  /**
   * Returns value pointed by this accessor or first value if it holds only one value or zero if index is above the
   * dimension length.
   */
  X ValOrZero() {
    if (ptr_dimension.type != MATRIX_DIMENSION_TYPE_VALUES) {
      Print("Error: Trying to get value from matrix", ptr_matrix.Repr(), "'s dimension which doesn't contain values!");
      return (X)EMPTY_VALUE;
    }

    int _num_values = ArraySize(ptr_dimension.values);

    if (_num_values == 0 || index >= _num_values) return (X)0;

    return ptr_dimension.values[index];
  }
};

/**
 * A single matrix's dimension. Contains array of containers or values.
 */
template <typename X>
class MatrixDimension {
 public:
  ENUM_MATRIX_DIMENSION_TYPE type;

  // Values array if type is "Values".
  X values[];

  // Physical position of the dimension in the matrix.
  int position[MATRIX_DIMENSIONS - 1];

  // Containers array if type is "Containers"
  MatrixDimension<X>* containers[];

  /**
   * Constructor.
   */
  MatrixDimension(ENUM_MATRIX_DIMENSION_TYPE _type = MATRIX_DIMENSION_TYPE_UNKNOWN) { type = _type; }

  /**
   * Destructor.
   */
  ~MatrixDimension() {
    for (int i = 0; i < ArraySize(containers); ++i) {
      delete containers[i];
    }
  }

  /**
   * Makes a clone of this and child dimensions.
   */
  MatrixDimension<X>* Clone() const {
    MatrixDimension<X>* _clone = new MatrixDimension<X>(type);
    int i;

    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      ArrayResize(_clone.containers, ArraySize(containers));

      for (i = 0; i < ArraySize(containers); ++i) {
        _clone.containers[i] = containers[i].Clone();
      }
    } else {
      ArrayCopy(_clone.values, values);
    }

    return _clone;
  }

  /**
   * Adds container to the list.
   */
  void AddContainer(MatrixDimension* _dimension) {
    ArrayResize(containers, ArraySize(containers) + 1);
    containers[ArraySize(containers) - 1] = _dimension;
  }

  /**
   * Adds value to the list.
   */
  void AddValue(X value) {
    ArrayResize(
        values, ArraySize(values) + 1,
        (ArraySize(values) - ArraySize(values) % MATRIX_VALUES_ARRAY_INCREMENT) + MATRIX_VALUES_ARRAY_INCREMENT);
    values[ArraySize(values) - 1] = value;
  }

  /**
   * Sets physical position of the dimension in the matrix.
   */
  void SetPosition(int& _position[], int _level) {
    for (int i = 0; i < ArraySize(_position); ++i) {
      position[i] = i < _level ? _position[i] : -1;
    }
  }

  string Spaces(int _num) {
    string _padding;
    StringInit(_padding, _num, ' ');
    return _padding;
  }

  string ToString(bool _whitespaces = false, int _precision = 3, int level = 1) {
    string out = "";
    int i;

    if (ArraySize(containers) != 0) {
      out += (_whitespaces ? Spaces((level - 1) * 2) : "") + (_whitespaces ? "[\n" : "[");
      for (i = 0; i < ArraySize(containers); ++i) {
        out += containers[i].ToString(_whitespaces, _precision, level + 1) +
               (i != ArraySize(containers) - 1 ? "," : "") + (_whitespaces ? "\n" : "");
      }
      out += (_whitespaces ? Spaces((level - 1) * 2) : "") + "]";
    } else {
      out += (_whitespaces ? Spaces(level * 2) : "") + (_whitespaces ? "[ " : "[");
      for (i = 0; i < ArraySize(values); ++i) {
        if (values[i] > -MaxOf(values[i]) && values[i] < MaxOf(values[i])) {
          out += DoubleToString((double)values[i], _precision);
        } else {
          out += (values[i] < 0 ? "-inf" : "inf");
        }
        out += (i != ArraySize(values) - 1) ? (_whitespaces ? ", " : ",") : "";
      }
      out += (_whitespaces ? " ]" : "]");
    }

    return out;
  }

  /**
   * Reduces dimension if it contains values. Goes recursively up to _level.
   */
  void ReduceSimple(int _level = 0, ENUM_MATRIX_OPERATION _reduce_op = MATRIX_OPERATION_SUM, int _current_level = 0) {
    int i;
    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS && _current_level <= _level) {
      for (i = 0; i < ArraySize(containers); ++i) {
        containers[i].ReduceSimple(_level, _reduce_op, _current_level + 1);
      }
    }

    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS && ArraySize(containers) > 0 &&
        containers[0].type == MATRIX_DIMENSION_TYPE_VALUES && ArraySize(containers[0].values) == 1) {
      type = MATRIX_DIMENSION_TYPE_VALUES;

      for (i = 0; i < ArraySize(containers); ++i) {
        X _sum = 0;
        for (int k = 0; k < ArraySize(containers[i].values); ++k) {
          _sum += containers[i].values[k];
        }
        AddValue(_sum);
        delete containers[i];
      }

      ArrayResize(containers, 0);
    }
  }

  /**
   * Reduces (aggregates) dimensions up to _level.
   */
  void Reduce(int _level = 0, ENUM_MATRIX_OPERATION _reduce_op = MATRIX_OPERATION_SUM, int _current_level = 0) {
    int i;
    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS && _current_level < _level) {
      for (i = 0; i < ArraySize(containers); ++i) {
        containers[i].Reduce(_level, _reduce_op, _current_level + 1);
      }
    }

    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS && _current_level >= _level) {
      // There will be as many values as containers.
      ArrayResize(values, ArraySize(containers));
      for (i = 0; i < ArraySize(containers); ++i) {
        X _sum = 0;
        X _out1 = 0, _out2;
        int _out3;

        containers[i].Op(_reduce_op, 0, 0, 0, _out1, _out2, _out3);

        values[i] = _out1;

        delete containers[i];
      }

      ArrayResize(containers, 0);
      type = MATRIX_DIMENSION_TYPE_VALUES;
    }
  }

  /**
   * Reduces dimension if it contains values. Goes recursively up to _level.
   * Returns initial dimensions size for the given level.
   */
  int DuplicateDimension(int _level, int _num, int _current_level = 0) {
    int i, k, num_initial_containers = 0;
    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS && _current_level < _level) {
      for (i = 0; i < ArraySize(containers); ++i) {
        num_initial_containers = containers[i].DuplicateDimension(_level, _num, _current_level + 1);
      }
      return num_initial_containers;
    }

    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      num_initial_containers = ArraySize(containers);
      for (i = 0; i < _num; ++i) {
        for (k = 0; k < num_initial_containers; ++k) {
          MatrixDimension<X>* _new_dim = containers[k].Clone();
          AddContainer(_new_dim);
        }
      }

      return num_initial_containers;
    }

    return 0;
  }

  /**
   * Initializes dimension data from another dimension.
   */
  void CopyFrom(MatrixDimension<X>& _r) {
    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      for (int i = 0; i < ArraySize(containers); ++i) {
        containers[i].CopyFrom(_r.containers[i]);
      }
    } else if (type == MATRIX_DIMENSION_TYPE_VALUES) {
      ArrayCopy(values, _r.values);
    }
  }

  /**
   * Resizes this dimension and sets its type (containers or values array).
   */
  virtual void Resize(int _num_items, ENUM_MATRIX_DIMENSION_TYPE _type = MATRIX_DIMENSION_TYPE_VALUES) {
    int i, _last_size;

    if (_type != MATRIX_DIMENSION_TYPE_CONTAINERS) {
      // Removing containers if there's any.
      for (i = 0; i < ArraySize(containers); ++i) {
        delete containers[i];
      }
      ArrayResize(containers, 0);
    }

    if (_type != MATRIX_DIMENSION_TYPE_VALUES) {
      // Removing values.
      ArrayResize(values, 0);
    }

    switch (_type) {
      case MATRIX_DIMENSION_TYPE_CONTAINERS:
        if (type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
          // There already were containers, resizing.
          if (_num_items < ArraySize(containers)) {
            // Deleting not needed containers.
            for (i = _num_items; i < ArraySize(containers); ++i) {
              delete containers[i];
            }
          }
        }
        ArrayResize(containers, _num_items);
        break;

      case MATRIX_DIMENSION_TYPE_VALUES:
        _last_size = ArraySize(values);
        ArrayResize(values, _num_items);
        if (_num_items > _last_size) {
          // Clearing new values.
          ArrayFill(values, _last_size, _num_items - _last_size, (X)0);
        }
        break;
    }

    type = _type;
  }

  /**
   * Initializes dimensions deeply.
   *
   * @todo Allow of resizing containers instead of freeing them firstly.
   */
  static MatrixDimension<X>* SetDimensions(MatrixDimension<X>* _ptr_parent_dimension, int& _dimensions[], int index,
                                           int& _current_position[]) {
    if (_ptr_parent_dimension == NULL) _ptr_parent_dimension = new MatrixDimension();

    if (index == 0 && _dimensions[0] == 0) {
      // Matrix without any dimensions.
      _ptr_parent_dimension.type = MATRIX_DIMENSION_TYPE_VALUES;
    }

    _ptr_parent_dimension.SetPosition(_current_position, index);

    int i;

    if (_dimensions[index + 1] == 0) {
      _ptr_parent_dimension.Resize(_dimensions[index], MATRIX_DIMENSION_TYPE_VALUES);
    } else {
      _ptr_parent_dimension.Resize(_dimensions[index], MATRIX_DIMENSION_TYPE_CONTAINERS);

      for (i = 0; i < _dimensions[index]; ++i) {
        _ptr_parent_dimension.containers[i] =
            SetDimensions(_ptr_parent_dimension.containers[i], _dimensions, index + 1, _current_position);

        ++_current_position[index];
      }
    }

    return _ptr_parent_dimension;
  }

  /**
   * Executes operation on a single value.
   */
  X OpSingle(ENUM_MATRIX_OPERATION _op, X _src = (X)0, X _arg1 = (X)0, X _arg2 = (X)0, X _arg3 = (X)0) {
    int _pos = 0;
    switch (_op) {
      case MATRIX_OPERATION_ABS:
        return MathAbs(_src);
      case MATRIX_OPERATION_ADD:
        return _src + _arg1;
      case MATRIX_OPERATION_SUBTRACT:
        return _src - _arg1;
      case MATRIX_OPERATION_MULTIPLY:
        return _src * _arg1;
      case MATRIX_OPERATION_DIVIDE:
        return _src / _arg1;
        break;
      case MATRIX_OPERATION_FILL:
        return _arg1;
      case MATRIX_OPERATION_FILL_RANDOM:
        if (_arg1 != -1) {
          srand((int)_arg3);
        }
        return -(X)1 + (X)MathRand() / 32767 * 2;
      case MATRIX_OPERATION_FILL_RANDOM_RANGE:
        if (_arg3 != -1) {
          srand((int)_arg3);
        }
        return (X)MathRand() / 32767 * (_arg2 - _arg1) + _arg1;
      case MATRIX_OPERATION_ABS_DIFF:
        return MathAbs(_src - _arg1);
      case MATRIX_OPERATION_ABS_DIFF_SQUARE:
        return (X)pow(MathAbs(_src - _arg1), (X)2);
      case MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG:
        return (X)pow(log(_src + 1) - log(_arg1 + 1), (X)2);
      case MATRIX_OPERATION_POISSON:
        return (X)(_arg1 - _src * log(_arg1));
      case MATRIX_OPERATION_LOG_COSH:
        // log((exp((b-a)) + exp(-(b-a)))/2)
        return (X)log((exp((_arg1 - _src)) + exp(-(_arg1 - _src))) / (X)2);
      case MATRIX_OPERATION_RELU:
        return Math::ReLU(_src);
      default:
        Print("MatrixDimension::OpSingle(): Invalid operation ", EnumToString(_op), "!");
    }

    return (X)0;
  }

  /**
   * Executes operation on all matrix's values.
   */
  void Op(ENUM_MATRIX_OPERATION _op, X _arg1, X _arg2, X _arg3, X& _out1, X& _out2, int& _out3) {
    int i, k;
    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      for (i = 0; i < ArraySize(containers); ++i) {
        containers[i].Op(_op, _arg1, _arg2, _arg3, _out1, _out2, _out3);
      }
    } else {
      for (i = 0; i < ArraySize(values); ++i) {
        switch (_op) {
          case MATRIX_OPERATION_ABS:
          case MATRIX_OPERATION_ADD:
          case MATRIX_OPERATION_SUBTRACT:
          case MATRIX_OPERATION_MULTIPLY:
          case MATRIX_OPERATION_DIVIDE:
          case MATRIX_OPERATION_FILL:
          case MATRIX_OPERATION_FILL_RANDOM:
          case MATRIX_OPERATION_FILL_RANDOM_RANGE:
          case MATRIX_OPERATION_POISSON:
          case MATRIX_OPERATION_LOG_COSH:
          case MATRIX_OPERATION_RELU:
            values[i] = OpSingle(_op, values[i], _arg1, _arg2, _arg3);
            break;
          case MATRIX_OPERATION_FILL_POS_ADD:
            values[i] = 0;
            for (k = 0; k < ArraySize(position); ++k) {
              if (position[k] == -1) {
                break;
              }
              values[i] += (X)position[k];
            }
            values[i] += (X)i;
            break;
          case MATRIX_OPERATION_FILL_POS_MUL:
            values[i] = MinOf((X)0);
            for (k = 0; k < ArraySize(position); ++k) {
              if (position[k] == -1) {
                break;
              }
              values[i] = (values[i] == MinOf((X)0)) ? position[k] : values[i] * position[k];
            }
            values[i] = (values[i] == MinOf((X)0)) ? i : values[i] * i;
            break;
          case MATRIX_OPERATION_POWER:
            values[i] = (X)pow(values[i], _arg1);
            break;
          case MATRIX_OPERATION_SUM:
            _out1 += values[i];
            break;
          case MATRIX_OPERATION_MIN:
            if (values[i] < _out1) {
              _out1 = values[i];
            }
            break;
          case MATRIX_OPERATION_MAX:
            if (values[i] > _out1) {
              _out1 = values[i];
            }
            break;
          case MATRIX_OPERATION_ABS_DIFF:
            values[i] = MathAbs(values[i] - _arg1);
            break;
          default:
            Print("MatrixDimension::Op(): Invalid operation ", EnumToString(_op), "!");
        }
      }
    }
  }

  /**
   * Executes operation on the children containers and values. Used internally.
   */
  void Op(ENUM_MATRIX_OPERATION _op, X _arg1 = (X)0, X _arg2 = (X)0, X _arg3 = (X)0) {
    X _out1, _out2;
    int _out3;

    Op(_op, _arg1, _arg2, _arg3, _out1, _out2, _out3);
  }

  /**
   * Extracts dimensions's values to the given array. Used internally.
   */
  void FillArray(X& array[], int& offset) {
    int i;
    if (type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      for (i = 0; i < ArraySize(containers); ++i) {
        containers[i].FillArray(array, offset);
      }
    } else {
      for (i = 0; i < ArraySize(values); ++i, ++offset) {
        array[offset] = values[i];
      }
    }
  }

  void FromArray(X& _array[], int& offset) {
    int i;
    switch (type) {
      case MATRIX_DIMENSION_TYPE_CONTAINERS:
        for (i = 0; i < ArraySize(containers); ++i) {
          containers[i].FromArray(_array, offset);
        }
        break;
      case MATRIX_DIMENSION_TYPE_VALUES:
        for (i = 0; i < ArraySize(values); ++i, ++offset) {
          values[i] = _array[offset];
        }
        break;
    }
  }

  /**
   * Performs operation between current matrix/tensor and another one of the same or lower level.
   */
  void Op(MatrixDimension<X>* _r, ENUM_MATRIX_OPERATION _op, X _arg1 = (X)0, int _only_value_index = -1) {
    int i;
    bool r_is_single = ArraySize(_r.values) == 1;

    if (_r.type == MATRIX_DIMENSION_TYPE_VALUES && ArraySize(_r.values) == 1) {
      // There is only one value in the right container, we will use that value for all operations.
      _only_value_index = 0;
    }

    switch (type) {
      case MATRIX_DIMENSION_TYPE_CONTAINERS:
        switch (_r.type) {
          case MATRIX_DIMENSION_TYPE_CONTAINERS:
            // Both dimensions have containers.
            for (i = 0; i < ArraySize(containers); ++i) {
              containers[i].Op(_r.containers[ArraySize(_r.containers) == 1 ? 0 : i], _op, _arg1);
            }
            break;
          case MATRIX_DIMENSION_TYPE_VALUES:
            // Left dimension have containers, but right dimension have values.
            for (i = 0; i < ArraySize(containers); ++i) {
              // If there is only a single value in the right dimension, use it for all operations inside current
              // container.
              containers[i].Op(_r, _op, _arg1, _only_value_index != -1 ? _only_value_index : i);
            }
            break;
        }
        break;
      case MATRIX_DIMENSION_TYPE_VALUES:
        switch (_r.type) {
          case MATRIX_DIMENSION_TYPE_CONTAINERS:
            // Right dimension have containers.
            if (ArraySize(_r.containers) != 1) {
              Alert("Right container must have exactly one element!");
              return;
            }

            Op(_r.containers[0], _op, _arg1);
            break;

          case MATRIX_DIMENSION_TYPE_VALUES:
            // Left and right dimensions have values or we use single right value.
            for (i = 0; i < ArraySize(values); ++i) {
              values[i] = OpSingle(_op, values[i], _r.values[_only_value_index != -1 ? _only_value_index : i]);
            }

            break;
        }
        break;
    }
  }
};

/**
 * Matrix class.
 */
template <typename X>
class Matrix {
 public:
  // First/root dimension.
  MatrixDimension<X>* ptr_first_dimension;

  // Array with declaration of items per matrix's dimension.
  int dimensions[MATRIX_DIMENSIONS];

  // Current size of the matrix (all dimensions multiplied).
  int size;

  // Number of matrix dimensions.
  int num_dimensions;

  /**
   * Constructor.
   */
  Matrix(string _data) { FromString(_data); }

  /**
   * Constructor.
   */
  Matrix(const int num_1d = 0, const int num_2d = 0, const int num_3d = 0, const int num_4d = 0, const int num_5d = 0) {
    ptr_first_dimension = NULL;
    SetShape(num_1d, num_2d, num_3d, num_4d, num_5d);
  }

  /**
   * Constructor.
   */
  Matrix(MatrixDimension<X>* _dimension) : ptr_first_dimension(NULL) { Initialize(_dimension); }

  /**
   * Copy constructor.
   */
  Matrix(const Matrix<X>& _right) {
    if (_right.ptr_first_dimension == NULL) {
      return;
    }

    Initialize(_right.ptr_first_dimension.Clone());
  }

  /**
   * Private copy constructor. We don't want to assign Matrix via pointer due to memory leakage.
   */

 private:
  Matrix(const Matrix<X>* _right) {}

 public:
  /**
   * Matrix initializer.
   */
  void Initialize(MatrixDimension<X>* _dimension) {
    if (ptr_first_dimension != NULL) delete ptr_first_dimension;

    ptr_first_dimension = _dimension;
    // Calculating dimensions.
    int i;

    for (i = 0; i < MATRIX_DIMENSIONS; ++i) {
      dimensions[i] = 0;
    }

    for (i = 0; i < MATRIX_DIMENSIONS; ++i) {
      if (_dimension == NULL) break;

      if (_dimension.type == MATRIX_DIMENSION_TYPE_CONTAINERS) {
        dimensions[i] = ArraySize(_dimension.containers);
        _dimension = _dimension.containers[0];
      } else if (_dimension.type == MATRIX_DIMENSION_TYPE_VALUES) {
        dimensions[i++] = ArraySize(_dimension.values);
        break;
      } else {
        Print("Internal error: unknown dimension type!");
      }
    }

    num_dimensions = i;

    RecalculateSize();
  }

  void RecalculateSize() {
    size = 0;

    for (int i = 0; i < ArraySize(dimensions); ++i) {
      if (dimensions[i] != 0) {
        if (size == 0) {
          size = 1;
        }

        size *= dimensions[i];
      }
    }
  }

  /**
   * Assignment operator.
   */
  void operator=(const Matrix<X>& _right) { Initialize(_right.ptr_first_dimension.Clone()); }

  /**
   * Assignment operator. Initializes matrix using given dimension.
   */
  Matrix(MatrixDimensionAccessor<X>& accessor) {
    if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      Initialize(accessor.ptr_dimension.containers[accessor.index].Clone());
    } else if (accessor.Type() == MATRIX_DIMENSION_TYPE_VALUES) {
      SetShape(1);
      this[0] = accessor.Val();
    }
  }

  /**
   * Assignment operator.
   */
  void operator=(string _data) { FromString(_data); }

  /**
   * Destructor.
   */
  ~Matrix() {
    if (ptr_first_dimension != NULL) {
      delete ptr_first_dimension;
    }
  }

  /**
   * Index operator. Returns container or value accessor.
   */
  MatrixDimensionAccessor<X> operator[](int index) {
    MatrixDimensionAccessor<X> accessor(&this, ptr_first_dimension, index);
    return accessor;
  }

  /**
   * Sets or changes matrix's dimensions.
   */
  void SetShape(const int num_1d = 0, const int num_2d = 0, const int num_3d = 0, const int num_4d = 0,
                const int num_5d = 0) {
    dimensions[0] = num_1d;
    dimensions[1] = num_2d;
    dimensions[2] = num_3d;
    dimensions[3] = num_4d;
    dimensions[4] = num_5d;
    dimensions[5] = 0;

    int _current_position[] = {0, 0, 0, 0};

    ptr_first_dimension = MatrixDimension<X>::SetDimensions(ptr_first_dimension, dimensions, 0, _current_position);

    // Calculating size.
    size = 0;

    num_dimensions = (num_1d != 0 ? 1 : 0) + (num_2d != 0 ? 1 : 0) + (num_3d != 0 ? 1 : 0) + (num_4d != 0 ? 1 : 0) +
                     (num_5d != 0 ? 1 : 0);

    // Calculating size.
    for (int i = 0; i < MATRIX_DIMENSIONS; ++i) {
      if (dimensions[i] != 0) {
        if (size == 0) {
          size = 1;
        }

        size *= dimensions[i];
      }
    }
  }

  /**
   * Returns length of the given dimension.
   */
  int GetRange(int _dimension) {
    if (_dimension >= MATRIX_DIMENSIONS) {
      Print("Matrix::GetRange(): Dimension should be between 0 and ", MATRIX_DIMENSIONS - 1, ". Got ", _dimension, "!");
      return -1;
    }

    return dimensions[_dimension];
  }

  /**
   * Returns total number of values the matrix contain of.
   */
  int GetSize() { return size; }

  /**
   * Returns number of matrix dimensions.
   */
  int GetDimensions() { return num_dimensions; }

  void DuplicateDimension(int _level, int _num, int _current_level = 0) {
    if (_num < 1) {
      return;
    }

    if (_level >= GetDimensions()) {
      return;
    }

    int initial_container_size = ptr_first_dimension.DuplicateDimension(_level, _num);
    dimensions[_level] += _num * initial_container_size;
    RecalculateSize();
  }

  /**
   * Returns value at the given position.
   */
  X GetValue(int _pos_1d, int _pos_2d = -1, int _pos_3d = -1, int _pos_4d = -1, int _pos_5d = -1) {
    MatrixDimensionAccessor<X> accessor = this[_pos_1d];

    if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      accessor = accessor[_pos_2d];
      if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
        accessor = accessor[_pos_3d];
        if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
          accessor = accessor[_pos_4d];
          if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
            Alert("Matrix::GetValue(): Internal error. Last dimensions shouldn't be a container!");
          }
        }
      }
    }

    return accessor.Val();
  }

  /**
   * Returns value at the given position (or parent one for missing dimensions, or zero for missing indices).
   */
  X GetValueLossely(int _source_dimensions, int _pos_1d, int _pos_2d = -1, int _pos_3d = -1, int _pos_4d = -1,
                    int _pos_5d = -1) {
    int _shift_dimensions = _source_dimensions - GetDimensions();

    while (_shift_dimensions-- > 0) {
      _pos_1d = _pos_2d;
      _pos_2d = _pos_3d;
      _pos_3d = _pos_4d;
      _pos_4d = _pos_5d;
      _pos_5d = 0;
    }

    if (GetDimensions() < 1) return 0;

    MatrixDimensionAccessor<X> accessor;

    if (_pos_1d >= dimensions[0]) {
      if (dimensions[0] == 1)
        _pos_1d = 0;
      else
        return 0;
    }

    accessor = this[_pos_1d];

    // Returning prematurely if we experienced value instead of a container.
    if (accessor.Type() == MATRIX_DIMENSION_TYPE_VALUES) return accessor.Val();

    if (_pos_2d >= dimensions[1]) {
      if (dimensions[1] == 1)
        _pos_2d = 0;
      else
        return 0;
    }

    accessor = accessor[_pos_2d];

    // Returning prematurely if we experienced value instead of a container.
    if (accessor.Type() == MATRIX_DIMENSION_TYPE_VALUES) return accessor.Val();

    if (_pos_3d >= dimensions[2]) {
      if (dimensions[2] == 1)
        _pos_3d = 0;
      else
        return 0;
    }

    accessor = accessor[_pos_3d];

    // Returning prematurely if we experienced value instead of a container.
    if (accessor.Type() == MATRIX_DIMENSION_TYPE_VALUES) return accessor.Val();

    if (_pos_4d >= dimensions[3]) {
      if (dimensions[3] == 1)
        _pos_4d = 0;
      else
        return 0;
    }

    accessor = accessor[_pos_4d];

    // Returning prematurely if we experienced value instead of a container.
    if (accessor.Type() == MATRIX_DIMENSION_TYPE_VALUES) return accessor.Val();

    if (_pos_5d >= dimensions[4]) {
      if (dimensions[4] == 1)
        _pos_5d = 0;
      else
        return 0;
    }

    accessor = accessor[_pos_5d];

    // Returning prematurely if we experienced value instead of a container.
    if (accessor.Type() == MATRIX_DIMENSION_TYPE_VALUES) return accessor.Val();

    Alert("Matrix::GetValueLossely(): Internal error. Last dimensions shouldn't be a container!");

    return 0;
  }

  /**
   * Returns values at the given position.
   */
  void SetValue(X _value, int _pos_1d, int _pos_2d = -1, int _pos_3d = -1, int _pos_4d = -1, int _pos_5d = -1) {
    MatrixDimensionAccessor<X> accessor = this[_pos_1d];

    if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
      accessor = accessor[_pos_2d];
      if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
        accessor = accessor[_pos_3d];
        if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
          accessor = accessor[_pos_4d];
          if (accessor.Type() == MATRIX_DIMENSION_TYPE_CONTAINERS) {
            Alert("Matrix::GetValue(): Internal error. Last dimensions shouldn't be a container!");
          }
        }
      }
    }

    accessor = _value;
  }

  /**
   * Increments all existing matrix's values by given one.
   */
  void operator+=(X value) { Add(value); }

  /**
   * Makes all values absolute (negatives becomes positive).
   */
  void Abs() {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_ABS);
    }
  }

  /**
   * Increments all existing matrix's values by given one.
   */
  void Add(X value) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_ADD, value);
    }
  }

  /**
   * Decrements all existing matrix's values by given one.
   */
  void operator-=(X value) { Sub(value); }

  /**
   * Decrements all existing matrix's values by given one.
   */
  void Sub(X value) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_SUBTRACT, value);
    }
  }

  /**
   * Multiplies all existing matrix's values by given one.
   */
  void operator*=(X value) { Mul(value); }

  /**
   * Multiplies all existing matrix's values by given one.
   */
  void Mul(X value) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_MULTIPLY, value);
    }
  }

  /**
   * Divides all existing matrix's values by given one.
   */
  void operator/=(X value) { Div(value); }

  /**
   * Divides all existing matrix's values by given one.
   */
  void Div(X value) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_DIVIDE, value);
    }
  }

  /**
   * Replaces all matrix's values by given one.
   */
  void Fill(X value) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_FILL, value);
    }
  }

  /**
   * Replaces existing matrix's values by random one (-1.0 - 1.0).
   */
  void FillRandom(int _seed = -1) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_FILL_RANDOM, _seed);
    }
  }

  /**
   * Replaces existing matrix's values by random value from a given range.
   */
  void FillRandom(X _start, X _end, int _seed = -1) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_FILL_RANDOM_RANGE, _start, _end, _seed);
    }
  }

  /**
   * Fills matrix with values which are sum of all the matrix coordinates.
   */
  void FillPosAdd() {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_FILL_POS_ADD);
    }
  }

  /**
   * Fills matrix with values which are multiply of all the matrix coordinates.
   */
  void FillPosMul() {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_FILL_POS_MUL);
    }
  }

  /**
   * Replaces existing matrix's values by random value from a given range.
   */
  X Sum() {
    X _out1 = 0, _out2;
    int _out3;
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_SUM, 0, 0, 0, _out1, _out2, _out3);
    }
    return _out1;
  }

  /**
   * Calculates the lowest value in the whole matrix.
   */
  X Min() {
    X _out1 = MaxOf((X)0), _out2;
    int _out3;
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_MIN, 0, 0, 0, _out1, _out2, _out3);
    }
    return _out1;
  }

  /**
   * Calculates the lowest value in the whole matrix.
   */
  X Max() {
    X _out1 = MinOf((X)0), _out2;
    int _out3;
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_MAX, 0, 0, 0, _out1, _out2, _out3);
    }
    return _out1;
  }

  /**
   * Calculates the average value in the whole matrix.
   */
  X Avg() {
    X _out1 = 0, _out2;
    int _out3;
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_SUM, 0, 0, 0, _out1, _out2, _out3);
      return GetSize() > 0 ? _out1 / GetSize() : 0;
    }
    return MinOf((X)0);
  }

  void Power(X value) {
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_POWER, value);
    }
  }

  /**
   * Calculates median of the matrix values.
   */
  X Med() {
    if (ptr_first_dimension) {
      X array[];
      GetRawArray(array);
      ArraySort(array);

      double median;

      int len = ArraySize(array);

      if (len % 2 == 0)
        median = (array[len / 2] + array[(len / 2) - 1]) / 2;
      else
        median = array[len / 2];

      return (X)median;
    }
    return MinOf((X)0);
  }

  static void MatMul(Matrix<X>& source, Matrix<X>& target, Matrix<X>& output) {
    if (source.GetSize() != target.GetRange(1)) {
      Alert("Inconsistent size of matrices!");
    }

    int num_outputs = target.GetRange(0);
    int num_inputs = target.GetRange(1);

    output.SetShape(num_outputs);

    for (int output_idx = 0; output_idx < num_outputs; ++output_idx) {
      output[output_idx] = 0;
      for (int input_idx = 0; input_idx < num_inputs; ++input_idx) {
        output[output_idx] += source[input_idx].Val() * target[output_idx][input_idx].Val();
      }
    }
  }

  /**
   * Performs matrix multiplication.
   */
  Matrix<X>* MatMul(Matrix<X>& target) {
    Matrix<X>* output = new Matrix<X>();
    MatMul(this, target, output);
    return output;
  }

  /**
   * Performs matrix multiplication.
   */
  Matrix<X>* operator^(Matrix<X>& target) { return MatMul(target); }

  /**
   * Performs in-place matrix multiplication.
   */
  void operator^=(Matrix<X>& target) {
    Matrix<X> result;
    MatMul(this, target, result);
    this = result;
  }

  /**
   * Matrix-matrix addition operator.
   */
  Matrix<X>* operator+(const Matrix<X>& r) {
    Matrix<X>* result = Clone();

    if (result.ptr_first_dimension) {
      result.ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_ADD);
    }

    return result;
  }

  /**
   * Matrix-matrix inplace addition operator.
   */
  void operator+=(const Matrix<X>& r) {
    if (ptr_first_dimension && r.ptr_first_dimension) {
      ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_ADD);
    }
  }

  /**
   * Matrix-matrix subtraction operator.
   */
  Matrix<X>* operator-(const Matrix<X>& r) {
    Matrix<X>* result = Clone();

    if (result.ptr_first_dimension) {
      result.ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_SUBTRACT);
    }

    return result;
  }

  /**
   * Matrix-matrix inplace subtraction operator.
   */
  void operator-=(const Matrix<X>& r) {
    if (ptr_first_dimension && r.ptr_first_dimension) {
      ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_SUBTRACT);
    }
  }

  /**
   * Matrix-matrix multiplication operator.
   */
  Matrix<X>* operator*(const Matrix<X>& r) {
    Matrix<X>* result = Clone();

    if (result.ptr_first_dimension) {
      result.ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_MULTIPLY);
    }

    return result;
  }

  /**
   * Matrix-matrix inplace multiplication operator.
   */
  void operator*=(const Matrix<X>& r) {
    if (ptr_first_dimension && r.ptr_first_dimension) {
      ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_MULTIPLY);
    }
  }

  /**
   * Matrix-matrix division operator.
   */
  Matrix<X>* operator/(const Matrix<X>& r) {
    Matrix<X>* result = Clone();

    if (result.ptr_first_dimension) {
      result.ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_DIVIDE);
    }

    return result;
  }

  /**
   * Matrix-matrix inplace division operator.
   */
  void operator/=(const Matrix<X>& r) {
    if (ptr_first_dimension && r.ptr_first_dimension) {
      ptr_first_dimension.Op(r.ptr_first_dimension, MATRIX_OPERATION_DIVIDE);
    }
  }

  /**
   * Fills array with all values from the matrix.
   */
  void GetRawArray(X& array[]) {
    ArrayResize(array, GetSize());
    int offset = 0;
    ptr_first_dimension.FillArray(array, offset);
  }

  /**
   * Flattens matrix.
   */
  Matrix<X>* Flatten() {
    X values[];

    GetRawArray(values);

    Matrix<X>* result = new Matrix<X>(ArraySize(values));

    for (int i = 0; i < ArraySize(values); ++i) {
      result[i] = values[i];
    }

    return result;
  }

  /**
   * Initializer that generates tensors with a uniform distribution.
   */
  void FillRandomUniform(X _min, X _max, int _seed = -1) { FillRandom(_min, _max, _seed); }

#ifdef USE_MQL_MATH_STAT
  /**
   * Initializer that generates tensors with a normal distribution.
   */
  void FillRandomNormal(X _mean, X _stddev, int _seed = -1) {
#ifdef __MQL5__
    if (_seed != -1) {
      Print("Matrix::FillRandomNormal(): _seed parameter is not yet implemented! Please use -1 as _seed.");
    }

    double _values[];
    MathRandomNormal(_mean, _stddev, GetSize(), _values);
    FillFromArray(_values);
#else
    Print("Matrix::FillRandomNormal() is implemented only in MQL5!");
#endif
  }
#endif

  void FillFromArray(X& _array[]) {
    if (ArraySize(_array) != GetSize()) {
      Print("Matrix::FillFromArray(): input array (", ArraySize(_array), " elements) must be the same size as matrix (",
            GetSize(), " elements)!");
    }

    int offset = 0;
    ptr_first_dimension.FromArray(_array, offset);
  }

  /**
   * Initializer that generates a truncated normal distribution.
   */
  void FillTruncatedNormal(X _mean, X _stddev, int _seeds = -1) {
    Print("Matrix::FillTruncatedNormal() is not yet implemented!");
  }

  /**
   * The Glorot normal initializer, also called Xavier normal initializer.
   */
  void FillGlorotNormal(int _seed = -1) { Print("Matrix::FillGlorotNormal() is not yet implemented!"); }

  /**
   * The Glorot uniform initializer, also called Xavier uniform initializer.
   */
  void FillGlorotUniform(int _seed = -1) { Print("Matrix::FillGlorotUniform() is not yet implemented!"); }

  /**
   * Initializer that generates the identity matrix.
   */
  void FillIdentity(X _gain = (X)1) {
    if (GetDimensions() != 2) {
      Print("Matrix::FillIdentity() has no sense in the non-2d matrix!");
      return;
    }
    if (GetRange(0) != GetRange(1)) {
      Print("Matrix::FillIdentity(): Both dimensions should have exact size! Passed ", Repr(), ".");
      return;
    }
    Fill(0);
    for (int i = 0; i < GetRange(0); ++i) {
      this[i][i] = _gain;
    }
  }

  /**
   * Initializer that generates an orthogonal matrix.
   */
  void FillOrthogonal(X _gain, int _seed = -1) { Print("Matrix::FillOrthogonal() is not yet implemented!"); }

  /**
   * Calculates absolute difference between this tensor and given one using optional weights tensor.
   */
  Matrix<X>* Mean(ENUM_MATRIX_OPERATION _abs_diff_op, ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _prediction,
                  Matrix<X>* _weights = NULL) {
    switch (_abs_diff_op) {
      case MATRIX_OPERATION_ABS_DIFF:
      case MATRIX_OPERATION_ABS_DIFF_SQUARE:
      case MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG:
        break;
      default:
        Print("Mean(): Unsupported absolute difference operator: ", EnumToString(_abs_diff_op), "!");
    }

    if (!ShapeCompatible(&this, _prediction)) {
      Print("MeanAbsolute(): Shape ", Repr(), " is not compatible with prediction shape ", _prediction.Repr(), "!");
      return NULL;
    }

    if (_weights != NULL && _weights.GetDimensions() > this.GetDimensions()) {
      Print("MeanAbsolute(): Shape ", Repr(), ": Weights must be a tensor level <= ", this.GetDimensions(), "!");
      return NULL;
    }

    Matrix<X>*_matrix, *_pooled;

    // We'll be working on copy of the current tensor.
    _matrix = Clone();

    // Calculating absolute difference between copied tensor and given prediction.
    _matrix.ptr_first_dimension.Op(_prediction.ptr_first_dimension, _abs_diff_op);

    switch (_abs_diff_op) {
      case MATRIX_OPERATION_ABS_DIFF_SQUARE:
      case MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG:
        // Reducing values of the last dimension of the matrix.
        _pooled = _matrix.GetPooled(_reduction, MATRIX_PADDING_SAME, dimensions[1] == 0 ? dimensions[0] : 1,
                                    dimensions[2] == 0 ? dimensions[1] : 1, dimensions[3] == 0 ? dimensions[2] : 1,
                                    dimensions[4] == 0 ? dimensions[3] : 1, dimensions[5] == 0 ? dimensions[4] : 1);

        // Physically reducing last dimension of the matrix.
        _pooled.ReduceSimple();
        delete _matrix;
        _matrix = _pooled;
        break;
    }

    if (_weights != NULL) {
      // Multiplying copied tensor by given weights. Note that weights tensor could be of lower level than original
      // tensor.
      _matrix.ptr_first_dimension.Op(_weights.ptr_first_dimension, MATRIX_OPERATION_MULTIPLY);
    }

    return _matrix;
  }

  /**
   * Reduces single or all dimensions containing only a single value.
   */
  void ReduceSimple(bool _only_last_dimension = true, ENUM_MATRIX_OPERATION _reduce_op = MATRIX_OPERATION_SUM) {
    if (ptr_first_dimension != NULL) {
      ptr_first_dimension.ReduceSimple(_only_last_dimension ? GetDimensions() - 1 : 0, _reduce_op);
    }
  }

  void Reduce(int _level = 0, ENUM_MATRIX_OPERATION _reduce_op = MATRIX_OPERATION_SUM) {
    if (ptr_first_dimension == NULL) {
      return;
    }

    ptr_first_dimension.Reduce(_level, _reduce_op);

    for (int i = _level + 1; i < MATRIX_DIMENSIONS; ++i) {
      dimensions[i] = 0;
    }

    RecalculateSize();
  }

  /**
   * Computes the Poisson loss
   */
  Matrix<X>* Poisson(Matrix<X>* _prediction) {
    if (ptr_first_dimension == NULL) {
      return NULL;
    }
    Matrix<X>* _clone = Clone();
    _clone.ptr_first_dimension.Op(_prediction.ptr_first_dimension, MATRIX_OPERATION_POISSON);
    return _clone;
  }

  /**
   * Reduces matrix using vector math.
   *
   * Use _dimension = -1 for last dimension.
   *
   * @todo Support multiple dimensions for reduction.
   */
  Matrix<X>* VectorReduce(Matrix<X>* _product, ENUM_MATRIX_VECTOR_REDUCE _reduce, int _dimension = 0) {
    if (_dimension == -1) _dimension = GetDimensions() - 1;

    if (!ShapeCompatibleLossely(&this, _product)) {
      // Alert("VectorReduce(): Incompatible shapes: ", Repr(), " and ", _product.Repr(), "!");
      // return NULL;
    }

    int i, k, _index[] = {0, 0, 0, 0, 0, 0, 0};

    // Preparing dimension indices.
    for (i = 0; i < MATRIX_DIMENSIONS; ++i) {
      if (dimensions[i] == 0) break;

      _index[i] = 0;
    }

    int _out_dims[MATRIX_DIMENSIONS] = {0, 0, 0, 0, 0};
    int _out_index[MATRIX_DIMENSIONS] = {0, 0, 0, 0, 0};

    // Calculating output matrix dimensions.
    for (i = 0, k = 0; i < GetDimensions(); ++i) {
      if (i != _dimension) {
        _out_dims[k++] = dimensions[i];
      }
    }

    Matrix<X>* _ptr_result = new Matrix<X>(_out_dims[0], _out_dims[1], _out_dims[2], _out_dims[3], _out_dims[4]);

    int _curr_dimension = 0;
    bool _stop = false;

    while (!_stop) {
      X _dot = 0, _mag1 = 0, _mag2 = 0;

      for (i = 0, k = 0; i < GetDimensions(); ++i) {
        if (i != _dimension) {
          _out_index[k++] = _index[i];
        }
      }

      X _aux1 = 0, _aux2 = 0, _aux3 = 0, _aux4 = 0;
      int _aux5 = 0;

      // Taking one group at a time.
      for (int b = 0; b < dimensions[_dimension]; ++b) {
        X _value_a = GetValue(_index[0], _index[1], _index[2], _index[3], _index[4]);
        X _value_b = _product.GetValueLossely(GetDimensions(), _index[0], _index[1], _index[2], _index[3], _index[4]);

        switch (_reduce) {
          case MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY:
            // Dot.
            _aux1 += _value_a * _value_b;
            // Mag1.
            _aux2 += _value_a * _value_a;
            // Mag2.
            _aux3 += _value_b * _value_b;
            break;

          case MATRIX_VECTOR_REDUCE_HINGE_LOSS:
            // Sum.
            _aux1 += MathMax(0, 1 - _value_a * _value_b);
            // Counter.
            _aux5 += 1;
            break;
        }

        ++_index[_dimension];
      }

      _index[_dimension] = 0;

      X _res = 0;

      switch (_reduce) {
        case MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY:
          _res = (X)(_aux1 / (sqrt(_aux2) * sqrt(_aux3)));
          break;

        case MATRIX_VECTOR_REDUCE_HINGE_LOSS:
          // Res = Sum / Count.
          _res = _aux1 / _aux5;
          break;
      }

      _ptr_result.SetValue(_res, _out_index[0], _out_index[1], _out_index[2], _out_index[3], _out_index[4]);

      if (_dimension == 0)
        ++_index[1];
      else
        ++_index[0];

      for (k = 0; k < GetDimensions(); ++k) {
        if (_index[k] >= dimensions[k]) {
          if (k >= GetDimensions() - 1) {
            // No more dimensions.
            _stop = true;
            break;
          }

          _index[k] = 0;

          if (k + 1 == _dimension) {
            if (_dimension == GetDimensions() - 1) {
              // Incrementing last dimension have no sense, stopping.
              _stop = true;
              break;
            }
            ++_index[k + 2];
          } else
            ++_index[k + 1];
        }
      }
    }

    return _ptr_result;
  }

  Matrix<X>* CosineSimilarity(Matrix<X>* _product, int _dimension = 0) {
    return VectorReduce(_product, MATRIX_VECTOR_REDUCE_COSINE_SIMILARITY, _dimension);
  }

  Matrix<X>* HingeLoss(Matrix<X>* _product) { return VectorReduce(_product, MATRIX_VECTOR_REDUCE_HINGE_LOSS, -1); }

  /**
   * Calculates absolute difference between this tensor and given one using optional weights tensor.
   */
  Matrix<X>* MeanAbsolute(Matrix<X>* _prediction, ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _weights = NULL) {
    return Mean(MATRIX_OPERATION_ABS_DIFF, _reduction, _prediction, _weights);
  }

  /**
   * Calculates squared absolute difference between this tensor and given one using optional weights tensor.
   */
  Matrix<X>* MeanSquared(Matrix<X>* _prediction, ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _weights = NULL) {
    return Mean(MATRIX_OPERATION_ABS_DIFF_SQUARE, _reduction, _prediction, _weights);
  }

  /**
   * Calculates logarithmic squared absolute difference between this tensor and given one using optional weights tensor.
   */
  Matrix<X>* MeanSquaredLogarithmic(Matrix<X>* _prediction, ENUM_MATRIX_OPERATION _reduction,
                                    Matrix<X>* _weights = NULL) {
    return Mean(MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG, _reduction, _prediction, _weights);
  }

  /**
   * Calculates mean absolute using given reduction operation and optionally, weights tensor.
   */
  X MeanReduced(ENUM_MATRIX_OPERATION _abs_diff_op, ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _prediction,
                Matrix<X>* _weights = NULL) {
    Matrix<X>* _diff = Mean(_abs_diff_op, _reduction, _prediction, _weights);

    X result;

    switch (_reduction) {
      case MATRIX_OPERATION_SUM:
        result = _diff.Sum();
        break;
      case MATRIX_OPERATION_MIN:
        result = _diff.Min();
        break;
      case MATRIX_OPERATION_MAX:
        result = _diff.Max();
        break;
      case MATRIX_OPERATION_AVG:
        result = _diff.Avg();
        break;
      case MATRIX_OPERATION_MED:
        result = _diff.Med();
        break;
      default:
        Print("MeanAbsolute(): Unsupported reduction type: ", EnumToString(_reduction), "!");
        return MinOf((X)0);
    }

    delete _diff;

    return result;
  }

  /**
   * Calculates mean absolute using given reduction operation and optionally, weights tensor.
   */
  X MeanAbsolute(ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _prediction, Matrix<X>* _weights = NULL) {
    return MeanReduced(MATRIX_OPERATION_ABS_DIFF, _reduction, _prediction, _weights);
  }

  /**
   * Calculates squared mean absolute using given reduction operation and optionally, weights tensor.
   */
  X MeanSquared(ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _prediction, Matrix<X>* _weights = NULL) {
    return MeanReduced(MATRIX_OPERATION_ABS_DIFF_SQUARE, _reduction, _prediction, _weights);
  }

  /**
   * Calculates logarithmic squared mean absolute using given reduction operation and optionally, weights tensor.
   */
  X MeanSquaredLogarithmic(ENUM_MATRIX_OPERATION _reduction, Matrix<X>* _prediction, Matrix<X>* _weights = NULL) {
    return MeanReduced(MATRIX_OPERATION_ABS_DIFF_SQUARE_LOG, _reduction, _prediction, _weights);
  }

  /**
   * ReLU activator.
   */
  Matrix<X>* Relu() {
    Matrix<X>* result = Clone();
    result.Relu_();
    return result;
  }

  /**
   * Inplace ReLU activator.
   */
  void Relu_() {
    X _out1 = 0, _out2;
    int _out3;
    if (ptr_first_dimension) {
      ptr_first_dimension.Op(MATRIX_OPERATION_RELU, 0, 0, 0, _out1, _out2, _out3);
    }
  }

  /**
   * Clones current matrix.
   */
  Matrix<X>* Clone() const {
    Matrix<X>* _cloned = new Matrix<X>(dimensions[0], dimensions[1], dimensions[2], dimensions[3], dimensions[4]);
    _cloned.ptr_first_dimension.CopyFrom(ptr_first_dimension);
    return _cloned;
  }

  /**
   * Sets value of the given matrix's dimension.
   *
   * @todo Deep version of this method.
   */

  void Set(X value, const int _1d, const int _2d = -1, const int _3d = -1, const int _4d = -1, const int _5d = -1) {
    if (_2d == -1) {
      this[_1d] = value;
    } else if (_3d == -1) {
      this[_1d][_2d] = value;
    } else if (_4d == -1) {
      this[_1d][_2d][_3d] = value;
    } else if (_5d == -1) {
      this[_1d][_2d][_3d][_4d] = value;
    } else {
      this[_1d][_2d][_3d][_4d][_5d] = value;
    }
  }

  Matrix<X>* GetConv2d(int _in_channels, int _out_channels, int _krn_1d, int _krn_2d,
                       int _stride_1d = MATRIX_STRIDE_AS_POOL, int _stride_2d = MATRIX_STRIDE_AS_POOL,
                       Matrix<X>* _weights = NULL) {
    if (dimensions[0] < _in_channels) {
      Alert("Insufficient number of channels in the input. First dimensions should have ", _in_channels,
            " arrays, got ", dimensions[0]);
      return NULL;
    }

    Matrix<X>* clone = Clone();

    clone.DuplicateDimension(1, _out_channels - 1);

    if (_weights != NULL) {
      Matrix<X>* weight_flattened = _weights.Flatten();
      for (int _in_channel_idx = 0; _in_channel_idx < _in_channels; ++_in_channel_idx) {
        clone.ptr_first_dimension.containers[_in_channel_idx].Op(weight_flattened.ptr_first_dimension,
                                                                 MATRIX_OPERATION_MULTIPLY);
      }
      delete weight_flattened;
    }

    Matrix<X>* pooled =
        clone.GetPooled(MATRIX_OPERATION_SUM, MATRIX_PADDING_VALID, 1, 2, _krn_1d, _krn_2d, 0,  // Kernel size.
                        1, 2, _stride_1d, _stride_2d);

    delete clone;
    return pooled;
  }

  static void GetPooledSize(ENUM_MATRIX_PADDING _padding, int _dim_1d, int _dim_2d, int _dim_3d, int _dim_4d,
                            int _dim_5d, int _pool_1d, int _pool_2d, int _pool_3d, int _pool_4d, int _pool_5d,
                            int _stride_1d, int _stride_2d, int _stride_3d, int _stride_4d, int _stride_5d,
                            int& _out_1d, int& _out_2d, int& _out_3d, int& _out_4d, int& _out_5d) {
    // Calculating resulting matrix required sizes per dimension.

#define _MATRIX_CHECK_POOL_AND_STRIDE(num)                 \
  if (_pool_##num##d == 0) _pool_##num##d = _dim_##num##d; \
  if (_stride_##num##d == MATRIX_STRIDE_AS_POOL)           \
    _stride_##num##d = _pool_##num##d;                     \
  else if (_stride_##num##d == 0) {                        \
    _stride_##num##d = 1;                                  \
  }

    _MATRIX_CHECK_POOL_AND_STRIDE(1);
    _MATRIX_CHECK_POOL_AND_STRIDE(2);
    _MATRIX_CHECK_POOL_AND_STRIDE(3);
    _MATRIX_CHECK_POOL_AND_STRIDE(4);
    _MATRIX_CHECK_POOL_AND_STRIDE(5);

    if (_padding == MATRIX_PADDING_VALID) {
      _out_1d = _stride_1d > 0 ? int(MathCeil(((X)_dim_1d - _pool_1d + 1) / _stride_1d))
                               : 0;  // (3 - z2 + 1) / 2  =  Ceil(1)    = 1
      _out_2d = _out_1d == 0 ? 0
                             : (_stride_2d > 0 ? int(MathCeil(((X)_dim_2d - _pool_2d + 1) / _stride_2d))
                                               : 0);  // (2 - 2 + 1) / 2  =  Ceil(0.5)  = 1
      _out_3d = _out_2d == 0 ? 0 : (_stride_3d > 0 ? int(MathCeil(((X)_dim_3d - _pool_3d + 1) / _stride_3d)) : 0);
      _out_4d = _out_3d == 0 ? 0 : (_stride_4d > 0 ? int(MathCeil(((X)_dim_4d - _pool_4d + 1) / _stride_4d)) : 0);
      _out_5d = _out_4d == 0 ? 0 : (_stride_5d > 0 ? int(MathCeil(((X)_dim_5d - _pool_5d + 1) / _stride_5d)) : 0);
    } else {
      _out_1d =
          _stride_1d > 0 ? int(_stride_1d == 0 ? 0 : ceil((X)_dim_1d / _stride_1d)) : 0;  // 3 / 2  =  Ceil(1.5)  =  2
      _out_2d = _out_1d == 0 ? 0
                             : (_stride_2d > 0 ? int(_stride_2d == 0 ? 0 : ceil((X)_dim_2d / _stride_2d))
                                               : 0);  // 2 / 2  =  Ceil(1) = 1
      _out_3d = _out_2d == 0 ? 0 : (_stride_3d > 0 ? int(_stride_3d == 0 ? 0 : ceil((X)_dim_3d / _stride_3d)) : 0);
      _out_4d = _out_3d == 0 ? 0 : (_stride_4d > 0 ? int(_stride_4d == 0 ? 0 : ceil((X)_dim_4d / _stride_4d)) : 0);
      _out_5d = _out_4d == 0 ? 0 : (_stride_5d > 0 ? int(_stride_5d == 0 ? 0 : ceil((X)_dim_5d / _stride_5d)) : 0);
    }
  }

  static int GetPooledSizeTotal(ENUM_MATRIX_PADDING _padding, int _dim_1d, int _dim_2d, int _dim_3d, int _dim_4d,
                                int _dim_5d, int _pool_1d, int _pool_2d, int _pool_3d, int _pool_4d, int _pool_5d,
                                int _stride_1d, int _stride_2d, int _stride_3d, int _stride_4d, int _stride_5d) {
    int _dimensions[MATRIX_DIMENSIONS];

    GetPooledSize(_padding, _dim_1d, _dim_2d, _dim_3d, _dim_4d, _dim_5d, _pool_1d, _pool_2d, _pool_3d, _pool_4d,
                  _pool_5d, _stride_1d, _stride_2d, _stride_3d, _stride_4d, _stride_5d, _dimensions[0], _dimensions[1],
                  _dimensions[2], _dimensions[3], _dimensions[4]);

    return GetDimensionsTotal(_dimensions);
  }

  static int GetDimensionsTotal(int& dimensions[]) {
    int size = 0;

    for (int i = 0; i < ArraySize(dimensions); ++i) {
      if (dimensions[i] != 0) {
        if (size == 0) {
          size = 1;
        }

        size *= dimensions[i];
      }
    }

    return size;
  }

  /**
   * Returns matrix reduces by given method (avg, min, max) using pooling.
   *
   * Stride, when set to 0, will revert back to 1.
   */
  Matrix<X>* GetPooled(ENUM_MATRIX_OPERATION _op, ENUM_MATRIX_PADDING _padding, int _pool_1d = 0, int _pool_2d = 0,
                       int _pool_3d = 0, int _pool_4d = 0, int _pool_5d = 0, int _stride_1d = MATRIX_STRIDE_AS_POOL,
                       int _stride_2d = MATRIX_STRIDE_AS_POOL, int _stride_3d = MATRIX_STRIDE_AS_POOL,
                       int _stride_4d = MATRIX_STRIDE_AS_POOL, int _stride_5d = MATRIX_STRIDE_AS_POOL) {
    int _out_1d, _out_2d, _out_3d, _out_4d, _out_5d;

#define _MATRIX_STRIDE_AS_POOL_MAYBE(dim)          \
  if (_stride_##dim##d == MATRIX_STRIDE_AS_POOL) { \
    _stride_##dim##d = _pool_##dim##d;             \
  }

    _MATRIX_STRIDE_AS_POOL_MAYBE(1);
    _MATRIX_STRIDE_AS_POOL_MAYBE(2);
    _MATRIX_STRIDE_AS_POOL_MAYBE(3);
    _MATRIX_STRIDE_AS_POOL_MAYBE(4);
    _MATRIX_STRIDE_AS_POOL_MAYBE(5);

    GetPooledSize(_padding, dimensions[0], dimensions[1], dimensions[2], dimensions[3], dimensions[4], _pool_1d,
                  _pool_2d, _pool_3d, _pool_4d, _pool_5d, _stride_1d, _stride_2d, _stride_3d, _stride_4d, _stride_5d,
                  _out_1d, _out_2d, _out_3d, _out_4d, _out_5d);

    Matrix<X>* _result = new Matrix<X>(_out_1d, _out_2d, _out_3d, _out_4d, _out_5d);

// If limit is 0 then var will end up as -1 and no loop will be performed.
// If limit is not 0 then normal for(var = 0; var < limit; ++var) will be performed.
#define _MATRIX_FOR_OR_MINUS_1(var, limit) \
  for (int var = (limit == 0 ? -1 : 0); (limit == 0) ? var == -1 : var < limit; ++var)

    _MATRIX_FOR_OR_MINUS_1(_chunk_1d, _out_1d) {
      _MATRIX_FOR_OR_MINUS_1(_chunk_2d, _out_2d) {
        _MATRIX_FOR_OR_MINUS_1(_chunk_3d, _out_3d) {
          _MATRIX_FOR_OR_MINUS_1(_chunk_4d, _out_4d) {
            _MATRIX_FOR_OR_MINUS_1(_chunk_5d, _out_5d) {
              X result =
                  ChunkOp(_op, _padding, _pool_1d, _pool_2d, _pool_3d, _pool_4d, _pool_5d, _stride_1d, _stride_2d,
                          _stride_3d, _stride_4d, _stride_5d, _chunk_1d, _chunk_2d, _chunk_3d, _chunk_4d, _chunk_5d);

              _result.Set(result, _chunk_1d, _chunk_2d, _chunk_3d, _chunk_4d, _chunk_5d);
            }
          }
        }
      }
    }

    return _result;
  }

  /**
   * Performs given operation on the multidimensional data, taking into consideration pool/chunk size, stride and
   * paddings previously calculated by GetPooled().
   */
  X ChunkOp(ENUM_MATRIX_OPERATION _op, ENUM_MATRIX_PADDING _padding, const int _pool_1d, const int _pool_2d,
            const int _pool_3d, const int _pool_4d, const int _pool_5d, const int _stride_1d, const int _stride_2d,
            const int _stride_3d, const int _stride_4d, const int _stride_5d, const int _chunk_1d, const int _chunk_2d,
            const int _chunk_3d, const int _chunk_4d, const int _chunk_5d) {
#define _MATRIX_FOR_DIM(dim)                                                                                       \
  int _start_##dim##d = _chunk_##dim##d == -1 ? 0 : (_chunk_##dim##d * _stride_##dim##d);                          \
  for (int d##dim = (_chunk_##dim##d == -1) ? (dimensions[dim - 1] != 0 ? _start_##dim##d : -1) : _start_##dim##d; \
       (d##dim == -1 || d##dim < _start_##dim##d + _pool_##dim##d); ++d##dim)

    X value = 0;
    MatrixDimensionAccessor<X> _accessor_d1, _accessor_d2, _accessor_d3, _accessor_d4, _accessor_d5;

#define _MATRIX_AGGR(val)    \
  ++_count;                  \
  _min = MathMin(_min, val); \
  _max = MathMax(_max, val); \
  _sum += val;

    int _count = 0;
    X _min = MaxOf((X)0);
    X _max = MinOf((X)0);
    X _sum = 0;
    X _avg = 0;

    X _val;

    _MATRIX_FOR_DIM(1) {
      bool _d1_valid = d1 < dimensions[0] && d1 >= 0;
      if (!_d1_valid) {
        // We don't aggreate zeroes.
        continue;
      } else {
        // First dimension have values?
        _accessor_d1 = this[d1];

        if (_accessor_d1.Type() == MATRIX_DIMENSION_TYPE_VALUES) {
          _MATRIX_AGGR(ptr_first_dimension.values[d1]);
          continue;
        }

        _MATRIX_FOR_DIM(2) {
          bool _d2_valid = d2 < dimensions[1] && d2 >= 0;
          if (!_d2_valid) {
            // We don't aggreate zeroes.
            continue;
          } else {
            // Second dimension have values?
            _accessor_d2 = _accessor_d1[d2];

            if (_accessor_d2.Type() == MATRIX_DIMENSION_TYPE_VALUES) {
              _val = _accessor_d2.Val();
              _MATRIX_AGGR(_val);
              continue;
            }

            _MATRIX_FOR_DIM(3) {
              bool _d3_valid = d3 < dimensions[2] && d3 >= 0;
              if (!_d3_valid) {
                // We don't aggreate zeroes.
                continue;
              } else {
                // Third dimension have values?
                _accessor_d3 = _accessor_d2[d3];

                if (_accessor_d3.Type() == MATRIX_DIMENSION_TYPE_VALUES) {
                  _val = _accessor_d3.Val();
                  _MATRIX_AGGR(_val);
                  continue;
                }

                _MATRIX_FOR_DIM(4) {
                  bool _d4_valid = d4 < dimensions[3] && d4 >= 0;
                  if (!_d4_valid) {
                    // We don't aggreate zeroes.
                    continue;
                  } else {
                    // Fourth dimension have values?
                    _accessor_d4 = _accessor_d3[d4];

                    if (_accessor_d4.Type() == MATRIX_DIMENSION_TYPE_VALUES) {
                      _val = _accessor_d4.Val();
                      _MATRIX_AGGR(_val);
                      continue;
                    }

                    _MATRIX_FOR_DIM(5) {
                      bool _d5_valid = d5 < dimensions[4] && d5 >= 0;
                      if (!_d5_valid) {
                        // We don't aggreate zeroes.
                        continue;
                      } else {
                        // Fifth dimension have values?
                        _accessor_d5 = _accessor_d4[d5];

                        if (_accessor_d4.Type() == MATRIX_DIMENSION_TYPE_VALUES) {
                          _val = _accessor_d5.Val();
                          _MATRIX_AGGR(_val);
                          continue;
                        } else {
                          Print("Matrix::ChunkOp(): Internal error. 5th dimension shouldn't have containers!");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    _avg = _sum / _count;

    switch (_op) {
      case MATRIX_OPERATION_MIN:
        return _min;
      case MATRIX_OPERATION_MAX:
        return _max;
      case MATRIX_OPERATION_SUM:
        return _sum;
      case MATRIX_OPERATION_AVG:
        return _avg;
      default:
        Print("Matrix::ChunkOp(): Invalid operation ", EnumToString(_op), "!");
    }

    return 0;
  }

  /**
   * Checks whether both matrices have the same dimensions' length.
   */
  static bool ShapeCompatible(Matrix<X>* _a, Matrix<X>* _b) { return _a.Repr() == _b.Repr(); }

  /**
   * Checks whether right matrix have less or equal dimensions' length..
   */
  static bool ShapeCompatibleLossely(Matrix<X>* _a, Matrix<X>* _b) {
    if (_b.GetDimensions() > _a.GetDimensions()) return false;

    for (int i = 0; i < _b.GetDimensions(); ++i) {
      if (_b.dimensions[i] != 1 && _b.dimensions[i] > _a.dimensions[i]) return false;
    }

    return true;
  }

  static Matrix<X>* CreateFromString(string text) {
    Matrix<X>* _ptr_matrix = new Matrix<X>();

    _ptr_matrix.FromString(text);

    return _ptr_matrix;
  }

  void FromString(string text) {
    MatrixDimension<X>*_dimensions[], *_root_dimension = NULL;
    int _dimensions_length[MATRIX_DIMENSIONS] = {0, 0, 0, 0, 0};
    int i, _number_start_pos;
    bool _had_values;
    X _number;
    bool _expecting_value_or_child = true;
    bool _expecting_comma = false;
    bool _expecting_end = false;

    for (i = 0; i < StringLen(text); ++i) {
      unsigned short _char = StringGetCharacter(text, i), c;

      switch (_char) {
        case '[':
          if (!_expecting_value_or_child) {
            Print("Unexpected '[' at offset ", i, "!");
            return;
          }

          _had_values = false;

          if (ArraySize(_dimensions) != 0) {
            _dimensions[ArraySize(_dimensions) - 1].type = MATRIX_DIMENSION_TYPE_CONTAINERS;
          }

          ArrayResize(_dimensions, ArraySize(_dimensions) + 1, MATRIX_DIMENSIONS);
          _dimensions[ArraySize(_dimensions) - 1] = new MatrixDimension<X>();

          if (ArraySize(_dimensions) >= 2) {
            _dimensions[ArraySize(_dimensions) - 2].AddContainer(_dimensions[ArraySize(_dimensions) - 1]);
          }

          if (_root_dimension == NULL) {
            _root_dimension = _dimensions[0];
          }

          _expecting_value_or_child = true;
          _expecting_end = true;
          break;

        case ']':
          ArrayResize(_dimensions, ArraySize(_dimensions) - 1, MATRIX_DIMENSIONS);
          _expecting_value_or_child = true;
          _expecting_comma = false;
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '-':
        case '.':
          if (!_expecting_value_or_child) {
            Print("Unexpected number at offset ", i, "!");
            return;
          }

          // Parsing number.
          _number_start_pos = i;
          do {
            c = StringGetCharacter(text, i++);
          } while ((c >= '0' && c <= '9') || c == '.' || c == '-' || c == 'e');
          _number = (X)StringToDouble(StringSubstr(text, _number_start_pos, i));
          i -= 2;
          _dimensions[ArraySize(_dimensions) - 1].type = MATRIX_DIMENSION_TYPE_VALUES;
          _dimensions[ArraySize(_dimensions) - 1].AddValue(_number);
          _expecting_end = true;
          _expecting_value_or_child = true;
          _expecting_comma = false;
          break;

        case ',':
          _expecting_value_or_child = true;
          _expecting_comma = false;
          _expecting_end = false;
          break;
        case ' ':
        case '\t':
        case '\r':
          break;
      }
    }

    Initialize(_root_dimension);
  }

  /**
   * Returns string or human-readable representation of the matrix's values.
   *
   * [
   *   [2,  3,  4]
         [2, 5] [6, 7]
       [5,  6,  7]
       [8,  9, 10]
   * ]
   *
   */
  string ToString(bool _whitespaces = false, int _precision = 3) {
    return ptr_first_dimension.ToString(_whitespaces, _precision);
  }

  /**
   * Returns representation of matrix's dimension, e.g., "[2, 5, 10]".
   */
  string Repr() {
    string _out = "[";

    for (int i = 0; i < ArraySize(dimensions); ++i) {
      if (dimensions[i] == 0) {
        continue;
      }

      _out += IntegerToString(dimensions[i]) + ((i < MATRIX_DIMENSIONS && dimensions[i + 1] != 0) ? ", " : "");
    }

    return _out + "]";
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Matrix.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Dict.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictBase.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Matrix.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef DICT_MQH
#define DICT_MQH






template <typename K, typename V>
class DictIterator : public DictIteratorBase<K, V> {
 public:
  /**
   * Constructor.
   */
  DictIterator() {}

  /**
   * Constructor.
   */
  DictIterator(DictBase<K, V>& dict, unsigned int slotIdx) : DictIteratorBase(dict, slotIdx) {}

  /**
   * Copy constructor.
   */
  DictIterator(const DictIterator& right) : DictIteratorBase(right) {}
};

/**
 * Hash-table based dictionary.
 */
template <typename K, typename V>
class Dict : public DictBase<K, V> {
 protected:
 public:
  /**
   * Constructor.
   */
  Dict() {}

  Dict(string _data, string _dlm = "\n") {}

  /**
   * Copy constructor.
   */
  Dict(const Dict<K, V>& right) {
    Clear();
    Resize(right.GetSlotCount());
    for (unsigned int i = 0; i < (unsigned int)ArraySize(right._DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i] = right._DictSlots_ref.DictSlots[i];
    }
    _DictSlots_ref._num_used = right._DictSlots_ref._num_used;
    _current_id = right._current_id;
    _mode = right._mode;
  }

  void operator=(const Dict<K, V>& right) {
    Clear();
    Resize(right.GetSlotCount());
    for (unsigned int i = 0; i < (unsigned int)ArraySize(right._DictSlots_ref.DictSlots); ++i) {
      _DictSlots_ref.DictSlots[i] = right._DictSlots_ref.DictSlots[i];
    }
    _DictSlots_ref._num_used = right._DictSlots_ref._num_used;
    _current_id = right._current_id;
    _mode = right._mode;
  }

  void Clear() {
    for (unsigned int i = 0; i < (unsigned int)ArraySize(_DictSlots_ref.DictSlots); ++i) {
      if (_DictSlots_ref.DictSlots[i].IsUsed()) _DictSlots_ref.DictSlots[i].SetFlags(0);
    }

    _DictSlots_ref._num_used = 0;
  }

  /**
   * Inserts value using hashless key.
   */
  bool Push(V value) {
    if (!InsertInto(_DictSlots_ref, value)) return false;
    return true;
  }

  /**
   * Inserts value using hashless key.
   */
  bool operator+=(V value) { return Push(value); }

  /**
   * Inserts or replaces value for a given key.
   */
  bool Set(K key, V value) {
    if (!InsertInto(_DictSlots_ref, key, value, true)) return false;
    return true;
  }

  V operator[](K key) {
    if (_mode == DictModeList) return GetSlot((unsigned int)key).value;

    int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, key, position);

    if (!slot) return (V)NULL;

    return slot.value;
  }

  /**
   * Returns value for a given key.
   *
   * @return
   *   Returns value for a given key, otherwise the default value.
   */
  V GetByKey(const K _key, V _default = NULL) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, _key, position);

    if (!slot) {
      return _default;
    }

    return slot.value;
  }

  /**
   * Returns value for a given position.
   */
  V GetByPos(unsigned int _position) {
    DictSlot<K, V>* slot = GetSlotByPos(_DictSlots_ref, _position);

    if (!slot) {
      Alert("Invalid DictStruct position \"", _position, "\" (called by GetByPos()). Returning empty structure.");
      DebugBreak();
      static V _empty;
      return _empty;
    }

    return slot.value;
  }

  /**
   * Checks whether dictionary contains given key => value pair.
   */
  template <>
  bool Contains(const K key, const V value) {
    unsigned int position;
    DictSlot<K, V>* slot = GetSlotByKey(_DictSlots_ref, key, position);

    if (!slot) return false;

    return slot.value == value;
  }

  /**
   * Returns index of dictionary's value or -1 if value doesn't exist.
   */
  template <>
  int IndexOf(V& value) {
    for (DictIteratorBase<K, V> i(Begin()); i.IsValid(); ++i) {
      if (i.Value() == value) {
        return (int)i.Index();
      }
    }

    return -1;
  }

  /**
   * Checks whether dictionary contains given value.
   */
  bool Contains(const V value) {
    for (DictIterator<K, V> i = Begin(); i.IsValid(); ++i) {
      if (i.Value() == value) {
        return true;
      }
    }

    return false;
  }

 protected:
  /**
   * Inserts value into given array of DictSlots.
   */
  bool InsertInto(DictSlotsRef<K, V>& dictSlotsRef, const K key, V value, bool allow_resize) {
    if (_mode == DictModeUnknown)
      _mode = DictModeDict;
    else if (_mode != DictModeDict) {
      Alert("Warning: Dict already operates as a list, not a dictionary!");
      return false;
    }

    unsigned int position;
    DictSlot<K, V>* keySlot = GetSlotByKey(dictSlotsRef, key, position);

    if (keySlot == NULL && !IsGrowUpAllowed()) {
      // Resize is prohibited.
      return false;
    }

    // Will resize dict if there were performance problems before.
    if (allow_resize && IsGrowUpAllowed() && !dictSlotsRef.IsPerformant()) {
      if (!GrowUp()) {
        return false;
      }
      // We now have new positions of slots, so we have to take the corrent slot again.
      keySlot = GetSlotByKey(dictSlotsRef, key, position);
    }

    if (keySlot == NULL && dictSlotsRef._num_used == ArraySize(dictSlotsRef.DictSlots)) {
      // No DictSlotsRef.DictSlots available.
      if (overflow_listener != NULL) {
        if (!overflow_listener(DICT_OVERFLOW_REASON_FULL, dictSlotsRef._num_used, 0)) {
          // Overwriting slot pointed exactly by key's position in the hash table (we don't check for possible
          // conflicts).
          keySlot = &dictSlotsRef.DictSlots[Hash(key) % ArraySize(dictSlotsRef.DictSlots)];
        }
      }

      if (keySlot == NULL) {
        // We need to expand array of DictSlotsRef.DictSlots (by 25% by default).
        if (!GrowUp()) return false;
      }
    }

    if (keySlot == NULL) {
      position = Hash(key) % ArraySize(dictSlotsRef.DictSlots);

      unsigned int _starting_position = position;
      int _num_conflicts = 0;
      bool _overwrite_slot = false;

      // Searching for empty DictSlot<K, V> or used one with the matching key. It skips used, hashless DictSlots.
      while (dictSlotsRef.DictSlots[position].IsUsed() &&
             (!dictSlotsRef.DictSlots[position].HasKey() || dictSlotsRef.DictSlots[position].key != key)) {
        if (overflow_listener_max_conflicts != 0 && ++_num_conflicts == overflow_listener_max_conflicts) {
          if (overflow_listener != NULL) {
            if (!overflow_listener(DICT_OVERFLOW_REASON_TOO_MANY_CONFLICTS, dictSlotsRef._num_used, _num_conflicts)) {
              // Overflow listener returned false so we won't search for further empty slot.
              _overwrite_slot = true;
              break;
            }
          } else {
            // Even if there is no overflow listener function, we stop searching for further empty slot as maximum
            // number of conflicts has been reached.
            _overwrite_slot = true;
            break;
          }
        }

        // Position may overflow, so we will start from the beginning.
        position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
      }

      if (_overwrite_slot) {
        // Overwriting starting position for faster further lookup.
        position = _starting_position;
      } else {
        // Slot overwrite is not needed. Using empty slot.
        ++dictSlotsRef._num_used;
      }

      dictSlotsRef.AddConflicts(_num_conflicts);
    }

    dictSlotsRef.DictSlots[position].key = key;
    dictSlotsRef.DictSlots[position].value = value;
    dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_HAS_KEY | DICT_SLOT_IS_USED | DICT_SLOT_WAS_USED);
    return true;
  }

  /**
   * Inserts hashless value into given array of DictSlots.
   */
  bool InsertInto(DictSlotsRef<K, V>& dictSlotsRef, V value) {
    if (_mode == DictModeUnknown)
      _mode = DictModeList;
    else if (_mode != DictModeList) {
      Alert("Warning: Dict already operates as a dictionary, not a list!");
      DebugBreak();
      return false;
    }

    if (dictSlotsRef._num_used == ArraySize(dictSlotsRef.DictSlots)) {
      // No DictSlotsRef.DictSlots available, we need to expand array of DictSlotsRef.DictSlots.
      if (!GrowUp()) return false;
    }

    unsigned int position = Hash((unsigned int)dictSlotsRef._list_index) % ArraySize(dictSlotsRef.DictSlots);

    // Searching for empty DictSlot<K, V>.
    while (dictSlotsRef.DictSlots[position].IsUsed()) {
      // Position may overflow, so we will start from the beginning.
      position = (position + 1) % ArraySize(dictSlotsRef.DictSlots);
    }

    dictSlotsRef.DictSlots[position].value = value;
    dictSlotsRef.DictSlots[position].SetFlags(DICT_SLOT_IS_USED | DICT_SLOT_WAS_USED);

    ++dictSlotsRef._list_index;
    ++dictSlotsRef._num_used;
    return true;
  }

  /**
   * Expands array of DictSlots by given percentage value.
   */
  bool GrowUp(int percent = DICT_GROW_UP_PERCENT_DEFAULT) {
    return Resize(MathMax(10, (int)((float)ArraySize(_DictSlots_ref.DictSlots) * ((float)(percent + 100) / 100.0f))));
  }

  /**
   * Shrinks or expands array of DictSlots.
   */
  bool Resize(int new_size) {
    if (new_size <= MathMin(_DictSlots_ref._num_used, ArraySize(_DictSlots_ref.DictSlots))) {
      // We already use minimum number of slots possible.
      return true;
    }

    DictSlotsRef<K, V> new_DictSlots;

    if (ArrayResize(new_DictSlots.DictSlots, new_size) == -1) return false;

    int i;

    for (i = 0; i < new_size; ++i) {
      new_DictSlots.DictSlots[i].SetFlags(0);
    }

    new_DictSlots._num_used = 0;

    // Copies entire array of DictSlots into new array of DictSlots. Hashes will be rehashed.
    for (i = 0; i < ArraySize(_DictSlots_ref.DictSlots); ++i) {
      if (!_DictSlots_ref.DictSlots[i].IsUsed()) continue;

      if (_DictSlots_ref.DictSlots[i].HasKey()) {
        if (!InsertInto(new_DictSlots, _DictSlots_ref.DictSlots[i].key, _DictSlots_ref.DictSlots[i].value, false))
          return false;
      } else {
        if (!InsertInto(new_DictSlots, _DictSlots_ref.DictSlots[i].value)) return false;
      }
    }
    // Freeing old DictSlots array.
    ArrayFree(_DictSlots_ref.DictSlots);

    _DictSlots_ref = new_DictSlots;

    return true;
  }

 public:
#ifdef __MQL__
  template <>
#endif
  SerializerNodeType Serialize(Serializer& s) {
    if (s.IsWriting()) {
      for (DictIteratorBase<K, V> i(Begin()); i.IsValid(); ++i) {
        V value = i.Value();
        s.Pass(THIS_REF, GetMode() == DictModeDict ? i.KeyAsString() : "", value);
      }

      return (GetMode() == DictModeDict) ? SerializerNodeObject : SerializerNodeArray;
    } else {
      SerializerIterator<V> i;

      for (i = s.Begin<V>(); i.IsValid(); ++i) {
        if (i.HasKey()) {
          // Converting key to a string.
          K key;
          Convert::StringToType(i.Key(), key);

          // Note that we're retrieving value by a key (as we are in an
          // object!).
          Set(key, i.Value(i.Key()));
        } else {
          Push(i.Value());
        }
      }
      return i.ParentNodeType();
    }
  }

  /**
   * Initializes object with given number of elements. Could be skipped for non-containers.
   */
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
    V _child = (V)NULL;
    while (_n1-- > 0) {
      Push(_child);
    }
  }

  /**
   * Converts values into 1D matrix.
   */
  template <typename X>
  Matrix<X>* ToMatrix() {
    Matrix<X>* result = new Matrix<X>(Size());

    for (DictIterator<K, V> i = Begin(); i.IsValid(); ++i) result[i.Index()] = (X)i.Value();

    return result;
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Dict.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerConverter.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef SERIALIZER_CSV_MQH
#define SERIALIZER_CSV_MQH

// Includes.









struct CsvTitle {
  int column_index;
  string title;

  CsvTitle(int _column_index = 0, string _title = "") : column_index(_column_index), title(_title) {}
};

enum ENUM_SERIALIZER_CSV_FLAGS {
  SERIALIZER_CSV_INCLUDE_TITLES = 1,
  SERIALIZER_CSV_INCLUDE_TITLES_TREE = SERIALIZER_CSV_INCLUDE_TITLES + 2,
  SERIALIZER_CSV_INCLUDE_KEY = 4
};

class SerializerCsv {
 public:
  static string Stringify(SerializerNode* _root, unsigned int serializer_flags, void* serializer_aux_arg = NULL,
                          MiniMatrix2d<string>* _matrix_out = NULL,
                          MiniMatrix2d<SerializerNodeParamType>* _column_types_out = NULL) {
    SerializerConverter* _stub = (SerializerConverter*)serializer_aux_arg;

    if (CheckPointer(_root) == POINTER_INVALID) {
      Alert("SerializerCsv: Invalid root node poiner!");
      DebugBreak();
      return NULL;
    }

    if (_stub == NULL || _stub.Node() == NULL) {
      Alert("SerializerCsv: Cannot convert to CSV without stub object!");
      DebugBreak();
      return NULL;
    }

    bool _include_titles = bool(serializer_flags & SERIALIZER_CSV_INCLUDE_TITLES);
    bool _include_key = bool(serializer_flags & SERIALIZER_CSV_INCLUDE_KEY);

    unsigned int _num_columns, _num_rows;
    int x, y;

    if (_stub.Node().IsArray()) {
      _num_columns = _stub.Node().MaximumNumChildrenInDeepEnd();
      _num_rows = _root.NumChildren();
    } else {
      _num_columns = MathMax(_stub.Node().MaximumNumChildrenInDeepEnd(), _root.MaximumNumChildrenInDeepEnd());
      _num_rows = _root.NumChildren() > 0 ? 1 : 0;
    }

    if (_include_titles) {
      ++_num_rows;
    }

    if (_include_key) {
      ++_num_columns;
    }

    MiniMatrix2d<string> _cells;
    MiniMatrix2d<string> _column_titles;
    MiniMatrix2d<SerializerNodeParamType> _column_types;

    if (_matrix_out == NULL) {
      _matrix_out = &_cells;
    }

    if (_column_types_out == NULL) {
      _column_types_out = &_column_types;
    }

    _matrix_out.Resize(_num_columns, _num_rows);
    _column_types_out.Resize(_num_columns, 1);

    if (_include_titles) {
      _column_titles.Resize(_num_columns, 1);
      int _titles_current_column = 0;
      SerializerCsv::ExtractColumns(_stub.Node(), &_column_titles, _column_types_out, serializer_flags,
                                    _titles_current_column);
      for (x = 0; x < _matrix_out.SizeX(); ++x) {
        _matrix_out.Set(x, 0, EscapeString(_column_titles.Get(x, 0)));
      }
    }

#ifdef __debug__
    Print("Stub: ", _stub.Node().ToString());
    Print("Data: ", _root.ToString());
    Print("Size: ", _num_columns, " x ", _num_rows);
#endif

    if (!SerializerCsv::FlattenNode(_root, _stub.Node(), _matrix_out, _column_types_out, _include_key ? 1 : 0,
                                    _include_titles ? 1 : 0, serializer_flags)) {
      Alert("SerializerCsv: Error occured during flattening!");
    }

    string _result;

    for (y = 0; y < _matrix_out.SizeY(); ++y) {
      for (x = 0; x < _matrix_out.SizeX(); ++x) {
        _result += _matrix_out.Get(x, y);

        if (x != _matrix_out.SizeX() - 1) {
          _result += ",";
        }
      }

      if (y != _matrix_out.SizeY() - 1) _result += "\n";
    }

    if ((serializer_flags & SERIALIZER_FLAG_REUSE_STUB) == 0) {
      _stub.Clean();
    }

    return _result;
  }

  static string ParamToString(SerializerNodeParam* param) {
    switch (param.GetType()) {
      case SerializerNodeParamBool:
      case SerializerNodeParamLong:
      case SerializerNodeParamDouble:
        return param.AsString(false, false, false, param.GetFloatingPointPrecision());
      case SerializerNodeParamString:
        return EscapeString(param.AsString(false, false, false, param.GetFloatingPointPrecision()));
      default:
        Print("Error: Wrong param type ", EnumToString(param.GetType()), "!");
        DebugBreak();
    }

    return "";
  }

  static string EscapeString(string _value) {
    string _result = _value;
    StringReplace(_result, "\"", "\"\"");
    return "\"" + _result + "\"";
  }

  /**
   * Extracts column names and types from the stub, so even if there is not data, we'll still have information about
   * columns.
   */
  static void ExtractColumns(SerializerNode* _stub, MiniMatrix2d<string>* _titles,
                             MiniMatrix2d<SerializerNodeParamType>* _column_types, int _flags, int& _column) {
    for (unsigned int _stub_entry_idx = 0; _stub_entry_idx < _stub.NumChildren(); ++_stub_entry_idx) {
      SerializerNode* _child = _stub.GetChild(_stub_entry_idx);
      if (_child.IsContainer()) {
        ExtractColumns(_child, _titles, _column_types, _flags, _column);
      } else if (_child.HasKey()) {
        _titles.Set(_column++, 0, _child.Key());
      }
    }
  }

  /**
   *
   */
  static bool FlattenNode(SerializerNode* _data, SerializerNode* _stub, MiniMatrix2d<string>& _cells,
                          MiniMatrix2d<SerializerNodeParamType>* _column_types, int _column, int _row, int _flags) {
    unsigned int _data_entry_idx;

    bool _include_key = bool(_flags & SERIALIZER_CSV_INCLUDE_KEY);

    if (_stub.IsArray()) {
      for (_data_entry_idx = 0; _data_entry_idx < _data.NumChildren(); ++_data_entry_idx) {
        if (_include_key) {
          // Adding object's key in the first row.
          SerializerNode* _child = _data.GetChild(_data_entry_idx);
          string key = _child.HasKey() ? _child.Key() : "";
          _cells.Set(0, _row + _data_entry_idx, key);
        }

        if (!SerializerCsv::FillRow(_data.GetChild(_data_entry_idx), _stub.GetChild(0), _cells, _column_types, _column,
                                    _row + _data_entry_idx, 0, 0, _flags)) {
          return false;
        }
      }
    } else if (_stub.IsObject()) {
      // Object means that there is only one row.
      if (_data.IsArray()) {
        // Stub is an object, but data is an array (should be?).
        for (_data_entry_idx = 0; _data_entry_idx < _data.NumChildren(); ++_data_entry_idx) {
          if (!SerializerCsv::FillRow(_data.GetChild(_data_entry_idx), _stub, _cells, _column_types, _column, _row, 0,
                                      0, _flags)) {
            return false;
          }

          _column += (int)_stub.GetChild(_data_entry_idx).MaximumNumChildrenInDeepEnd();
        }
      } else {
        // Stub and object are both arrays.
        if (!SerializerCsv::FillRow(_data, _stub, _cells, _column_types, _column, _row, 0, 0, _flags)) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   *
   */
  static bool FillRow(SerializerNode* _data, SerializerNode* _stub, MiniMatrix2d<string>& _cells,
                      MiniMatrix2d<SerializerNodeParamType>* _column_types, int _column, int _row, int _index,
                      int _level, int _flags) {
    unsigned int _data_entry_idx, _entry_size;

    if (_stub.IsObject()) {
      for (_data_entry_idx = 0; _data_entry_idx < _data.NumChildren(); ++_data_entry_idx) {
        if (_stub.NumChildren() == 0) {
          Print("Stub is empty for object representation of: ", _data.ToString(false, 2));
          Print(
              "Note that if you're serializing a dictionary, your stub must contain a single, dummy key and maximum "
              "possible object representation.");
          Print("Missing key \"", _data.Key(), "\" in stub.");
          DebugBreak();
        }
        _entry_size = MathMax(_stub.GetChild(_data_entry_idx).TotalNumChildren(),
                              _data.GetChild(_data_entry_idx).TotalNumChildren());

        if (!SerializerCsv::FillRow(_data.GetChild(_data_entry_idx),
                                    _stub != NULL ? _stub.GetChild(_data_entry_idx) : NULL, _cells, _column_types,
                                    _column, _row, _data_entry_idx, _level + 1, _flags)) {
          return false;
        }

        _column += (int)_entry_size;
      }
    } else if (_stub.IsArray()) {
      for (_data_entry_idx = 0; _data_entry_idx < _data.NumChildren(); ++_data_entry_idx) {
        _entry_size = MathMax(_stub.GetChild(_data_entry_idx).TotalNumChildren(),
                              _data.GetChild(_data_entry_idx).TotalNumChildren());

        if (!SerializerCsv::FillRow(_data.GetChild(_data_entry_idx), _stub.GetChild(0), _cells, _column_types, _column,
                                    _row, _data_entry_idx, _level + 1, _flags)) {
          return false;
        }

        _column += (int)_entry_size;
      }
    } else {
      // A property.

      bool _include_titles = bool(_flags & SERIALIZER_CSV_INCLUDE_TITLES);
      bool _include_titles_tree = (_flags & SERIALIZER_CSV_INCLUDE_TITLES_TREE) == SERIALIZER_CSV_INCLUDE_TITLES_TREE;

      if (_column_types != NULL) {
        if (_data.GetValueParam() == NULL) {
          Alert("Error: Expected value here! Stub is probably initialized without proper structure.");
          DebugBreak();
        }
        _column_types.Set(_column, 0, _data.GetValueParam().GetType());
      }

      _cells.Set(_column, _row, ParamToString(_data.GetValueParam()));
    }

    return true;
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerCsv.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef SERIALIZER_SQL_MQH
#define SERIALIZER_SQL_MQH

// Includes.




class SerializerSqlite {
 public:
  static ENUM_DATATYPE CsvParamTypeToSqlType(SerializerNodeParamType _param_type) {
    switch (_param_type) {
      case SerializerNodeParamBool:
        return TYPE_BOOL;
      case SerializerNodeParamLong:
        return TYPE_LONG;
      case SerializerNodeParamDouble:
        return TYPE_DOUBLE;
      case SerializerNodeParamString:
        return TYPE_STRING;
    }
    Print("Error: CsvParamTypeToSqlType: wrong _param_type parameter! Got ", _param_type, ".");
    DebugBreak();
    return (ENUM_DATATYPE)-1;
  }

  static bool ConvertToFile(SerializerConverter& source, string _path, string _table, unsigned int _stringify_flags = 0,
                            void* _stub = NULL) {
    // We must have titles tree as
    MiniMatrix2d<string> _matrix_out;
    MiniMatrix2d<SerializerNodeParamType> _column_types;
    string _csv = SerializerCsv::Stringify(source.root_node, _stringify_flags | SERIALIZER_CSV_INCLUDE_TITLES, _stub,
                                           &_matrix_out, &_column_types);

#ifdef __debug__
    Print("SerializerSqlite: Parsing CSV input:\n", _csv);
#endif

    Database _db(_path);
    int i;

    if (!_db.SchemaExists(_table)) {
      DatabaseTableSchema _schema;
      for (i = 0; i < _matrix_out.SizeX(); ++i) {
        string _column_name_quoted = _matrix_out.Get(i, 0);
        string _column_name_unquoted = StringSubstr(_column_name_quoted, 1, StringLen(_column_name_quoted) - 2);
        DatabaseTableColumnEntry _column;
        _column.name = _column_name_unquoted;
        _column.type = CsvParamTypeToSqlType(_column_types.Get(i, 0));
        _column.flags = 0;
        _column.char_size = 0;
        _schema.AddColumn(_column);
      }

      _db.SetTableSchema(_table, _schema);
    }

    if (!_db.TableExists(_table)) {
      if (!_db.CreateTable(_table, _db.GetTableSchema(_table))) {
        return false;
      }
    }

    if (!_db.ImportData(_table, _matrix_out)) {
      return false;
    }

    return true;
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerSqlite.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerConverter.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.struct.serialize.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Chart's struct serializers.
 */

// Forward class declaration.
class Serializer;

// Includes.



/* Method to serialize ChartEntry structure. */
SerializerNodeType ChartEntry::Serialize(Serializer& _s) {
  _s.PassStruct(THIS_REF, "bar", bar, SERIALIZER_FIELD_FLAG_DYNAMIC);
  return SerializerNodeObject;
}

/* Method to serialize ChartParams structure. */
SerializerNodeType ChartParams::Serialize(Serializer& s) {
  s.Pass(THIS_REF, "id", id);
  s.Pass(THIS_REF, "symbol", symbol);
  s.PassStruct(THIS_REF, "tf", tf);
  return SerializerNodeObject;
}

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.struct.serialize.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.struct.static.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Chart's static structs.
 */

/* Defines struct for chart static methods. */
struct ChartStatic {
  /**
   * Returns the number of bars on the specified chart.
   */
  static int iBars(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT) {
#ifdef __MQL4__
    // In MQL4, for the current chart, the information about the amount of bars is in the Bars predefined variable.
    return ::iBars(_symbol, _tf);
#else  // _MQL5__
    // ENUM_TIMEFRAMES _tf = MQL4::TFMigrate(_tf);
    return ::Bars(_symbol, _tf);
#endif
  }

  /**
   * Search for a bar by its time.
   *
   * Returns the index of the bar which covers the specified time.
   */
  static int iBarShift(string _symbol, ENUM_TIMEFRAMES _tf, datetime _time, bool _exact = false) {
#ifdef __MQL4__
    return ::iBarShift(_symbol, _tf, _time, _exact);
#else  // __MQL5__
    if (_time < 0) return (-1);
    ARRAY(datetime, arr);
    datetime _time0;
    // ENUM_TIMEFRAMES _tf = MQL4::TFMigrate(_tf);
    CopyTime(_symbol, _tf, 0, 1, arr);
    _time0 = arr[0];
    if (CopyTime(_symbol, _tf, _time, _time0, arr) > 0) {
      if (ArraySize(arr) > 2) {
        return ArraySize(arr) - 1;
      } else {
        return _time < _time0 ? 1 : 0;
      }
    } else {
      return -1;
    }
#endif
  }

  /**
   * Returns close price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   *
   * @see http://docs.mql4.com/series/iclose
   */
  static double iClose(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) {
#ifdef __MQL4__
    return ::iClose(_symbol, _tf, _shift);  // Same as: Close[_shift]
#else                                       // __MQL5__
    ARRAY(double, _arr);
    ArraySetAsSeries(_arr, true);
    return (_shift >= 0 && CopyClose(_symbol, _tf, _shift, 1, _arr) > 0) ? _arr[0] : 0;
#endif
  }

  /**
   * Returns low price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  static double iHigh(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, uint _shift = 0) {
#ifdef __MQL4__
    return ::iHigh(_symbol, _tf, _shift);  // Same as: High[_shift]
#else                                      // __MQL5__
    ARRAY(double, _arr);
    ArraySetAsSeries(_arr, true);
    return (_shift >= 0 && CopyHigh(_symbol, _tf, _shift, 1, _arr) > 0) ? _arr[0] : 0;
#endif
  }

  /**
   * Returns the shift of the maximum value over a specific number of periods depending on type.
   */
  static int iHighest(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _type = MODE_HIGH,
                      uint _count = WHOLE_ARRAY, int _start = 0) {
#ifdef __MQL4__
    return ::iHighest(_symbol, _tf, _type, _count, _start);
#else  // __MQL5__
    if (_start < 0) return (-1);
    _count = (_count <= 0 ? ChartStatic::iBars(_symbol, _tf) : _count);
    ARRAY(double, arr_d);
    ARRAY(long, arr_l);
    ARRAY(datetime, arr_dt);
    ArraySetAsSeries(arr_d, true);
    switch (_type) {
      case MODE_OPEN:
        CopyOpen(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_LOW:
        CopyLow(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_HIGH:
        CopyHigh(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_CLOSE:
        CopyClose(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_VOLUME:
        ArraySetAsSeries(arr_l, true);
        CopyTickVolume(_symbol, _tf, _start, _count, arr_l);
        return (ArrayMaximum(arr_l, 0, _count) + _start);
      case MODE_TIME:
        ArraySetAsSeries(arr_dt, true);
        CopyTime(_symbol, _tf, _start, _count, arr_dt);
        return (ArrayMaximum(arr_dt, 0, _count) + _start);
      default:
        break;
    }
    return (ArrayMaximum(arr_d, 0, _count) + _start);
#endif
  }

  /**
   * Returns low price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  static double iLow(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, uint _shift = 0) {
#ifdef __MQL4__
    return ::iLow(_symbol, _tf, _shift);  // Same as: Low[_shift]
#else                                     // __MQL5__
    ARRAY(double, _arr);
    ArraySetAsSeries(_arr, true);
    return (_shift >= 0 && CopyLow(_symbol, _tf, _shift, 1, _arr) > 0) ? _arr[0] : 0;
#endif
  }

  /**
   * Returns the shift of the lowest value over a specific number of periods depending on type.
   */
  static int iLowest(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _type = MODE_LOW,
                     unsigned int _count = WHOLE_ARRAY, int _start = 0) {
#ifdef __MQL4__
    return ::iLowest(_symbol, _tf, _type, _count, _start);
#else  // __MQL5__
    if (_start < 0) return (-1);
    _count = (_count <= 0 ? iBars(_symbol, _tf) : _count);
    ARRAY(double, arr_d);
    ARRAY(long, arr_l);
    ARRAY(datetime, arr_dt);
    ArraySetAsSeries(arr_d, true);
    switch (_type) {
      case MODE_OPEN:
        CopyOpen(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_LOW:
        CopyLow(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_HIGH:
        CopyHigh(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_CLOSE:
        CopyClose(_symbol, _tf, _start, _count, arr_d);
        break;
      case MODE_VOLUME:
        ArraySetAsSeries(arr_l, true);
        CopyTickVolume(_symbol, _tf, _start, _count, arr_l);
        return ArrayMinimum(arr_l, 0, _count) + _start;
      case MODE_TIME:
        ArraySetAsSeries(arr_dt, true);
        CopyTime(_symbol, _tf, _start, _count, arr_dt);
        return ArrayMinimum(arr_dt, 0, _count) + _start;
      default:
        break;
    }
    return ArrayMinimum(arr_d, 0, _count) + _start;
#endif
  }

  /**
   * Returns open price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  static double iOpen(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, uint _shift = 0) {
#ifdef __MQL4__
    return ::iOpen(_symbol, _tf, _shift);  // Same as: Open[_shift]
#else                                      // __MQL5__
    ARRAY(double, _arr);
    ArraySetAsSeries(_arr, true);
    return (_shift >= 0 && CopyOpen(_symbol, _tf, _shift, 1, _arr) > 0) ? _arr[0] : 0;
#endif
  }

  /**
   * Returns the current price value given applied price type.
   */
  static double iPrice(ENUM_APPLIED_PRICE _ap, string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT,
                       int _shift = 0) {
    double _result = EMPTY_VALUE;
    switch (_ap) {
      // Close price.
      case PRICE_CLOSE:
        _result = ChartStatic::iClose(_symbol, _tf, _shift);
        break;
      // Open price.
      case PRICE_OPEN:
        _result = ChartStatic::iOpen(_symbol, _tf, _shift);
        break;
      // The maximum price for the period.
      case PRICE_HIGH:
        _result = ChartStatic::iHigh(_symbol, _tf, _shift);
        break;
      // The minimum price for the period.
      case PRICE_LOW:
        _result = ChartStatic::iLow(_symbol, _tf, _shift);
        break;
      // Median price: (high + low)/2.
      case PRICE_MEDIAN:
        _result = (ChartStatic::iHigh(_symbol, _tf, _shift) + ChartStatic::iLow(_symbol, _tf, _shift)) / 2;
        break;
      // Typical price: (high + low + close)/3.
      case PRICE_TYPICAL:
        _result = (ChartStatic::iHigh(_symbol, _tf, _shift) + ChartStatic::iLow(_symbol, _tf, _shift) +
                   ChartStatic::iClose(_symbol, _tf, _shift)) /
                  3;
        break;
      // Weighted close price: (high + low + close + close)/4.
      case PRICE_WEIGHTED:
        _result = (ChartStatic::iHigh(_symbol, _tf, _shift) + ChartStatic::iLow(_symbol, _tf, _shift) +
                   ChartStatic::iClose(_symbol, _tf, _shift) + ChartStatic::iClose(_symbol, _tf, _shift)) /
                  4;
        break;
    }
    return _result;
  }

  /**
   * Returns open time price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  static datetime iTime(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, uint _shift = 0) {
#ifdef __MQL4__
    return ::iTime(_symbol, _tf, _shift);  // Same as: Time[_shift]
#else                                      // __MQL5__
    ARRAY(datetime, _arr);
    // ENUM_TIMEFRAMES _tf = MQL4::TFMigrate(_tf);
    // @todo: Improves performance by caching values.
    return (_shift >= 0 && ::CopyTime(_symbol, _tf, _shift, 1, _arr) > 0) ? _arr[0] : 0;
#endif
  }

  /**
   * Returns tick volume value for the bar.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  static long iVolume(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) {
#ifdef __MQL4__
    ResetLastError();
    long _volume = ::iVolume(_symbol, _tf, _shift);  // Same as: Volume[_shift]
    if (_LastError != ERR_NO_ERROR) {
      _volume = EMPTY_VALUE;
      ResetLastError();
    }
    return _volume;
#else  // __MQL5__
    ARRAY(long, _arr);
    ArraySetAsSeries(_arr, true);
    return (_shift >= 0 && CopyTickVolume(_symbol, _tf, _shift, 1, _arr) > 0) ? _arr[0] : 0;
#endif
  }

  /**
   * Gets Chart ID.
   */
  static long ID() { return ::ChartID(); }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.struct.static.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.define.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Chart.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Terminal's defines.
 */

/* Defines */

// Define type of timeframe periods using bitwise values.
#define M1B (1 << M1)    // 1 minute
#define M2B (1 << M2)    // 2 minutes (non-standard)
#define M3B (1 << M3)    // 3 minutes (non-standard)
#define M4B (1 << M4)    // 4 minutes (non-standard)
#define M5B (1 << M5)    // 5 minutes
#define M6B (1 << M6)    // 6 minutes (non-standard)
#define M10B (1 << M10)  // 10 minutes (non-standard)
#define M12B (1 << M12)  // 12 minutes (non-standard)
#define M15B (1 << M15)  // 15 minutes
#define M20B (1 << M20)  // 20 minutes (non-standard)
#define M30B (1 << M30)  // 30 minutes
#define H1B (1 << H1)    // 1 hour
#define H2B (1 << H2)    // 2 hours (non-standard)
#define H3B (1 << H3)    // 3 hours (non-standard)
#define H4B (1 << H4)    // 4 hours
#define H6B (1 << H6)    // 6 hours (non-standard)
#define H8B (1 << H8)    // 8 hours (non-standard)
#define H12B (1 << H12)  // 12 hours (non-standard)
#define D1B (1 << D1)    // Daily
#define W1B (1 << W1)    // Weekly
#define MN1B (1 << MN1)  // Monthly

#ifndef __MQL4__
// Chart.
#define CHART_BAR 0
#define CHART_CANDLE 1
//---
#ifndef MODE_ASCEND
#define MODE_ASCEND 0
#endif
#ifndef MODE_DESCEND
#define MODE_DESCEND 1
#endif
//---
#define MODE_LOW 1
#define MODE_HIGH 2
// --
#define MODE_OPEN 0
#define MODE_CLOSE 3
#define MODE_VOLUME 4
#define MODE_REAL_VOLUME 5
// --
#define MODE_TIME 5
#define MODE_BID 9
#define MODE_ASK 10
#define MODE_POINT 11
#define MODE_DIGITS 12
#define MODE_SPREAD 13
#define MODE_STOPLEVEL 14
#define MODE_LOTSIZE 15
#define MODE_TICKVALUE 16
#define MODE_TICKSIZE 17
#define MODE_SWAPLONG 18
#define MODE_SWAPSHORT 19
#define MODE_STARTING 20
#define MODE_EXPIRATION 21
#define MODE_TRADEALLOWED 22
#define MODE_TICK_SIZE 21
#define MODE_TICK_VALUE 22
#define MODE_MINLOT 23
#define MODE_LOTSTEP 24
#define MODE_MAXLOT 25
#define MODE_SWAPTYPE 26
#define MODE_PROFITCALCMODE 27
#define MODE_MARGINCALCMODE 28
#define MODE_MARGININIT 29
#define MODE_MARGINMAINTENANCE 30
#define MODE_MARGINHEDGED 31
#define MODE_MARGINREQUIRED 32
#define MODE_FREEZELEVEL 33
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.define.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.struct.tf.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Array.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Bar.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Bar.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Bar's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Pivot Point calculation method. */
enum ENUM_PP_TYPE {
  PP_CAMARILLA = 1,   // Camarilla: A set of eight levels which resemble support and resistance values
  PP_CLASSIC = 2,     // Classic pivot point
  PP_FIBONACCI = 3,   // Fibonacci pivot point
  PP_FLOOR = 4,       // Floor: Most basic and popular type of pivots used in Forex trading technical analysis
  PP_TOM_DEMARK = 5,  // Tom DeMark's pivot point (predicted lows and highs of the period)
  PP_WOODIE = 6,      // Woodie's pivot point are giving more weight to the Close price of the previous period
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Bar.enum.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: ISerializable.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Serializable interface.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif



class Serializer;

class ISerializable {
 public:
  virtual SerializerNodeType Serialize(Serializer &s) = 0;
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: ISerializable.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Bar's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward class declaration.
class Serializer;

// Includes.







/* Struct for storing OHLC values. */
struct BarOHLC
#ifndef __MQL__
    : public ISerializable
#endif
{
  datetime time;
  float open, high, low, close;
  // Struct constructor.
  BarOHLC() : open(0), high(0), low(0), close(0), time(0){};
  BarOHLC(float _open, float _high, float _low, float _close, datetime _time = 0)
      : time(_time), open(_open), high(_high), low(_low), close(_close) {
    if (_time == 0) {
      _time = TimeCurrent();
    }
  }
  BarOHLC(ARRAY_REF(float, _prices), datetime _time = 0) : time(_time) {
    _time = _time == 0 ? TimeCurrent() : _time;
    int _size = ArraySize(_prices);
    close = _prices[0];
    open = _prices[_size - 1];
    high = fmax(close, open);
    low = fmin(close, open);
    for (int i = 0; i < _size; i++) {
      high = fmax(high, _prices[i]);
      low = fmin(low, _prices[i]);
    }
  }
  // Struct methods.
  // Getters
  bool GetPivots(ENUM_PP_TYPE _type, float &_pp, float &_r1, float &_r2, float &_r3, float &_r4, float &_s1, float &_s2,
                 float &_s3, float &_s4) {
    float _range = GetRange();
    switch (_type) {
      case PP_CAMARILLA:
        // A set of eight very probable levels which resemble support and resistance values for a current trend.
        _pp = GetPivot();
        _r1 = (float)(close + _range * 1.1 / 12);
        _r2 = (float)(close + _range * 1.1 / 6);
        _r3 = (float)(close + _range * 1.1 / 4);
        _r4 = (float)(close + _range * 1.1 / 2);
        _s1 = (float)(close - _range * 1.1 / 12);
        _s2 = (float)(close - _range * 1.1 / 6);
        _s3 = (float)(close - _range * 1.1 / 4);
        _s4 = (float)(close - _range * 1.1 / 2);
        break;
      case PP_CLASSIC:
        _pp = GetPivot();
        _r1 = (2 * _pp) - low;   // R1 = (H - L) * 1.1 / 12 + C (1.0833)
        _r2 = _pp + _range;      // R2 = (H - L) * 1.1 / 6 + C (1.1666)
        _r3 = _pp + _range * 2;  // R3 = (H - L) * 1.1 / 4 + C (1.25)
        _r4 = _pp + _range * 3;  // R4 = (H - L) * 1.1 / 2 + C (1.5)
        _s1 = (2 * _pp) - high;  // S1 = C - (H - L) * 1.1 / 12 (1.0833)
        _s2 = _pp - _range;      // S2 = C - (H - L) * 1.1 / 6 (1.1666)
        _s3 = _pp - _range * 2;  // S3 = C - (H - L) * 1.1 / 4 (1.25)
        _s4 = _pp - _range * 3;  // S4 = C - (H - L) * 1.1 / 2 (1.5)
        break;
      case PP_FIBONACCI:
        _pp = GetPivot();
        _r1 = (float)(_pp + 0.382 * _range);
        _r2 = (float)(_pp + 0.618 * _range);
        _r3 = _pp + _range;
        _r4 = _r1 + _range;  // ?
        _s1 = (float)(_pp - 0.382 * _range);
        _s2 = (float)(_pp - 0.618 * _range);
        _s3 = _pp - _range;
        _s4 = _s1 - _range;  // ?
        break;
      case PP_FLOOR:
        // Most basic and popular type of pivots used in Forex trading technical analysis.
        _pp = GetPivot();              // Pivot (P) = (H + L + C) / 3
        _r1 = (2 * _pp) - low;         // Resistance (R1) = (2 * P) - L
        _r2 = _pp + _range;            // R2 = P + H - L
        _r3 = high + 2 * (_pp - low);  // R3 = H + 2 * (P - L)
        _r4 = _r3;
        _s1 = (2 * _pp) - high;        // Support (S1) = (2 * P) - H
        _s2 = _pp - _range;            // S2 = P - H + L
        _s3 = low - 2 * (high - _pp);  // S3 = L - 2 * (H - P)
        _s4 = _s3;                     // ?
        break;
      case PP_TOM_DEMARK:
        // Tom DeMark's pivot point (predicted lows and highs of the period).
        _pp = GetPivotDeMark();
        _r1 = (2 * _pp) - low;  // New High = X / 2 - L.
        _r2 = _pp + _range;
        _r3 = _r1 + _range;
        _r4 = _r2 + _range;      // ?
        _s1 = (2 * _pp) - high;  // New Low = X / 2 - H.
        _s2 = _pp - _range;
        _s3 = _s1 - _range;
        _s4 = _s2 - _range;  // ?
        break;
      case PP_WOODIE:
        // Woodie's pivot point are giving more weight to the Close price of the previous period.
        // They are similar to floor pivot points, but are calculated in a somewhat different way.
        _pp = GetWeighted();    // Pivot (P) = (H + L + 2 * C) / 4
        _r1 = (2 * _pp) - low;  // Resistance (R1) = (2 * P) - L
        _r2 = _pp + _range;     // R2 = P + H - L
        _r3 = _r1 + _range;
        _r4 = _r2 + _range;      // ?
        _s1 = (2 * _pp) - high;  // Support (S1) = (2 * P) - H
        _s2 = _pp - _range;      // S2 = P - H + L
        _s3 = _s1 - _range;
        _s4 = _s2 - _range;  // ?
        break;
      default:
        break;
    }
    return _r4 > _r3 && _r3 > _r2 && _r2 > _r1 && _r1 > _pp && _pp > _s1 && _s1 > _s2 && _s2 > _s3 && _s3 > _s4;
  }
  datetime GetTime() { return time; }
  float GetAppliedPrice(ENUM_APPLIED_PRICE _ap) const { return BarOHLC::GetAppliedPrice(_ap, open, high, low, close); }
  float GetBody() const { return close - open; }
  float GetBodyAbs() const { return fabs(close - open); }
  float GetBodyInPct(int _hundreds = 100) const { return GetRange() > 0 ? _hundreds / GetRange() * GetBodyAbs() : 0; }
  float GetChangeInPct(int _hundreds = 100) const { return (close - open) / open * _hundreds; }
  float GetClose() const { return close; }
  float GetHigh() const { return high; }
  float GetLow() const { return low; }
  float GetMaxOC() const { return fmax(open, close); }
  float GetMedian() const { return (high + low) / 2; }
  float GetMinOC() const { return fmin(open, close); }
  float GetOpen() const { return open; }
  float GetPivot() const { return GetTypical(); }
  float GetPivotDeMark() const {
    // If Close < Open Then X = H + 2 * L + C
    // If Close > Open Then X = 2 * H + L + C
    // If Close = Open Then X = H + L + 2 * C
    float _pp = open > close ? (high + (2 * low) + close) / 4 : ((2 * high) + low + close) / 4;
    return open == close ? (high + low + (2 * close)) / 4 : _pp;
  }
  float GetPivotWithOpen() const { return (open + high + low + close) / 4; }
  float GetPivotWithOpen(float _open) const { return (_open + high + low + close) / 4; }
  float GetRange() const { return high - low; }
  float GetRangeChangeInPct(int _hundreds = 100) const {
    return _hundreds - (_hundreds / open * fabs(open - GetRange()));
  }
  float GetRangeInPips(float _ppp) const { return GetRange() / _ppp; }
  float GetTypical() const { return (high + low + close) / 3; }
  float GetWeighted() const { return (high + low + close + close) / 4; }
  float GetWickMin() const { return fmin(GetWickLower(), GetWickUpper()); }
  float GetWickLower() const { return GetMinOC() - low; }
  float GetWickLowerInPct() const { return GetRange() > 0 ? 100 / GetRange() * GetWickLower() : 0; }
  float GetWickMax() const { return fmax(GetWickLower(), GetWickUpper()); }
  float GetWickSum() const { return GetWickLower() + GetWickUpper(); }
  float GetWickUpper() const { return high - GetMaxOC(); }
  float GetWickUpperInPct() const { return GetRange() > 0 ? 100 / GetRange() * GetWickUpper() : 0; }
  short GetType() const { return IsBull() ? 1 : (IsBear() ? -1 : 0); }
  void GetValues(ARRAY_REF(float, _out)) {
    ArrayResize(_out, 4);
    int _index = ArraySize(_out) - 4;
    _out[_index++] = open;
    _out[_index++] = high;
    _out[_index++] = low;
    _out[_index++] = close;
  }
  template <typename T>
  static T GetAppliedPrice(ENUM_APPLIED_PRICE _ap, T _o, T _h, T _l, T _c) {
    switch (_ap) {
      case PRICE_CLOSE:
        return _c;
      case PRICE_OPEN:
        return _o;
      case PRICE_HIGH:
        return _h;
      case PRICE_LOW:
        return _l;
      case PRICE_MEDIAN:
        return (_h + _l) / 2;
      case PRICE_TYPICAL:
        return (_h + _l + _c) / 3;
      case PRICE_WEIGHTED:
        return (_h + _l + _c + _c) / 4;
      default:
        return _o;
    }
  }
  // State checkers.
  bool IsBear() const { return open > close; }
  bool IsBull() const { return open < close; }
  bool IsValid() const { return high >= low && fmin(open, close) > 0; }
  // Serializers.
  SerializerNodeType Serialize(Serializer &s);
  // Converters.
  string ToCSV() { return StringFormat("%d,%g,%g,%g,%g", time, open, high, low, close); }
};



/* Method to serialize BarOHLC structure. */
SerializerNodeType BarOHLC::Serialize(Serializer &s) {
  // s.Pass(THIS_REF, "time", TimeToString(time));
  s.Pass(THIS_REF, "open", open, SERIALIZER_FIELD_FLAG_DYNAMIC);
  s.Pass(THIS_REF, "high", high, SERIALIZER_FIELD_FLAG_DYNAMIC);
  s.Pass(THIS_REF, "low", low, SERIALIZER_FIELD_FLAG_DYNAMIC);
  s.Pass(THIS_REF, "close", close, SERIALIZER_FIELD_FLAG_DYNAMIC);
  return SerializerNodeObject;
}

/* Defines struct to store bar entries. */
struct BarEntry {
  BarOHLC ohlc;
  BarEntry() {}
  BarEntry(const BarOHLC &_ohlc) { ohlc = _ohlc; }
  // Struct getters
  BarOHLC GetOHLC() const { return ohlc; }
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer &s) {
    s.PassStruct(THIS_REF, "ohlc", ohlc, SERIALIZER_FIELD_FLAG_DYNAMIC);
    return SerializerNodeObject;
  }
  string ToCSV() { return StringFormat("%s", ohlc.ToCSV()); }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Bar.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Chart's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward class declaration.
class Class;

// Includes.









/* Defines struct to store bar entries. */
struct ChartEntry {
  BarEntry bar;
  // Constructors.
  ChartEntry() {}
  ChartEntry(const BarEntry& _bar) { SetBar(_bar); }
  // Getters.
  BarEntry GetBar() { return bar; }
  string ToCSV() { return StringFormat("%s", bar.ToCSV()); }
  // Setters.
  void SetBar(const BarEntry& _bar) { bar = _bar; }
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer& _s);
};

/* Defines struct for chart parameters. */
struct ChartParams {
  long id;
  string symbol;
  ChartTf tf;
  // Copy constructor.
  ChartParams(ChartParams& _cparams) : symbol(_cparams.symbol), tf(_cparams.tf) {}
  // Constructors.
  ChartParams(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, string _symbol = NULL, long _id = 0)
      : id(_id), symbol(_symbol), tf(_tf){};
  ChartParams(ENUM_TIMEFRAMES_INDEX _tfi, string _symbol = NULL, long _id = 0) : id(_id), symbol(_symbol), tf(_tfi){};
  // Getters.
  template <typename T>
  T Get(ENUM_CHART_PARAM _param) {
    switch (_param) {
      case CHART_PARAM_ID:
        return (T)id;
      case CHART_PARAM_SYMBOL:
        return (T)symbol;
      case CHART_PARAM_TF:
        return (T)tf.GetTf();
      case CHART_PARAM_TFI:
        return (T)tf.GetIndex();
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }
  ChartTf GetChartTf() const { return tf; }
  // ENUM_TIMEFRAMES GetTf() const { return tf.GetTf(); }
  // ENUM_TIMEFRAMES_INDEX GetTfIndex() const { return tf.GetIndex(); }
  // Setters.
  template <typename T>
  void Set(ENUM_CHART_PARAM _param, T _value) {
    switch (_param) {
      case CHART_PARAM_ID:
        id = (long)_value;
        return;
      case CHART_PARAM_SYMBOL:
        symbol = (string)_value;
        return;
      case CHART_PARAM_TF:
        tf.SetTf((ENUM_TIMEFRAMES)_value);
        return;
      case CHART_PARAM_TFI:
        tf.SetIndex((ENUM_TIMEFRAMES_INDEX)_value);
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  // Serializers.
  SerializerNodeType Serialize(Serializer& s);
} chart_params_defaults(PERIOD_CURRENT, _Symbol);

/**
 * Wrapper struct that returns close prices of each bar of the current chart.
 *
 * @see: https://docs.mql4.com/predefined/close
 */
struct ChartPriceClose {
  string symbol;
  ENUM_TIMEFRAMES tf;

  ChartPriceClose() : symbol(_Symbol), tf(PERIOD_CURRENT) {}
  double operator[](const int _shift) const { return Get(symbol, tf, _shift); }
  static double Get(const string _symbol, const ENUM_TIMEFRAMES _tf, const int _shift) {
    return ChartStatic::iClose(_symbol, _tf, _shift);
  }
};

/**
 * Wrapper struct that returns the highest prices of each bar of the current chart.
 *
 * @see: https://docs.mql4.com/predefined/high
 */
struct ChartPriceHigh {
  string symbol;
  ENUM_TIMEFRAMES tf;

  ChartPriceHigh() : symbol(_Symbol), tf(PERIOD_CURRENT) {}
  double operator[](const int _shift) const { return Get(symbol, tf, _shift); }
  static double Get(const string _symbol, const ENUM_TIMEFRAMES _tf, const int _shift) {
    return ChartStatic::iHigh(_symbol, _tf, _shift);
  }
};

/**
 * Wrapper struct that returns the lowest prices of each bar of the current chart.
 *
 * @see: https://docs.mql4.com/predefined/low
 */
struct ChartPriceLow {
  string symbol;
  ENUM_TIMEFRAMES tf;

  ChartPriceLow() : symbol(_Symbol), tf(PERIOD_CURRENT) {}
  double operator[](const int _shift) const { return Get(symbol, tf, _shift); }
  static double Get(const string _symbol, const ENUM_TIMEFRAMES _tf, const int _shift) {
    return ChartStatic::iLow(_symbol, _tf, _shift);
  }
};

/**
 * Wrapper struct that returns open prices of each bar of the current chart.
 *
 * @see: https://docs.mql4.com/predefined/open
 */
struct ChartPriceOpen {
  string symbol;
  ENUM_TIMEFRAMES tf;

  ChartPriceOpen() : symbol(_Symbol), tf(PERIOD_CURRENT) {}
  double operator[](const int _shift) const { return Get(symbol, tf, _shift); }
  static double Get(const string _symbol, const ENUM_TIMEFRAMES _tf, const int _shift) {
    return ChartStatic::iOpen(_symbol, _tf, _shift);
  }
};

/**
 * Wrapper struct that returns open time of each bar of the current chart.
 *
 * @see: https://docs.mql4.com/predefined/time
 */
struct ChartBarTime {
 protected:
  string symbol;
  ENUM_TIMEFRAMES tf;

 public:
  ChartBarTime() : symbol(_Symbol), tf(PERIOD_CURRENT) {}
  datetime operator[](const int _shift) const { return Get(symbol, tf, _shift); }
  static datetime Get(const string _symbol, const ENUM_TIMEFRAMES _tf, const int _shift) {
    return ChartStatic::iTime(_symbol, _tf, _shift);
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.define.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Market.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Market.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Market's structs.
 */

// Includes.



// Structure for trade time static methods.
struct MarketTimeForex : DateTimeEntry {
  // Market sessions for trading Forex.
  enum ENUM_MARKET_TIME_FOREX_HOURS {
    MARKET_TIME_FOREX_HOURS_NONE = 0 << 0,
    // By city.
    MARKET_TIME_FOREX_HOURS_CHICAGO = 1 << 0,
    MARKET_TIME_FOREX_HOURS_FRANKFURT = 1 << 1,
    MARKET_TIME_FOREX_HOURS_HONGKONG = 1 << 2,
    MARKET_TIME_FOREX_HOURS_LONDON = 1 << 3,
    MARKET_TIME_FOREX_HOURS_NEWYORK = 1 << 4,
    MARKET_TIME_FOREX_HOURS_SYDNEY = 1 << 5,
    MARKET_TIME_FOREX_HOURS_TOKYO = 1 << 6,
    MARKET_TIME_FOREX_HOURS_WELLINGTON = 1 << 7,
    // By region.
    MARKET_TIME_FOREX_HOURS_AMERICA = MARKET_TIME_FOREX_HOURS_NEWYORK | MARKET_TIME_FOREX_HOURS_CHICAGO,
    MARKET_TIME_FOREX_HOURS_ASIA = MARKET_TIME_FOREX_HOURS_TOKYO | MARKET_TIME_FOREX_HOURS_HONGKONG,
    MARKET_TIME_FOREX_HOURS_EUROPE = MARKET_TIME_FOREX_HOURS_LONDON | MARKET_TIME_FOREX_HOURS_FRANKFURT,
    MARKET_TIME_FOREX_HOURS_PACIFIC = MARKET_TIME_FOREX_HOURS_SYDNEY | MARKET_TIME_FOREX_HOURS_WELLINGTON,
  };
  // Constructors.
  MarketTimeForex() { Set(::TimeGMT()); }
  MarketTimeForex(datetime _time_gmt) { Set(_time_gmt); }
  MarketTimeForex(MqlDateTime &_dt_gmt) { Set(_dt_gmt); }
  // State methods.
  /* Getters */
  bool CheckHours(unsigned int _hours_enums) {
    // Trading sessions according to GMT (Greenwich Mean Time).
    if (_hours_enums > 0) {
      unsigned short _hopen = 24, _hclose = 0;
      // By city.
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_LONDON) != 0) {
        _hopen =
            _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_LONDON) ? GetOpenHour(MARKET_TIME_FOREX_HOURS_LONDON) : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_LONDON) ? GetCloseHour(MARKET_TIME_FOREX_HOURS_LONDON)
                                                                         : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_FRANKFURT) != 0) {
        _hopen = _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_FRANKFURT)
                     ? GetOpenHour(MARKET_TIME_FOREX_HOURS_FRANKFURT)
                     : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_FRANKFURT)
                      ? GetCloseHour(MARKET_TIME_FOREX_HOURS_FRANKFURT)
                      : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_NEWYORK) != 0) {
        _hopen = _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_NEWYORK) ? GetOpenHour(MARKET_TIME_FOREX_HOURS_NEWYORK)
                                                                       : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_NEWYORK)
                      ? GetCloseHour(MARKET_TIME_FOREX_HOURS_NEWYORK)
                      : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_CHICAGO) != 0) {
        _hopen = _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_CHICAGO) ? GetOpenHour(MARKET_TIME_FOREX_HOURS_CHICAGO)
                                                                       : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_CHICAGO)
                      ? GetCloseHour(MARKET_TIME_FOREX_HOURS_CHICAGO)
                      : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_TOKYO) != 0) {
        _hopen =
            _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_TOKYO) ? GetOpenHour(MARKET_TIME_FOREX_HOURS_TOKYO) : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_TOKYO) ? GetCloseHour(MARKET_TIME_FOREX_HOURS_TOKYO)
                                                                        : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_HONGKONG) != 0) {
        _hopen = _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_HONGKONG) ? GetOpenHour(MARKET_TIME_FOREX_HOURS_HONGKONG)
                                                                        : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_HONGKONG)
                      ? GetCloseHour(MARKET_TIME_FOREX_HOURS_HONGKONG)
                      : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_SYDNEY) != 0) {
        // @todo: _market_hours.CheckHours(MarketForexTime::MARKET_TIME_FOREX_HOURS_EUROPE |
        // MarketForexTime::MARKET_TIME_FOREX_HOURS_PACIFIC)
        _hopen =
            _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_SYDNEY) ? GetOpenHour(MARKET_TIME_FOREX_HOURS_SYDNEY) : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_SYDNEY) ? GetCloseHour(MARKET_TIME_FOREX_HOURS_SYDNEY)
                                                                         : _hclose;
      }
      if ((_hours_enums & MARKET_TIME_FOREX_HOURS_WELLINGTON) != 0) {
        // @todo: _market_hours.CheckHours(MarketForexTime::MARKET_TIME_FOREX_HOURS_EUROPE |
        // MarketForexTime::MARKET_TIME_FOREX_HOURS_PACIFIC)
        _hopen = _hopen > GetOpenHour(MARKET_TIME_FOREX_HOURS_WELLINGTON)
                     ? GetOpenHour(MARKET_TIME_FOREX_HOURS_WELLINGTON)
                     : _hopen;
        _hclose = _hclose < GetCloseHour(MARKET_TIME_FOREX_HOURS_WELLINGTON)
                      ? GetCloseHour(MARKET_TIME_FOREX_HOURS_WELLINGTON)
                      : _hclose;
      }
      return _hopen < _hclose ? hour >= _hopen && hour <= _hclose : hour >= _hopen || hour <= _hclose;
    }
    return false;
  }
  // Returns market close hour given a city or a region.
  unsigned short GetCloseHour(ENUM_MARKET_TIME_FOREX_HOURS _enum) {
    // Trading sessions according to GMT (Greenwich Mean Time).
    // Source: http://www.forexmarkethours.com/GMT_hours/02/
    switch (_enum) {
      case MARKET_TIME_FOREX_HOURS_CHICAGO:
        return 23;
      case MARKET_TIME_FOREX_HOURS_FRANKFURT:
        return 16;
      case MARKET_TIME_FOREX_HOURS_HONGKONG:
        return 10;
      case MARKET_TIME_FOREX_HOURS_LONDON:
        return 17;
      case MARKET_TIME_FOREX_HOURS_NEWYORK:
        return 22;
      case MARKET_TIME_FOREX_HOURS_SYDNEY:
        return 7;
      case MARKET_TIME_FOREX_HOURS_TOKYO:
        return 9;
      case MARKET_TIME_FOREX_HOURS_WELLINGTON:
        return 6;
      case MARKET_TIME_FOREX_HOURS_AMERICA:
        return MathMax(GetCloseHour(MARKET_TIME_FOREX_HOURS_NEWYORK), GetCloseHour(MARKET_TIME_FOREX_HOURS_CHICAGO));
      case MARKET_TIME_FOREX_HOURS_ASIA:
        return MathMax(GetCloseHour(MARKET_TIME_FOREX_HOURS_TOKYO), GetCloseHour(MARKET_TIME_FOREX_HOURS_HONGKONG));
      case MARKET_TIME_FOREX_HOURS_EUROPE:
        return MathMax(GetCloseHour(MARKET_TIME_FOREX_HOURS_LONDON), GetCloseHour(MARKET_TIME_FOREX_HOURS_FRANKFURT));
      case MARKET_TIME_FOREX_HOURS_PACIFIC:
        return MathMax(GetCloseHour(MARKET_TIME_FOREX_HOURS_SYDNEY), GetCloseHour(MARKET_TIME_FOREX_HOURS_WELLINGTON));
      default:
        return 0;
    }
  }
  // Returns market open hour given a city or a region.
  unsigned short GetOpenHour(ENUM_MARKET_TIME_FOREX_HOURS _enum) {
    // Trading sessions according to GMT (Greenwich Mean Time).
    // Source: http://www.forexmarkethours.com/GMT_hours/02/
    switch (_enum) {
      case MARKET_TIME_FOREX_HOURS_CHICAGO:
        return 14;
      case MARKET_TIME_FOREX_HOURS_FRANKFURT:
        return 7;
      case MARKET_TIME_FOREX_HOURS_HONGKONG:
        return 1;
      case MARKET_TIME_FOREX_HOURS_LONDON:
        return 8;
      case MARKET_TIME_FOREX_HOURS_NEWYORK:
        return 13;
      case MARKET_TIME_FOREX_HOURS_SYDNEY:
        return 22;
      case MARKET_TIME_FOREX_HOURS_TOKYO:
        return 0;
      case MARKET_TIME_FOREX_HOURS_WELLINGTON:
        return 22;
      case MARKET_TIME_FOREX_HOURS_AMERICA:
        return MathMin(GetOpenHour(MARKET_TIME_FOREX_HOURS_NEWYORK), GetOpenHour(MARKET_TIME_FOREX_HOURS_CHICAGO));
      case MARKET_TIME_FOREX_HOURS_ASIA:
        return MathMin(GetOpenHour(MARKET_TIME_FOREX_HOURS_TOKYO), GetOpenHour(MARKET_TIME_FOREX_HOURS_HONGKONG));
      case MARKET_TIME_FOREX_HOURS_EUROPE:
        return MathMin(GetOpenHour(MARKET_TIME_FOREX_HOURS_LONDON), GetOpenHour(MARKET_TIME_FOREX_HOURS_FRANKFURT));
      case MARKET_TIME_FOREX_HOURS_PACIFIC:
        return MathMin(GetOpenHour(MARKET_TIME_FOREX_HOURS_SYDNEY), GetOpenHour(MARKET_TIME_FOREX_HOURS_WELLINGTON));
      default:
        return 0;
    }
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Market.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Math.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Order.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: String.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Std.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef STRING_MQH
#define STRING_MQH

// Includes.


// Defines.
#define NL "\n"   // New line: 0x0A (MQL file functions auto-convert 0x0A to 0x0D0A).
#define TAB "\t"  // Tab: 0x09.

/**
 * Class to provide methods to deal with strings.
 */
class String {
 protected:
  ARRAY(string, strings);
  string dlm;

 public:
  /**
   * Class constructor.
   */
  String(string _string = "") : dlm(",") {
    if (_string != "") Add(_string);
  }

  /**
   * Add a new string.
   */
  bool Add(string _string) {
    uint _size = ArraySize(strings);
    if (ArrayResize(strings, _size + 1, 100)) {
      strings[_size] = _string;
      return true;
    } else {
      return false;
    }
  }

  /**
   * Add a new value.
   */
  bool Add(int _value) { return Add(IntegerToString(_value)); }

  /**
   * Get all arrays to string.
   */
  string ToString() {
    string _res = "";
    for (int i = 0; i < ArraySize(strings); i++) {
      _res += strings[i] + (string)dlm;
    }
    return _res;
  }

  /**
   * Remove separator character from the end of the string.
   */
  static void RemoveSepChar(string& text, string sep) {
    if (StringSubstr(text, StringLen(text) - 1) == sep) text = StringSubstr(text, 0, StringLen(text) - 1);
  }

  /**
   * Print multi-line text.
   */
  static void PrintText(string text) {
    ARRAY(string, _result);
    ushort usep = StringGetCharacter("\n", 0);
    for (int i = StringSplit(text, usep, _result) - 1; i >= 0; i--) {
      Print(_result[i]);
    }
  }

  /**
   * Returns the string copy with changed character in the specified position.
   *
   * @see https://www.mql5.com/en/articles/81
   */
  static string StringSetChar(string string_var, int pos, ushort character) {
#ifdef __MQLBUILD__
#ifdef __MQL4__
    // In MQL4 the character is symbol code in ASCII.
    return ::StringSetChar(string_var, pos, character);
#else  // __MQL5__
    string copy = string_var;
    // In MQL5 the character is symbol code in Unicode.
    StringSetCharacter(copy, pos, character);
    return copy;
#endif
#else  // C++
    printf("@fixme: %s\n", "StringSetChar()");
    return "";
#endif
  }
};
#endif  // STRING_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: String.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Data.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Data's defines.
 */

#ifndef __MQL4__
// --
#ifndef DoubleToStr
// Returns text string with the specified numerical value converted into a specified precision format.
#define DoubleToStr(value, digits) DoubleToString(value, digits)
#endif
#define StringGetChar StringGetCharacter
// --
#define StrToTime StringToTime
// --
#define DOUBLE_VALUE 0
#define FLOAT_VALUE 1
#define LONG_VALUE INT_VALUE
//---
#define EMPTY -1
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Data.define.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Order.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SymbolInfo.struct.static.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Terminal.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: MQL4.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Market.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Provide backward compatibility for MQL4 in MT5/MQL5.
 */

// Prevents processing this includes file for the second time.
#ifndef MQL4_MQH
#define MQL4_MQH

//+------------------------------------------------------------------+
//| Declaration of constants
//+------------------------------------------------------------------+

// Index in the order pool.
#ifndef SELECT_BY_POS
#define SELECT_BY_POS 0
#endif

// Some of standard MQL4 constants are absent in MQL5, therefore they should be declared as below.
#ifdef __MQL5__
#define show_inputs script_show_inputs
// --
#define extern input
// --
#define init OnInit
// --

// Defines macros for MQL5.
/* @fixme: Conflicts with SymbolInfo::Ask() method.
#define Ask SymbolInfo::GetAsk(_Symbol)
#define Bid SymbolInfo::GetAsk(_Symbol)
//#define Bid (::SymbolInfoDouble(_Symbol, ::SYMBOL_BID))
//#define Ask (::SymbolInfoDouble(_Symbol, ::SYMBOL_ASK))
*/

// Defines macros for MQL5.
/* @fixme: error: macro too complex
#define Day(void) DateTime::Day()
#define DayOfWeek(void) SymbolInfo::DayOfWeek()
#define DayOfYear(void) SymbolInfo::DayOfYear()
*/

// Define boolean values.
#define True true
#define False false
#define TRUE true
#define FALSE false
// --
/* @fixme: If this is defined, cannot call: DateTime::TimeToStr().
#ifndef TimeToStr
#define TimeToStr(time_value, flags) TimeToString(time_value, flags)
#endif
*/
// --
#define CurTime TimeCurrent
// --
#define LocalTime TimeLocal

#ifndef TRADE_ACTION_CLOSE_BY
#define TRADE_ACTION_CLOSE_BY 1
#endif

//+------------------------------------------------------------------+
//| Includes.
//+------------------------------------------------------------------+

/**
 * Returns market data about securities.
 */
/*

double MarketInfo(string _symbol, int _type) {
  return Market::MarketInfo(_symbol, _type);
}
*/

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string StringSetChar(const string &String_Var, const int iPos, const ushort Value) {
  string Str = String_Var;

  ::StringSetCharacter(Str, iPos, Value);

  return (Str);
}

#endif  // __MQL5__

#ifdef __MQL5__
#ifndef __MT4ORDERS__

#define __MT4ORDERS__

#define RESERVE_SIZE 1000
#define DAY (24 * 3600)
#define HISTORY_PAUSE (MT4HISTORY::IsTester ? 0 : 5)

class MT4HISTORY {
 private:
  static const bool IsTester;

  long Tickets[];
  uint Amount;

  datetime LastTime;

  int LastTotalDeals;
  int LastTotalOrders;

  datetime LastInitTime;

#define GETNEXTPOS_FUNCTION(NAME)                                           \
  static int GetNextPosMT4##NAME(int iPos) {                                \
    const int Total = ::History##NAME##sTotal();                            \
                                                                            \
    while (iPos < Total) {                                                  \
      if (MT4HISTORY::IsMT4##NAME(::History##NAME##GetTicket(iPos))) break; \
                                                                            \
      iPos++;                                                               \
    }                                                                       \
                                                                            \
    return (iPos);                                                          \
  }

  GETNEXTPOS_FUNCTION(Order)
  GETNEXTPOS_FUNCTION(Deal)

#undef GETNEXTPOS_FUNCTION

  bool RefreshHistory(void) {
    bool Res = false;

    const datetime LastTimeCurrent = ::TimeCurrent();

    if ((!MT4HISTORY::IsTester) && (LastTimeCurrent >= this.LastInitTime + DAY)) {
      this.LastTime = 0;

      this.LastTotalOrders = 0;
      this.LastTotalDeals = 0;

      this.Amount = 0;

      ::ArrayResize(this.Tickets, this.Amount, RESERVE_SIZE);

      this.LastInitTime = LastTimeCurrent;
    }

    if (::HistorySelect(this.LastTime, ::MathMax(LastTimeCurrent, this.LastTime) + DAY))  // Daily stock.
    {
      const int TotalOrders = ::HistoryOrdersTotal();
      const int TotalDeals = ::HistoryDealsTotal();

      Res = ((TotalOrders != this.LastTotalOrders) || (TotalDeals != this.LastTotalDeals));

      if (Res) {
        int iOrder = MT4HISTORY::GetNextPosMT4Order(this.LastTotalOrders);
        int iDeal = MT4HISTORY::GetNextPosMT4Deal(this.LastTotalDeals);

        long TimeOrder = (iOrder < TotalOrders)
                             ? ::HistoryOrderGetInteger(::HistoryOrderGetTicket(iOrder), ORDER_TIME_DONE /*_MSC*/)
                             : LONG_MAX;  // ORDER_TIME_DONE_MSC returns zero in the tester (build 1470).
        long TimeDeal = (iDeal < TotalDeals)
                            ? ::HistoryDealGetInteger(::HistoryDealGetTicket(iDeal), DEAL_TIME /*_MSC*/)
                            : LONG_MAX;

        while ((iDeal < TotalDeals) || (iOrder < TotalOrders))
          if (TimeOrder < TimeDeal) {
            this.Amount = ::ArrayResize(this.Tickets, this.Amount + 1, RESERVE_SIZE);

            this.Tickets[this.Amount - 1] = -(long)::HistoryOrderGetTicket(iOrder);

            iOrder = MT4HISTORY::GetNextPosMT4Order(iOrder + 1);

            TimeOrder = (iOrder < TotalOrders)
                            ? ::HistoryOrderGetInteger(::HistoryOrderGetTicket(iOrder), ORDER_TIME_DONE /*_MSC*/)
                            : LONG_MAX;  // ORDER_TIME_DONE_MSC returns zero in the tester (build 1470).
          } else {
            this.Amount = ::ArrayResize(this.Tickets, this.Amount + 1, RESERVE_SIZE);

            this.Tickets[this.Amount - 1] = (long)::HistoryDealGetTicket(iDeal);

            iDeal = MT4HISTORY::GetNextPosMT4Deal(iDeal + 1);

            TimeDeal = (iDeal < TotalDeals) ? ::HistoryDealGetInteger(::HistoryDealGetTicket(iDeal), DEAL_TIME /*_MSC*/)
                                            : LONG_MAX;
          }

        TimeOrder = (TotalOrders > 0)
                        ? ::HistoryOrderGetInteger(::HistoryOrderGetTicket(TotalOrders - 1), ORDER_TIME_DONE /*_MSC*/)
                        : 0;
        TimeDeal =
            (TotalDeals > 0) ? ::HistoryDealGetInteger(::HistoryDealGetTicket(TotalDeals - 1), DEAL_TIME /*_MSC*/) : 0;

        const long MaxTime = ::MathMax(TimeOrder, TimeDeal);

        this.LastTotalOrders = 0;
        this.LastTotalDeals = 0;

        if (LastTimeCurrent - HISTORY_PAUSE > MaxTime)
          this.LastTime = LastTimeCurrent - HISTORY_PAUSE;
        else {
          this.LastTime = (datetime)MaxTime;

          if (TimeOrder == MaxTime)
            for (int i = TotalOrders - 1; i >= 0; i--) {
              if (TimeOrder > ::HistoryOrderGetInteger(::HistoryOrderGetTicket(i), ORDER_TIME_DONE /*_MSC*/)) break;

              this.LastTotalOrders++;
            }

          if (TimeDeal == MaxTime)
            for (int i = TotalDeals - 1; i >= 0; i--) {
              if (TimeDeal != ::HistoryDealGetInteger(::HistoryDealGetTicket(TotalDeals - 1), DEAL_TIME /*_MSC*/))
                break;

              this.LastTotalDeals++;
            }
        }
      } else if (LastTimeCurrent - HISTORY_PAUSE > this.LastTime) {
        this.LastTime = LastTimeCurrent - HISTORY_PAUSE;

        this.LastTotalOrders = 0;
        this.LastTotalDeals = 0;
      }
    }

    return (Res);
  }

 public:
  static bool IsMT4Deal(const ulong Ticket) {
    const ENUM_DEAL_TYPE Type = (ENUM_DEAL_TYPE)::HistoryDealGetInteger(Ticket, DEAL_TYPE);

    return (((Type != DEAL_TYPE_BUY) && (Type != DEAL_TYPE_SELL)) ||
            ((ENUM_DEAL_ENTRY)::HistoryDealGetInteger(Ticket, DEAL_ENTRY) == DEAL_ENTRY_OUT));
  }

  static bool IsMT4Order(const ulong Ticket) {
    return ((::HistoryOrderGetDouble(Ticket, ORDER_VOLUME_CURRENT) > 0) ||
            (::HistoryOrderGetInteger(Ticket, ORDER_POSITION_ID) == 0));
  }

  MT4HISTORY(void) : Amount(0), LastTime(0), LastTotalDeals(0), LastTotalOrders(0), LastInitTime(0) {
    ::ArrayResize(this.Tickets, this.Amount, RESERVE_SIZE);

    this.RefreshHistory();
  }

  int GetAmount(void) {
    this.RefreshHistory();

    return ((int)this.Amount);
  }

  long operator[](const uint Pos) {
    long Res = 0;

    if (Pos >= this.Amount) {
      this.RefreshHistory();

      if (Pos < this.Amount) Res = this.Tickets[Pos];
    } else
      Res = this.Tickets[Pos];

    return (Res);
  }
};

static const bool MT4HISTORY::IsTester = (::MQLInfoInteger(MQL_TESTER) || ::MQLInfoInteger(MQL_OPTIMIZATION) ||
                                          ::MQLInfoInteger(MQL_VISUAL_MODE) || ::MQLInfoInteger(MQL_FRAME_MODE));

#undef HISTORY_PAUSE
#undef DAY
#undef RESERVE_SIZE

struct MT4_ORDER {
  int Ticket;
  int Type;

  double Lots;

  string Symbol;
  string Comment;

  double OpenPrice;
  datetime OpenTime;

  double StopLoss;
  double TakeProfit;

  double ClosePrice;
  datetime CloseTime;

  datetime Expiration;

  int MagicNumber;

  double Profit;

  double Commission;
  double Swap;

  string ToString(void) const {
    static const string Types[] = {"buy", "sell", "buy limit", "sell limit", "buy stop", "sell stop", "balance"};
    const int digits = (int)::SymbolInfoInteger(this.Symbol, SYMBOL_DIGITS);

    return ("#" + (string)this.Ticket + " " + (string)this.OpenTime + " " +
            ((this.Type < ::ArraySize(Types)) ? Types[this.Type] : "unknown") + " " + ::DoubleToString(this.Lots, 2) +
            " " + this.Symbol + " " + ::DoubleToString(this.OpenPrice, digits) + " " +
            ::DoubleToString(this.StopLoss, digits) + " " + ::DoubleToString(this.TakeProfit, digits) + " " +
            ((this.CloseTime > 0) ? ((string)this.CloseTime + " ") : "") + ::DoubleToString(this.ClosePrice, digits) +
            " " + ::DoubleToString(this.Commission, 2) + " " + ::DoubleToString(this.Swap, 2) + " " +
            ::DoubleToString(this.Profit, 2) + " " + ((this.Comment == "") ? "" : (this.Comment + " ")) +
            (string)this.MagicNumber + (((this.Expiration > 0) ? (" expiration " + (string)this.Expiration) : "")));
  }
};

class MT4ORDERS {
 private:
  static MT4_ORDER Order;
  static MT4HISTORY History;

  static const bool IsTester;

  static ulong GetPositionDealIn(const ulong PositionIdentifier = 0) {
    ulong Ticket = 0;

    if ((PositionIdentifier == 0) ? ::HistorySelectByPosition(::PositionGetInteger(POSITION_IDENTIFIER))
                                  : ::HistorySelectByPosition(PositionIdentifier)) {
      const int Total = ::HistoryDealsTotal();

      for (int i = 0; i < Total; i++) {
        const ulong TicketDeal = ::HistoryDealGetTicket(i);

        if (TicketDeal > 0)
          if ((ENUM_DEAL_ENTRY)::HistoryDealGetInteger(TicketDeal, DEAL_ENTRY) == DEAL_ENTRY_IN) {
            Ticket = TicketDeal;

            break;
          }
      }
    }

    return (Ticket);
  }

  static double GetPositionCommission(void) {
    double Commission = ::PositionGetDouble(POSITION_COMMISSION);

    if (Commission == 0) {
      const ulong Ticket = MT4ORDERS::GetPositionDealIn();

      if (Ticket > 0) {
        const double LotsIn = ::HistoryDealGetDouble(Ticket, DEAL_VOLUME);

        if (LotsIn > 0)
          Commission = ::HistoryDealGetDouble(Ticket, DEAL_COMMISSION) * ::PositionGetDouble(POSITION_VOLUME) / LotsIn;
      }
    }

    return (Commission);
  }

  static string GetPositionComment(void) {
    string comment = ::PositionGetString(POSITION_COMMENT);

    if (comment == "") {
      const ulong Ticket = MT4ORDERS::GetPositionDealIn();

      if (Ticket > 0) comment = ::HistoryDealGetString(Ticket, DEAL_COMMENT);
    }

    return (comment);
  }

  static void GetPositionData(void) {
    MT4ORDERS::Order.Ticket = (int)::PositionGetInteger(POSITION_TICKET);
    MT4ORDERS::Order.Type = (int)::PositionGetInteger(POSITION_TYPE);

    MT4ORDERS::Order.Lots = ::PositionGetDouble(POSITION_VOLUME);

    MT4ORDERS::Order.Symbol = ::PositionGetString(POSITION_SYMBOL);
    MT4ORDERS::Order.Comment = MT4ORDERS::GetPositionComment();

    MT4ORDERS::Order.OpenPrice = ::PositionGetDouble(POSITION_PRICE_OPEN);
    MT4ORDERS::Order.OpenTime = (datetime)::PositionGetInteger(POSITION_TIME);

    MT4ORDERS::Order.StopLoss = ::PositionGetDouble(POSITION_SL);
    MT4ORDERS::Order.TakeProfit = ::PositionGetDouble(POSITION_TP);

    MT4ORDERS::Order.ClosePrice = ::PositionGetDouble(POSITION_PRICE_CURRENT);
    MT4ORDERS::Order.CloseTime = 0;

    MT4ORDERS::Order.Expiration = 0;

    MT4ORDERS::Order.MagicNumber = (int)::PositionGetInteger(POSITION_MAGIC);

    MT4ORDERS::Order.Profit = ::PositionGetDouble(POSITION_PROFIT);

    MT4ORDERS::Order.Commission = MT4ORDERS::GetPositionCommission();
    MT4ORDERS::Order.Swap = ::PositionGetDouble(POSITION_SWAP);

    return;
  }

  static void GetOrderData(void) {
    MT4ORDERS::Order.Ticket = (int)::OrderGetInteger(ORDER_TICKET);
    MT4ORDERS::Order.Type = (int)::OrderGetInteger(ORDER_TYPE);

    MT4ORDERS::Order.Lots = ::OrderGetDouble(ORDER_VOLUME_CURRENT);

    MT4ORDERS::Order.Symbol = ::OrderGetString(ORDER_SYMBOL);
    MT4ORDERS::Order.Comment = ::OrderGetString(ORDER_COMMENT);

    MT4ORDERS::Order.OpenPrice = ::OrderGetDouble(ORDER_PRICE_OPEN);
    MT4ORDERS::Order.OpenTime = (datetime)::OrderGetInteger(ORDER_TIME_SETUP);

    MT4ORDERS::Order.StopLoss = ::OrderGetDouble(ORDER_SL);
    MT4ORDERS::Order.TakeProfit = ::OrderGetDouble(ORDER_TP);

    MT4ORDERS::Order.ClosePrice = ::OrderGetDouble(ORDER_PRICE_CURRENT);
    MT4ORDERS::Order.CloseTime = (datetime)::OrderGetInteger(ORDER_TIME_DONE);

    MT4ORDERS::Order.Expiration = (datetime)::OrderGetInteger(ORDER_TIME_EXPIRATION);

    MT4ORDERS::Order.MagicNumber = (int)::OrderGetInteger(ORDER_MAGIC);

    MT4ORDERS::Order.Profit = 0;

    MT4ORDERS::Order.Commission = 0;
    MT4ORDERS::Order.Swap = 0;

    return;
  }

  static void GetHistoryOrderData(const ulong Ticket) {
    MT4ORDERS::Order.Ticket = (int)::HistoryOrderGetInteger(Ticket, ORDER_TICKET);
    MT4ORDERS::Order.Type = (int)::HistoryOrderGetInteger(Ticket, ORDER_TYPE);

    MT4ORDERS::Order.Lots = ::HistoryOrderGetDouble(Ticket, ORDER_VOLUME_CURRENT);

    if (MT4ORDERS::Order.Lots == 0) MT4ORDERS::Order.Lots = ::HistoryOrderGetDouble(Ticket, ORDER_VOLUME_INITIAL);

    MT4ORDERS::Order.Symbol = ::HistoryOrderGetString(Ticket, ORDER_SYMBOL);
    MT4ORDERS::Order.Comment = ::HistoryOrderGetString(Ticket, ORDER_COMMENT);

    MT4ORDERS::Order.OpenPrice = ::HistoryOrderGetDouble(Ticket, ORDER_PRICE_OPEN);
    MT4ORDERS::Order.OpenTime = (datetime)::HistoryOrderGetInteger(Ticket, ORDER_TIME_SETUP);

    MT4ORDERS::Order.StopLoss = ::HistoryOrderGetDouble(Ticket, ORDER_SL);
    MT4ORDERS::Order.TakeProfit = ::HistoryOrderGetDouble(Ticket, ORDER_TP);

    MT4ORDERS::Order.ClosePrice = 0;
    MT4ORDERS::Order.CloseTime = (datetime)::HistoryOrderGetInteger(Ticket, ORDER_TIME_DONE);

    MT4ORDERS::Order.Expiration = (datetime)::HistoryOrderGetInteger(Ticket, ORDER_TIME_EXPIRATION);

    MT4ORDERS::Order.MagicNumber = (int)::HistoryOrderGetInteger(Ticket, ORDER_MAGIC);

    MT4ORDERS::Order.Profit = 0;

    MT4ORDERS::Order.Commission = 0;
    MT4ORDERS::Order.Swap = 0;

    return;
  }

  static void GetHistoryPositionData(const ulong Ticket) {
    MT4ORDERS::Order.Ticket = (int)::HistoryDealGetInteger(Ticket, DEAL_TICKET);
    MT4ORDERS::Order.Type = (int)::HistoryDealGetInteger(Ticket, DEAL_TYPE);

    if ((MT4ORDERS::Order.Type > OP_SELL))
      MT4ORDERS::Order.Type += (OP_BALANCE - OP_SELL - 1);
    else
      MT4ORDERS::Order.Type = 1 - MT4ORDERS::Order.Type;

    MT4ORDERS::Order.Lots = ::HistoryDealGetDouble(Ticket, DEAL_VOLUME);

    MT4ORDERS::Order.Symbol = ::HistoryDealGetString(Ticket, DEAL_SYMBOL);
    MT4ORDERS::Order.Comment = ::HistoryDealGetString(Ticket, DEAL_COMMENT);

    MT4ORDERS::Order.OpenPrice = ::HistoryDealGetDouble(Ticket, DEAL_PRICE);
    MT4ORDERS::Order.OpenTime = (datetime)::HistoryDealGetInteger(Ticket, DEAL_TIME);

    MT4ORDERS::Order.StopLoss = 0;
    MT4ORDERS::Order.TakeProfit = 0;

    MT4ORDERS::Order.ClosePrice = ::HistoryDealGetDouble(Ticket, DEAL_PRICE);
    MT4ORDERS::Order.CloseTime = (datetime)::HistoryDealGetInteger(Ticket, DEAL_TIME);
    ;

    MT4ORDERS::Order.Expiration = 0;

    MT4ORDERS::Order.MagicNumber = (int)::HistoryDealGetInteger(Ticket, DEAL_MAGIC);

    MT4ORDERS::Order.Profit = ::HistoryDealGetDouble(Ticket, DEAL_PROFIT);

    MT4ORDERS::Order.Commission = ::HistoryDealGetDouble(Ticket, DEAL_COMMISSION);
    MT4ORDERS::Order.Swap = ::HistoryDealGetDouble(Ticket, DEAL_SWAP);

    const ulong OpenTicket = MT4ORDERS::GetPositionDealIn(::HistoryDealGetInteger(Ticket, DEAL_POSITION_ID));

    if (OpenTicket > 0) {
      MT4ORDERS::Order.OpenPrice = ::HistoryDealGetDouble(OpenTicket, DEAL_PRICE);
      MT4ORDERS::Order.OpenTime = (datetime)::HistoryDealGetInteger(OpenTicket, DEAL_TIME);

      const double OpenLots = ::HistoryDealGetDouble(OpenTicket, DEAL_VOLUME);

      if (OpenLots > 0)
        MT4ORDERS::Order.Commission +=
            ::HistoryDealGetDouble(OpenTicket, DEAL_COMMISSION) * MT4ORDERS::Order.Lots / OpenLots;

      if (MT4ORDERS::Order.MagicNumber == 0)
        MT4ORDERS::Order.MagicNumber = (int)::HistoryDealGetInteger(OpenTicket, DEAL_MAGIC);

      if (MT4ORDERS::Order.Comment == "") MT4ORDERS::Order.Comment = ::HistoryDealGetString(OpenTicket, DEAL_COMMENT);
    }

    return;
  }

  static bool Waiting(const bool FlagInit = false) {
    static ulong StartTime = 0;

    if (FlagInit) StartTime = ::GetMicrosecondCount();

    const bool Res = (::GetMicrosecondCount() - StartTime < MT4ORDERS::OrderSend_MaxPause);

    if (Res) ::Sleep(0);

    return (Res);
  }

  static bool EqualPrices(const double Price1, const double Price2, const int digits) {
    return (::NormalizeDouble(Price1 - Price2, digits) == 0);
  }

#define WHILE(A) while (!(Res = (A)) && MT4ORDERS::Waiting())

  static bool OrderSend(const MqlTradeRequest &Request, MqlTradeResult &Result) {
    bool Res = ::OrderSend(Request, Result);

    if (Res && !MT4ORDERS::IsTester && (Result.retcode < TRADE_RETCODE_ERROR) && (MT4ORDERS::OrderSend_MaxPause > 0)) {
      Res = (Result.retcode == TRADE_RETCODE_DONE);
      MT4ORDERS::Waiting(true);

      if (Request.action == TRADE_ACTION_DEAL) {
        WHILE(::HistoryOrderSelect(Result.order));

        Res = Res && (((ENUM_ORDER_STATE)::HistoryOrderGetInteger(Result.order, ORDER_STATE) == ORDER_STATE_FILLED) ||
                      ((ENUM_ORDER_STATE)::HistoryOrderGetInteger(Result.order, ORDER_STATE) == ORDER_STATE_PARTIAL));

        if (Res) WHILE(::HistoryDealSelect(Result.deal));
      } else if (Request.action == TRADE_ACTION_PENDING) {
        if (Res)
          WHILE(::OrderSelect(Result.order));
        else {
          WHILE(::HistoryOrderSelect(Result.order));

          Res = false;
        }
      } else if (Request.action == TRADE_ACTION_SLTP) {
        if (Res) {
          bool EqualSL = false;
          bool EqualTP = false;

          const int digits = (int)::SymbolInfoInteger(Request.symbol, SYMBOL_DIGITS);

          if ((Request.position == 0) ? ::PositionSelect(Request.symbol) : ::PositionSelectByTicket(Request.position)) {
            EqualSL = MT4ORDERS::EqualPrices(::PositionGetDouble(POSITION_SL), Request.sl, digits);
            EqualTP = MT4ORDERS::EqualPrices(::PositionGetDouble(POSITION_TP), Request.tp, digits);
          }

          WHILE((EqualSL && EqualTP))
          if ((Request.position == 0) ? ::PositionSelect(Request.symbol) : ::PositionSelectByTicket(Request.position)) {
            EqualSL = MT4ORDERS::EqualPrices(::PositionGetDouble(POSITION_SL), Request.sl, digits);
            EqualTP = MT4ORDERS::EqualPrices(::PositionGetDouble(POSITION_TP), Request.tp, digits);
          }
        }
      } else if (Request.action == TRADE_ACTION_MODIFY) {
        if (Res) {
          bool EqualSL = false;
          bool EqualTP = false;

          const int digits = (int)::SymbolInfoInteger(Request.symbol, SYMBOL_DIGITS);

          if (::OrderSelect(Result.order)) {
            EqualSL = MT4ORDERS::EqualPrices(::OrderGetDouble(ORDER_SL), Request.sl, digits);
            EqualTP = MT4ORDERS::EqualPrices(::OrderGetDouble(ORDER_TP), Request.tp, digits);
          }

          WHILE((EqualSL && EqualTP))
          if (::OrderSelect(Result.order)) {
            EqualSL = MT4ORDERS::EqualPrices(::OrderGetDouble(ORDER_SL), Request.sl, digits);
            EqualTP = MT4ORDERS::EqualPrices(::OrderGetDouble(ORDER_TP), Request.tp, digits);
          }
        }
      } else if (Request.action == TRADE_ACTION_REMOVE)
        if (Res) WHILE(::HistoryOrderSelect(Result.order));
    }

    return (Res);
  }

#undef WHILE

  static bool NewOrderSend(const MqlTradeRequest &Request) {
    MqlTradeResult Result;

    return (MT4ORDERS::OrderSend(Request, Result) ? Result.retcode < TRADE_RETCODE_ERROR : false);
  }

  static bool ModifyPosition(const ulong Ticket, MqlTradeRequest &Request) {
    const bool Res = ::PositionSelectByTicket(Ticket);

    if (Res) {
      Request.action = TRADE_ACTION_SLTP;

      Request.position = Ticket;
      Request.symbol = ::PositionGetString(POSITION_SYMBOL);
    }

    return (Res);
  }

  static ENUM_ORDER_TYPE_FILLING GetFilling(const string Symb, const uint Type = ORDER_FILLING_FOK) {
    const ENUM_SYMBOL_TRADE_EXECUTION ExeMode =
        (ENUM_SYMBOL_TRADE_EXECUTION)::SymbolInfoInteger(Symb, SYMBOL_TRADE_EXEMODE);
    const int FillingMode = (int)::SymbolInfoInteger(Symb, SYMBOL_FILLING_MODE);

    return ((FillingMode == 0 || (Type >= ORDER_FILLING_RETURN) || ((FillingMode & (Type + 1)) != Type + 1))
                ? (((ExeMode == SYMBOL_TRADE_EXECUTION_EXCHANGE) || (ExeMode == SYMBOL_TRADE_EXECUTION_INSTANT))
                       ? ORDER_FILLING_RETURN
                       : ((FillingMode == SYMBOL_FILLING_IOC) ? ORDER_FILLING_IOC : ORDER_FILLING_FOK))
                : (ENUM_ORDER_TYPE_FILLING)Type);
  }

  static bool ModifyOrder(const ulong _ticket, const double _price, const datetime _expiration,
                          MqlTradeRequest &Request) {
    const bool _res = ::OrderSelect(_ticket);

    if (_res) {
      Request.action = TRADE_ACTION_MODIFY;
      Request.order = _ticket;

      Request.price = _price;

      Request.symbol = ::OrderGetString(ORDER_SYMBOL);

      Request.type_filling = MT4ORDERS::GetFilling(Request.symbol);

      if (_expiration > 0) {
        Request.type_time = ORDER_TIME_SPECIFIED;
        Request.expiration = _expiration;
      }
    }

    return (_res);
  }

 public:
  static bool SelectByPosHistory(const int Index) {
    const int Ticket = (int)MT4ORDERS::History[Index];
    const bool Res =
        (Ticket > 0) ? ::HistoryDealSelect(Ticket) : ((Ticket < 0) ? ::HistoryOrderSelect(-Ticket) : false);

    if (Res) {
      if (Ticket > 0)
        MT4ORDERS::GetHistoryPositionData(Ticket);
      else
        MT4ORDERS::GetHistoryOrderData(-Ticket);
    }

    return (Res);
  }

  // position has higher priority
  static bool SelectByPos(const int Index) {
    const int Total = ::PositionsTotal();
    const bool Flag = (Index < Total);

    const bool Res =
        (Flag) ? ::PositionSelectByTicket(::PositionGetTicket(Index)) : ::OrderSelect(::OrderGetTicket(Index - Total));

    if (Res) {
      if (Flag)
        MT4ORDERS::GetPositionData();
      else
        MT4ORDERS::GetOrderData();
    }

    return (Res);
  }

  static bool SelectByHistoryTicket(const int Ticket) {
    bool Res = ::HistoryDealSelect(Ticket) ? MT4HISTORY::IsMT4Deal(Ticket) : false;

    if (Res)
      MT4ORDERS::GetHistoryPositionData(Ticket);
    else {
      Res = ::HistoryOrderSelect(Ticket) ? MT4HISTORY::IsMT4Order(Ticket) : false;

      if (Res) MT4ORDERS::GetHistoryOrderData(Ticket);
    }

    return (Res);
  }

  static bool SelectByExistingTicket(const int Ticket) {
    bool Res = true;

    if (::PositionSelectByTicket(Ticket))
      MT4ORDERS::GetPositionData();
    else if (::OrderSelect(Ticket))
      MT4ORDERS::GetOrderData();
    else
      Res = false;

    return (Res);
  }

  // One Ticket priority:
  // MODE_TRADES:  exist position > exist order > deal > canceled order
  // MODE_HISTORY: deal > canceled order > exist position > exist order
  static bool SelectByTicket(const int Ticket, const int Pool = MODE_TRADES) {
    return ((Pool == MODE_TRADES)
                ? (MT4ORDERS::SelectByExistingTicket(Ticket) ? true : MT4ORDERS::SelectByHistoryTicket(Ticket))
                : (MT4ORDERS::SelectByHistoryTicket(Ticket) ? true : MT4ORDERS::SelectByExistingTicket(Ticket)));
  }

 public:
  static uint OrderSend_MaxPause;

  static bool MT4OrderSelect(const int Index, const int Select, const int Pool = MODE_TRADES) {
    return ((Select == SELECT_BY_POS)
                ? ((Pool == MODE_TRADES) ? MT4ORDERS::SelectByPos(Index) : MT4ORDERS::SelectByPosHistory(Index))
                : MT4ORDERS::SelectByTicket(Index, Pool));
  }

  // MT5 OrderSelect
  static bool MT4OrderSelect(const ulong Ticket) { return (::OrderSelect(Ticket)); }

  static int MT4OrdersTotal(void) { return (::OrdersTotal() + ::PositionsTotal()); }

  // MT5 OrdersTotal
  static int MT4OrdersTotal(const bool MT5) { return (::OrdersTotal()); }

  static int MT4OrdersHistoryTotal(void) { return (MT4ORDERS::History.GetAmount()); }

  static int MT4OrderSend(const string Symb, const int Type, const double dVolume, const double _price,
                          const int SlipPage, const double SL, const double TP, const string comment = NULL,
                          const int magic = 0, const datetime dExpiration = 0, color arrow_color = clrNONE) {
    MqlTradeRequest Request = {0};

    Request.action = (((Type == OP_BUY) || (Type == OP_SELL)) ? TRADE_ACTION_DEAL : TRADE_ACTION_PENDING);
    Request.magic = magic;

    Request.symbol = ((Symb == NULL) ? ::Symbol() : Symb);
    Request.volume = dVolume;
    Request.price = _price;

    Request.tp = TP;
    Request.sl = SL;
    Request.deviation = SlipPage;
    Request.type = (ENUM_ORDER_TYPE)Type;

    Request.type_filling = MT4ORDERS::GetFilling(Request.symbol, (uint)Request.deviation);

    if (dExpiration > 0) {
      Request.type_time = ORDER_TIME_SPECIFIED;
      Request.expiration = dExpiration;
    }

    Request.comment = comment;

    MqlTradeResult Result;

    return (MT4ORDERS::OrderSend(Request, Result)
                ? ((Request.action == TRADE_ACTION_DEAL)
                       ? (::HistoryDealSelect(Result.deal) ? (int)::HistoryDealGetInteger(Result.deal, DEAL_POSITION_ID)
                                                           : -1)
                       : (int)Result.order)
                : -1);
  }

  static bool MT4OrderModify(const ulong Ticket, const double _price, const double SL, const double TP,
                             const datetime Expiration, const color Arrow_Color = clrNONE) {
    MqlTradeRequest Request = {0};

    // considered case if order and position has the same ticket
    bool Res =
        ((Ticket != MT4ORDERS::Order.Ticket) || (MT4ORDERS::Order.Ticket <= OP_SELL))
            ? (MT4ORDERS::ModifyPosition(Ticket, Request) ? true
                                                          : MT4ORDERS::ModifyOrder(Ticket, _price, Expiration, Request))
            : (MT4ORDERS::ModifyOrder(Ticket, _price, Expiration, Request)
                   ? true
                   : MT4ORDERS::ModifyPosition(Ticket, Request));

    if (Res) {
      Request.tp = TP;
      Request.sl = SL;

      Res = MT4ORDERS::NewOrderSend(Request);
    }

    return (Res);
  }

  static bool MT4OrderClose(const ulong Ticket, const double dLots, const double _price, const int SlipPage,
                            const color Arrow_Color = clrNONE) {
    bool Res = ::PositionSelectByTicket(Ticket);

    if (Res) {
      MqlTradeRequest Request = {0};

      Request.action = TRADE_ACTION_DEAL;
      Request.position = Ticket;

      Request.symbol = ::PositionGetString(POSITION_SYMBOL);

      Request.volume = dLots;
      Request.price = _price;

      Request.deviation = SlipPage;

      Request.type = (ENUM_ORDER_TYPE)(1 - ::PositionGetInteger(POSITION_TYPE));

      Request.type_filling = MT4ORDERS::GetFilling(Request.symbol, (uint)Request.deviation);

      Res = MT4ORDERS::NewOrderSend(Request);
    }

    return (Res);
  }

  static bool MT4OrderCloseBy(const ulong Ticket, const int Opposite, const color Arrow_color) {
    bool Res = ::PositionSelectByTicket(Ticket);

    if (Res) {
      string _symbol = ::PositionGetString(POSITION_SYMBOL);
      ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)::PositionGetInteger(POSITION_TYPE);

      if (!PositionSelectByTicket(Opposite)) return (false);

      string symbol_by = ::PositionGetString(POSITION_SYMBOL);
      ENUM_POSITION_TYPE type_by = (ENUM_POSITION_TYPE)::PositionGetInteger(POSITION_TYPE);

      if (type == type_by) return (false);
      if (_symbol != symbol_by) return (false);

      MqlTradeRequest Request = {0};

      Request.action = TRADE_ACTION_CLOSE_BY;
      Request.position = Ticket;
      Request.position_by = Opposite;

      Res = MT4ORDERS::NewOrderSend(Request);
    }
    return (Res);
  }

  static bool MT4OrderDelete(const ulong Ticket, const color Arrow_Color = clrNONE) {
    bool Res = ::OrderSelect(Ticket);

    if (Res) {
      MqlTradeRequest Request = {0};

      Request.action = TRADE_ACTION_REMOVE;
      Request.order = Ticket;

      Res = MT4ORDERS::NewOrderSend(Request);
    }

    return (Res);
  }
};

static MT4_ORDER MT4ORDERS::Order = {0};

static MT4HISTORY MT4ORDERS::History;

static const bool MT4ORDERS::IsTester = (::MQLInfoInteger(MQL_TESTER) || ::MQLInfoInteger(MQL_OPTIMIZATION) ||
                                         ::MQLInfoInteger(MQL_VISUAL_MODE) || ::MQLInfoInteger(MQL_FRAME_MODE));

static uint MT4ORDERS::OrderSend_MaxPause = 1000000;  // Maximum time synchronization in microseconds.

bool OrderClose(const ulong Ticket, const double dLots, const double _price, const int SlipPage,
                const color Arrow_Color = clrNONE) {
  return (MT4ORDERS::MT4OrderClose(Ticket, dLots, _price, SlipPage, Arrow_Color));
}

bool OrderModify(const ulong Ticket, const double _price, const double SL, const double TP, const datetime Expiration,
                 const color Arrow_Color = clrNONE) {
  return (MT4ORDERS::MT4OrderModify(Ticket, _price, SL, TP, Expiration, Arrow_Color));
}

bool OrderDelete(const ulong Ticket, const color Arrow_Color = clrNONE) {
  return (MT4ORDERS::MT4OrderDelete(Ticket, Arrow_Color));
}

bool OrderCloseBy(const ulong Ticket, const int Opposite, const color Arrow_color) {
  return (MT4ORDERS::MT4OrderCloseBy(Ticket, Opposite, Arrow_color));
}

#endif  // __MT4ORDERS__
#endif  // __MQL5__

/**
 * MQL4 wrapper to work in MQL5.
 */
class MQL4 {
 public:
  /**
   * Converts MQL4 time periods.
   *
   * As in MQL5 chart period constants changed, and some new time periods (M2, M3, M4, M6, M10, M12, H2, H3, H6, H8,
   * H12) were added.
   *
   * Note: In MQL5 the numerical values of chart timeframe constants (from H1)
   * are not equal to the number of minutes of a bar.
   * E.g. In MQL5, the value of constant PERIOD_H1 is 16385, but in MQL4 PERIOD_H1=60.
   *
   * @see: https://www.mql5.com/en/articles/81
   */
  static ENUM_TIMEFRAMES TFMigrate(int _tf) {
    switch (_tf) {
      case 0:
        return (PERIOD_CURRENT);
      case 1:
        return (PERIOD_M1);
      case 2:
        return (PERIOD_M2);
      case 3:
        return (PERIOD_M3);
      case 4:
        return (PERIOD_M4);
      case 5:
        return (PERIOD_M5);
      case 6:
        return (PERIOD_M6);
      case 10:
        return (PERIOD_M10);
      case 12:
        return (PERIOD_M12);
      case 15:
        return (PERIOD_M15);
      case 30:
        return (PERIOD_M30);
      case 60:
        return (PERIOD_H1);
      case 240:
        return (PERIOD_H4);
      case 1440:
        return (PERIOD_D1);
      case 10080:
        return (PERIOD_W1);
      case 43200:
        return (PERIOD_MN1);
      case 16385:
        return (PERIOD_H1);
      case 16386:
        return (PERIOD_H2);
      case 16387:
        return (PERIOD_H3);
      case 16388:
        return (PERIOD_H4);
      case 16390:
        return (PERIOD_H6);
      case 16392:
        return (PERIOD_H8);
      case 16396:
        return (PERIOD_H12);
      case 16408:
        return (PERIOD_D1);
      case 32769:
        return (PERIOD_W1);
      case 49153:
        return (PERIOD_MN1);
      default:
        return (PERIOD_CURRENT);
    }
  }

  ENUM_MA_METHOD MethodMigrate(int method) {
    switch (method) {
      case 0:
        return (MODE_SMA);
      case 1:
        return (MODE_EMA);
      case 2:
        return (MODE_SMMA);
      case 3:
        return (MODE_LWMA);
      default:
        return (MODE_SMA);
    }
  }

  ENUM_APPLIED_PRICE PriceMigrate(int price) {
    switch (price) {
      case 1:
        return (PRICE_CLOSE);
      case 2:
        return (PRICE_OPEN);
      case 3:
        return (PRICE_HIGH);
      case 4:
        return (PRICE_LOW);
      case 5:
        return (PRICE_MEDIAN);
      case 6:
        return (PRICE_TYPICAL);
      case 7:
        return (PRICE_WEIGHTED);
      default:
        return (PRICE_CLOSE);
    }
  }

  ENUM_STO_PRICE StoFieldMigrate(int field) {
    switch (field) {
      case 0:
        return (STO_LOWHIGH);
      case 1:
        return (STO_CLOSECLOSE);
      default:
        return (STO_LOWHIGH);
    }
  }
};
#endif  // MQL4_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: MQL4.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: String.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.define.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Terminal.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Terminal's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Terminal.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Refs.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: MQL5.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Class to provide methods for state checking of the client terminal.
 *
 * @docs
 * - https://docs.mql4.com/chart_operations/chartredraw
 * - https://www.mql5.com/en/docs/chart_operations
 */

// Forward declaration.
class Terminal;

// Prevents processing this includes file for the second time.
#ifndef TERMINAL_MQH
#define TERMINAL_MQH

// Includes.









#ifdef __MQL5__
// Provide backward compatibility for MQL4 in MQL5.
//
#else
// Provides forward compatibility for MQL5 in MQL4.

#endif

/**
 * Class to provide functions that return parameters of the current terminal.
 */
class Terminal : public Object {
 public:
  /**
   * Class constructor.
   */
  Terminal() {}

  /**
   * Class deconstructor.
   */
  ~Terminal() {}

  /* Client Terminal property getters */

  /**
   * The client terminal build number.
   */
  static int GetBuild() { return Terminal::TerminalInfoInteger(TERMINAL_BUILD); }

  /**
   * Name of the program executed.
   */
  static string WindowExpertName(void) { return (::MQLInfoString(::MQL_PROGRAM_NAME)); }

  /**
   * Indicates the tester process.
   *
   * Checks if the Expert Advisor runs in the testing mode.
   */
  static bool IsTesting() {
#ifdef __MQL4__
    return ::IsTesting();
#else
    return (bool)MQLInfoInteger(MQL_TESTER);
#endif
  }

  /**
   * Indicates the optimization process.
   *
   * Checks if Expert Advisor runs in the Strategy Tester optimization mode.
   */
  static bool IsOptimization() {
#ifdef __MQL4__
    return ::IsOptimization();
#else
    return (bool)MQLInfoInteger(MQL_OPTIMIZATION);
#endif
  }

  /**
   * Checks if the Expert Advisor is tested in visual mode.
   */
  static bool IsVisualMode() {
#ifdef __MQL4__
    return ::IsVisualMode();
#else
    return (bool)MQLInfoInteger(MQL_VISUAL_MODE);
#endif
  }

  /**
   * Checks if the Expert Advisor is tested for real time mode
   * outside of the Strategy Tester.
   *
   * Note: It does not take into the account scripts.
   */
  static bool IsRealtime() {
    if (!IsTesting() && !IsOptimization() && !IsVisualMode()) {
      return (true);
    } else {
      return (false);
    }
  }

  /* State Checking methods */

  /**
   * Returns the contents of the system variable _LastError.
   *
   * @return
   * Returns the value of the last error that occurred during the execution of an program.
   *
   * @see
   * - https://docs.mql4.com/check/getlasterror
   * - https://www.mql5.com/en/docs/check/getlasterror
   */
  static int GetLastError() { return ::GetLastError(); }

  /**
   * Check if some error occured.
   *
   * @return
   * Returns true if the value of the last error indicates error.
   */
  static bool HasError() { return Terminal::GetLastError() > ERR_NO_ERROR; }

  /**
   * Checks the forced shutdown of an program.
   *
   * @return
   * Returns true, if the _StopFlag system variable contains a value other than 0.
   *
   * @see
   * - https://docs.mql4.com/check/isstopped
   * - https://www.mql5.com/en/docs/check/isstopped
   */
  static bool IsStopped() { return ::IsStopped(); }

  // UninitializeReason
  // MQLInfoInteger
  // MQLInfoString
  // MQLSetInteger
  // Symbol
  // Period
  // Digits
  // Point

  /**
   * Indicates the permission to use DLL files.
   */
  static bool IsDllsAllowed() {
    return Terminal::TerminalInfoInteger(TERMINAL_DLLS_ALLOWED) && MQLInfoInteger(MQL_DLLS_ALLOWED);
  }

  /**
   * Checks if Expert Advisors are enabled for running.
   *
   * @docs: https://docs.mql4.com/check/isexpertenabled
   */
  static bool IsExpertEnabled() {
#ifdef __MQL4__
    return ::IsExpertEnabled();
#else  // __MQL5__
    // In MQL5 there is no equivalent function,
    // so checks only the permission to trade.
    return (bool)Terminal::TerminalInfoInteger(TERMINAL_TRADE_ALLOWED);
#endif
  }

  /**
   * Indicates the permission to use external libraries (such as DLL).
   */
  static bool IsLibrariesAllowed() {
    return Terminal::TerminalInfoInteger(TERMINAL_DLLS_ALLOWED) && MQLInfoInteger(MQL_DLLS_ALLOWED);
  }

  /**
   * Indicates the permission to trade.
   *
   * Check the permission to trade at the running program level and at the terminal level.
   */
  static bool IsTradeAllowed() {
    return (bool)MQLInfoInteger(MQL_TRADE_ALLOWED) && (bool)Terminal::TerminalInfoInteger(TERMINAL_TRADE_ALLOWED);
  }

  /**
   * Checks whether context is occupied.
   *
   * @return
   * Returns true if context is occupied with an expert trading operation,
   * another expert or script cannot call trading functions at that moment due to error 146 (ERR_TRADE_CONTEXT_BUSY).
   */
  static bool IsTradeContextBusy() {
#ifdef __MQL4__
    return ::IsTradeContextBusy();
#else
    return false;
#endif
  }

  /**
   * The flag indicates the presence of MQL5.community authorization data in the terminal.
   *
   * Note: In the latest build, it returns ERR_TERMINAL_WRONG_PROPERTY (4513).
   */
  static bool HasCommunityAccount() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_COMMUNITY_ACCOUNT); }

  /**
   * Check connection to MQL5 community.
   *
   * Note: In the latest build, it returns ERR_FUNCTION_NOT_ALLOWED (4014).
   */
  static bool IsCommunityConnected() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_COMMUNITY_CONNECTION); }

  /**
   * Get MQL5 community balance.
   *
   * Note: In the latest build, it returns ERR_FUNCTION_NOT_ALLOWED (4014).
   */
  static double GetCommunityBalance() { return Terminal::TerminalInfoDouble(TERMINAL_COMMUNITY_BALANCE); }

  /**
   * Checks connection to a trade server.
   *
   * @see
   * - https://docs.mql4.com/check/isconnected
   * - https://www.mql5.com/en/docs/constants/environment_state/terminalstatus
   */
  static bool IsConnected() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_CONNECTED); }

  /**
   * Permission to send e-mails using SMTP-server and login, specified in the terminal settings.
   */
  static bool IsEmailEnabled() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_EMAIL_ENABLED); }

  /**
   * Permission to send reports using FTP-server and login, specified in the terminal settings.
   */
  static bool IsFtpEnabled() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_FTP_ENABLED); }

  /**
   * Permission to send notifications to smartphone.
   *
   * Note: In the latest build, it returns ERR_TERMINAL_WRONG_PROPERTY (4513).
   */
  static bool IsNotificationsEnabled() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_NOTIFICATIONS_ENABLED); }

  /**
   * The maximal bars count on the chart.
   */
  static int GetMaxBars() { return Terminal::TerminalInfoInteger(TERMINAL_MAXBARS); }

  /**
   * The flag indicates the presence of MetaQuotes ID data to send Push notifications.
   *
   * Note: In the latest build, it returns ERR_TERMINAL_WRONG_PROPERTY (4513).
   */
  static bool HasMetaQuotesId() { return (bool)Terminal::TerminalInfoInteger(TERMINAL_MQID); }

  /**
   * Number of the code page of the language installed in the client terminal.
   *
   * @see
   * - https://www.mql5.com/en/docs/constants/io_constants/codepageusage
   */
  static int GetCodePage() { return Terminal::TerminalInfoInteger(TERMINAL_CODEPAGE); }

  /**
   * The number of CPU cores in the system.
   */
  static int GetCpuCores() { return Terminal::TerminalInfoInteger(TERMINAL_CPU_CORES); }

  /**
   * Free disk space for the Files folder of the terminal in Mb.
   */
  static int GetDiskSpace() { return Terminal::TerminalInfoInteger(TERMINAL_DISK_SPACE); }

  /**
   * Physical memory in the system in Mb.
   */
  static int GetPhysicalMemory() { return Terminal::TerminalInfoInteger(TERMINAL_MEMORY_PHYSICAL); }

  /**
   * Memory available to the process of the terminal in Mb.
   */
  static int GetTotalMemory() { return Terminal::TerminalInfoInteger(TERMINAL_MEMORY_TOTAL); }

  /**
   * Free memory of the terminal process in Mb.
   */
  static int GetFreeMemory() { return Terminal::TerminalInfoInteger(TERMINAL_MEMORY_AVAILABLE); }

  /**
   * Memory used by the terminal in Mb.
   */
  static int GetUsedMemory() { return Terminal::TerminalInfoInteger(TERMINAL_MEMORY_USED); }

  /**
   * The resolution of information display on the screen.
   *
   * It is measured as number of Dots in a line per Inch (DPI).
   * Knowing the parameter value, you can set the size of graphical objects,
   * so that they look the same on monitors with different resolution characteristics.
   */
  static int GetScreenDpi() { return Terminal::TerminalInfoInteger((ENUM_TERMINAL_INFO_INTEGER)TERMINAL_SCREEN_DPI); }

  /**
   * The last known value of a ping to a trade server in microseconds.
   *
   * One second comprises of one million microseconds.
   */
  static int GetPingLast() { return Terminal::TerminalInfoInteger((ENUM_TERMINAL_INFO_INTEGER)TERMINAL_PING_LAST); }

  /*
   * Terminal file operations.
   *
   * @see: ENUM_TERMINAL_INFO_STRING
   * @docs
   * - https://www.mql5.com/en/docs/constants/environment_state/terminalstatus
   *
   */

  /**
   * Returns language of the terminal
   */
  static string GetLanguage() { return Terminal::TerminalInfoString(TERMINAL_LANGUAGE); }

  /**
   * Returns the name of company owning the client terminal.
   */
  static string GetCompany() { return Terminal::TerminalInfoString(TERMINAL_COMPANY); }

  /**
   * Returns the client terminal name.
   */
  static string GetName() { return Terminal::TerminalInfoString(TERMINAL_NAME); }

  /**
   * Returns the current working directory.
   *
   * It is usually the directory where the client terminal was launched.
   */
  static string GetTerminalPath() { return Terminal::TerminalInfoString(TERMINAL_PATH); }

  /**
   * Returns folder in which terminal data are stored.
   */
  static string GetDataPath() { return Terminal::TerminalInfoString(TERMINAL_DATA_PATH); }

  /**
   * Returns common path for all of the terminals installed on a computer.
   */
  static string GetCommonPath() { return Terminal::TerminalInfoString(TERMINAL_COMMONDATA_PATH); }

  /**
   * Returns folder in which expert files are stored.
   */
  static string GetExpertPath() {
#ifdef __MQL4__
    return GetDataPath() + "\\MQL4\\Experts";
#endif
#ifdef __MQL5__
    return GetDataPath() + "\\MQL5\\Experts";
#endif
#ifndef __MQLBUILD__
    return GetDataPath() + "\\Experts";
#endif
  }

  /* Check methods */

  /**
   * Check permissions to trade.
   */
  static bool CheckPermissionToTrade() {
    if (IsRealtime()) {
      return IsConnected() && IsTradeAllowed();
    }
    return true;
  }

  /*
   * Methods to provide error handling.
   *
   * @docs
   * - https://docs.mql4.com/constants/errorswarnings/errorcodes
   * - https://www.mql5.com/en/docs/constants/errorswarnings
   */

  /**
   * Get textual representation of the error based on its code.
   *
   * Note: The error codes are defined in stderror.mqh.
   * Alternatively you can print the error description by using ErrorDescription() function, defined in stdlib.mqh.
   */
  static string GetErrorText(int code) {
    string text;

    switch (code) {
      case 0:
        text = "No error returned.";
        break;
      case 1:
        text = "No error returned, but the result is unknown.";
        break;
      case 2:
        text = "Common error.";
        break;
      case 3:
        text = "Invalid trade parameters.";
        break;
      case 4:
        text = "Trade server is busy.";
        break;
      case 5:
        text = "Old version of the client terminal,";
        break;
      case 6:
        text = "No connection with trade server.";
        break;
      case 7:
        text = "Not enough rights.";
        break;
      case 8:
        text = "Too frequent requests.";
        break;
      case 9:
        text = "Malfunctional trade operation (never returned error).";
        break;
      case 64:
        text = "Account disabled.";
        break;
      case 65:
        text = "Invalid account.";
        break;
      case 128:
        text = "Trade timeout.";
        break;
      // --
      // The error 129 (ERR_INVALID_PRICE) is generated when calculated or unnormalized price cannot be applied.
      // E.g. If there has not been the requested open price in the price thread,
      // or it has not been normalized according to the amount of digits after decimal point.
      case 129:
        text = "Invalid price.";
        break;
      // --
      // The error 130 (ERR_INVALID_STOPS) is generated in the case of erroneous or unnormalized stop levels
      // (MODE_STOPLEVEL).
      case 130: /* ERR_INVALID_STOPS */
        text = "Invalid stops.";
        break;
      case 131:
        text = "Invalid trade volume.";
        break;
      case 132:
        text = "Market is closed.";
        break;
      case 133:
        text = "Trade is disabled.";
        break;
      case 134:
        text = "Not enough money.";
        break;
      case 135:
        text = "Price changed.";
        break;
      // --
      // ERR_OFF_QUOTES
      //   1. Off Quotes may be a technical issue.
      //   2. Off Quotes may be due to unsupported orders.
      //      - Trying to partially close a position. For example, attempting to close 0.10 (10k) of a 20k position.
      //      - Placing a micro lot trade. For example, attempting to place a 0.01 (1k) volume trade.
      //      - Placing a trade that is not in increments of 0.10 (10k) volume. For example, attempting to place a 0.77
      //      (77k) trade.
      //      - Adding a stop or limit to a market order before the order executes. For example, setting an EA to place
      //      a 0.1 volume (10k) buy market order with a stop loss of 50 pips.
      case 136: /* ERR_OFF_QUOTES */
        text = "Off quotes.";
        break;
      case 137:
        text = "Broker is busy (never returned error).";
        break;
      // --
      // The error 138 (ERR_REQUOTE) is generated when the requested open price is fully out of date.
      // The order can be opened at the current price only if the current price lies within the slippage range of price.
      case 138: /* ERR_REQUOTE */
        text = "Requote.";
        break;
      case 139:
        text = "Order is locked.";
        break;
      case 140:
        text = "Long positions only allowed.";
        break;
      case 141: /* ERR_TOO_MANY_REQUESTS */
        text = "Too many requests.";
        break;
      case 145:
        text = "Modification denied because order too close to market.";
        break;
      case 146:
        text = "Trade context is busy.";
        break;
      // --
      // The error 147 (ERR_TRADE_EXPIRATION_DENIED) is generated,
      // when a non-zero value is specified in the expiration time parameter of pending order.
      case 147:
        text = "Expirations are denied by broker.";
        break;
      // --
      // The error 148 (ERR_TRADE_TOO_MANY_ORDERS) is generated on some trade servers,
      // when the total amount of open and pending orders is limited.
      // If this limit has been exceeded, no new position can be opened.
      case 148: /* ERR_TRADE_TOO_MANY_ORDERS */
        text = "Amount of open and pending orders has reached the limit set by the broker";
        break;  // ERR_TRADE_TOO_MANY_ORDERS
      case 149:
        text = "An attempt to open an order opposite to the existing one when hedging is disabled";
        break;  // ERR_TRADE_HEDGE_PROHIBITED
      case 150:
        text = "An attempt to close an order contravening the FIFO rule.";
        break;  // ERR_TRADE_PROHIBITED_BY_FIFO
      /* Runtime Errors */
      // @docs: https://www.mql5.com/en/docs/constants/errorswarnings/errorcodes
      case 4000:
        text = "No error (never generated code).";
        break;
      case 4001:
        text = "Wrong function pointer.";
        break;
      case 4002:
        text = "Array index is out of range.";
        break;
      case 4003:
        text = "No memory for function call stack.";
        break;
      case 4004:
        text = "Recursive stack overflow.";
        break;
      case 4005:
        text = "Not enough stack for parameter.";
        break;
      case 4006:
        text = "No memory for parameter string.";
        break;
      case 4007:
        text = "No memory for temp string.";
        break;
      case 4008:
        text = "Not initialized string.";
        break;
      case 4009:
        text = "Not initialized string in array.";
        break;
      case 4010:
        text = "No memory for array\' string.";
        break;
      case 4011:
        text = "Too long string.";
        break;
      case 4012:
        text = "Remainder from zero divide.";
        break;
      case 4013:
        text = "Zero divide.";
        break;
      case 4014:
        text = "Unknown command.";
        break;
      case 4015:
        text = "Wrong jump (never generated error).";
        break;
      case 4016:
        text = "Not initialized array.";
        break;
      case 4017:
        text = "Dll calls are not allowed.";
        break;
      case 4018:
        text = "Cannot load library.";
        break;
      case 4019:
        text = "Cannot call function.";
        break;
      case 4020:
        text = "Expert function calls are not allowed.";
        break;
      case 4021:
        text = "Not enough memory for temp string returned from function.";
        break;
      case 4022:
        text = "System is busy (never generated error).";
        break;
      case 4050:
        text = "Invalid function parameters count.";
        break;
      case 4051:
        text = "Invalid function parameter value.";
        break;
      case 4052:
        text = "String function internal error.";
        break;
      case 4053:
        text = "Some array error.";
        break;
      case 4054:
        text = "Incorrect series array using.";
        break;
      case 4055:
        text = "Custom indicator error.";
        break;
      case 4056:
        text = "Array are incompatible.";
        break;
      case 4057:
        text = "Global variables processing error.";
        break;
      case 4058:
        text = "Global variable not found.";
        break;
      case 4059:
        text = "Function is not allowed in testing mode.";
        break;
      case 4060:
        text = "Function is not confirmed.";
        break;
      case 4061:
        text = "Send mail error.";
        break;
      case 4062:
        text = "String parameter expected.";
        break;
      case 4063:
        text = "Integer parameter expected.";
        break;
      case 4064:
        text = "Double parameter expected.";
        break;
      case 4065:
        text = "Array as parameter expected.";
        break;
      case 4066:
        text = "Requested history data in update state.";
        break;
      case 4074: /* ERR_NO_MEMORY_FOR_HISTORY */
        text = "No memory for history data.";
        break;
      case 4099:
        text = "End of file.";
        break;
      case 4100:
        text = "Some file error.";
        break;
      case 4101:
        text = "Wrong file name.";
        break;
      case 4102:
        text = "Too many opened files.";
        break;
      case 4103:
        text = "Cannot open file.";
        break;
      case 4104:
        text = "Incompatible access to a file.";
        break;
      case 4105:
        text = "No order selected.";
        break;
      case 4106:
        text = "Unknown symbol.";
        break;
      case 4107:
        text = "Invalid stoploss parameter for trade (OrderSend) function.";
        break;
      case 4108:
        text = "Invalid ticket.";
        break;
      case 4109:
        text = "Trade is not allowed in the expert properties.";
        break;
      case 4110:
        text = "Longs are not allowed in the expert properties.";
        break;
      case 4111:
        text = "Shorts are not allowed in the expert properties.";
        break;
      case 4200:
        text = "Object is already exist.";
        break;
      case 4201:
        text = "Unknown object property.";
        break;
      case 4202:
        text = "Object is not exist.";
        break;
      case 4203:
        text = "Unknown object type.";
        break;
      case 4204:
        text = "No object name.";
        break;
      case 4205:
        text = "Object coordinates error.";
        break;
      case 4206:
        text = "No specified subwindow.";
        break;
      /* Return Codes of the Trade Server */
      // @docs: https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes
      default:
        text = "Unknown error.";
    }
    return (text);
  }

  /**
   * Get last error text.
   */
  static string GetLastErrorText() { return GetErrorText(GetLastError()); }

  /**
   * Get text description based on the uninitialization reason code.
   */
  static string GetUninitReasonText(int reasonCode) {
    string text = "";
    switch (reasonCode) {
      case REASON_PROGRAM:  // 0
        text = "EA terminated its operation by calling the ExpertRemove() function.";
        break;
      case REASON_REMOVE:  // 1 (implemented for the indicators only)
        text = string("Program ") + __FILE__ + " has been deleted from the chart.";
        break;
      case REASON_RECOMPILE:  // 2 (implemented for the indicators)
        text = string("Program ") + __FILE__ + " has been recompiled.";
        break;
      case REASON_CHARTCHANGE:  // 3
        text = "Symbol or chart period has been changed.";
        break;
      case REASON_CHARTCLOSE:  // 4
        text = "Chart has been closed.";
        break;
      case REASON_PARAMETERS:  // 5
        text = "Input parameters have been changed by a user.";
        break;
      case REASON_ACCOUNT:  // 6
        text =
            "Another account has been activated or reconnection to the trade server has occurred due to changes in the "
            "account settings.";
        break;
      case REASON_TEMPLATE:  // 7
        text = "  A new template has been applied to chart.";
        break;
      case REASON_INITFAILED:  // 8
        text = "Configuration issue - initialization handler has returned a nonzero value.";
        break;
      case REASON_CLOSE:  // 9
        text = "Terminal has been closed.";
        break;
      default:
        text = "Unknown reason.";
        break;
    }
    return text;
  }

  /**
   * Returns the value of a corresponding property of the terminal.
   *
   * @param ENUM_TERMINAL_INFO_DOUBLE property_id
   *   Identifier of a property.
   *
   * @return double
   * Returns the value of the property.
   *
   * @docs
   * - https://docs.mql4.com/check/terminalinfodouble
   * - https://www.mql5.com/en/docs/check/terminalinfodouble
   *
   */
  static double TerminalInfoDouble(ENUM_TERMINAL_INFO_DOUBLE property_id) {
#ifdef __MQLBUILD__
    return ::TerminalInfoDouble(property_id);
#else
    printf("@fixme: %s\n", "Terminal::TerminalInfoDouble()");
    return 0;
#endif
  }

  /**
   * Returns the value of a corresponding property of the terminal.
   *
   * @param ENUM_TERMINAL_INFO_INTEGER property_id
   *   Identifier of a property.
   *
   * @return int
   * Returns the value of the property.
   *
   * @docs
   * - https://docs.mql4.com/check/terminalinfointeger
   * - https://www.mql5.com/en/docs/check/terminalinfointeger
   *
   */
  static int TerminalInfoInteger(ENUM_TERMINAL_INFO_INTEGER property_id) {
#ifdef __MQLBUILD__
    return ::TerminalInfoInteger(property_id);
#else
    printf("@fixme: %s\n", "Terminal::TerminalInfoInteger()");
    return 0;
#endif
  }

  /**
   * Returns the value of a corresponding property of the terminal.
   *
   * @param ENUM_TERMINAL_INFO_STRING property_id
   *   Identifier of a property.
   *
   * @return string
   * Returns the value of the property.
   *
   * @docs
   * - https://docs.mql4.com/check/terminalinfostring
   * - https://www.mql5.com/en/docs/check/terminalinfostring
   *
   */
  static string TerminalInfoString(ENUM_TERMINAL_INFO_STRING property_id) {
#ifdef __MQLBUILD__
    return ::TerminalInfoString(property_id);
#else
    printf("@fixme: %s\n", "Terminal::TerminalInfoString()");
    return 0;
#endif
  }

  /* Conditions */

  /**
   * Checks for terminal condition.
   *
   * @param ENUM_TERMINAL_CONDITION _cond
   *   Terminal condition.
   * @param MqlParam[] _args
   *   Terminal condition arguments.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_TERMINAL_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    long _arg1l = ArraySize(_args) > 0 ? DataParamEntry::ToInteger(_args[0]) : WRONG_VALUE;
    long _arg2l = ArraySize(_args) > 1 ? DataParamEntry::ToInteger(_args[1]) : WRONG_VALUE;
    switch (_cond) {
      case TERMINAL_COND_IS_CONNECTED:
        return !IsConnected();
      default:
        Print(StringFormat("Invalid terminal condition: %s!", EnumToString(_cond), __FUNCTION__));
        return false;
    }
  }
  bool CheckCondition(ENUM_TERMINAL_CONDITION _cond, long _arg1) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    ArrayPushObject(_args, _param1);
    return Terminal::CheckCondition(_cond, _args);
  }
  bool CheckCondition(ENUM_TERMINAL_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Terminal::CheckCondition(_cond, _args);
  }

  /* Actions */

  /**
   * Execute terminal action.
   *
   * @param ENUM_TERMINAL_ACTION _action
   *   Terminal action to execute.
   * @param MqlParam _args
   *   Terminal action arguments.
   * @return
   *   Returns true when the condition is met.
   */
  bool ExecuteAction(ENUM_TERMINAL_ACTION _action, ARRAY_REF(MqlParam, _args)) {
    long _arg1l = ArraySize(_args) > 0 ? DataParamEntry::ToInteger(_args[0]) : WRONG_VALUE;
    long _arg2l = ArraySize(_args) > 1 ? DataParamEntry::ToInteger(_args[1]) : WRONG_VALUE;
    long _arg3l = ArraySize(_args) > 2 ? DataParamEntry::ToInteger(_args[2]) : WRONG_VALUE;
    switch (_action) {
      case TERMINAL_ACTION_CRASH:
        delete THIS_PTR;
      default:
        Print(StringFormat("Invalid terminal action: %s!", EnumToString(_action), __FUNCTION__));
        return false;
    }
  }
  bool ExecuteAction(ENUM_TERMINAL_ACTION _action) {
    ARRAY(MqlParam, _args);
    return Terminal::ExecuteAction(_action, _args);
  }

  /* Printer methods */

  /**
   * Returns textual representation of the Terminal class.
   */
  string ToString(string _sep = "; ") {
    return StringFormat("Allow DLL: %s", IsDllsAllowed() ? "Yes" : "No") + _sep +
           StringFormat("Allow Libraries: %s", IsLibrariesAllowed() ? "Yes" : "No") + _sep +
           StringFormat("CPUs: %d", GetCpuCores()) + _sep +
           // StringFormat("Community account: %s", (string)HasCommunityAccount()) + _sep +
           // StringFormat("Community balance: %.2f", GetCommunityBalance()) + _sep +
           // StringFormat("Community connection: %s", (string)IsCommunityConnected()) + _sep +
           StringFormat("Disk space: %d", GetDiskSpace()) + _sep +
           StringFormat("Enabled FTP: %s", IsFtpEnabled() ? "Yes" : "No") + _sep +
           StringFormat("Enabled e-mail: %s", IsEmailEnabled() ? "Yes" : "No") + _sep +
           // StringFormat("Enabled notifications: %s", (string)IsNotificationsEnabled()) + _sep +
           StringFormat("IsOptimization: %s", IsOptimization() ? "Yes" : "No") + _sep +
           StringFormat("IsRealtime: %s", IsRealtime() ? "Yes" : "No") + _sep +
           StringFormat("IsTesting: %s", IsTesting() ? "Yes" : "No") + _sep +
           StringFormat("IsVisual: %s", IsVisualMode() ? "Yes" : "No") + _sep +
           // StringFormat("MQ ID: %s", (string)HasMetaQuotesId()) + _sep +
           StringFormat("Memory (free): %d", GetFreeMemory()) + _sep +
           StringFormat("Memory (physical): %d", GetPhysicalMemory()) + _sep +
           StringFormat("Memory (total): %d", GetTotalMemory()) + _sep +
           StringFormat("Memory (used): %d", GetUsedMemory()) + _sep +
           StringFormat("Path (Common): %s", GetCommonPath()) + _sep + StringFormat("Path (Data): %s", GetDataPath()) +
           _sep + StringFormat("Path (Expert): %s", GetExpertPath()) + _sep +
           StringFormat("Path (Terminal): %s", GetTerminalPath()) + _sep +
           StringFormat("Program name: %s", WindowExpertName()) + _sep +
           StringFormat("Screen DPI: %d", GetScreenDpi()) + _sep + StringFormat("Terminal build: %d", GetBuild()) +
           _sep + StringFormat("Terminal code page: %d", IntegerToString(GetCodePage())) + _sep +
           StringFormat("Terminal company: %s", GetCompany()) + _sep +
           StringFormat("Terminal connected: %s", IsConnected() ? "Yes" : "No") + _sep +
           StringFormat("Terminal language: %s", GetLanguage()) + _sep + StringFormat("Terminal name: %s", GetName()) +
           _sep + StringFormat("Termnal max bars: %d", GetMaxBars()) + _sep +
           StringFormat("Trade allowed: %s", IsTradeAllowed() ? "Yes" : "No") + _sep +
           StringFormat("Trade context busy: %s", IsTradeContextBusy() ? "Yes" : "No") + _sep +
           StringFormat("Trade perm: %s", CheckPermissionToTrade() ? "Yes" : "No") + _sep +
           StringFormat("Trade ping (last): %d", GetPingLast());
  }
};

// Defines macros (for MQL4 backward compatibility).
#ifndef __MQL4__
// @docs: https://docs.mql4.com/chart_operations/windowexpertname
string WindowExpertName(void) { return Terminal::WindowExpertName(); }
#endif

#endif  // TERMINAL_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Terminal.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Order's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.






#ifndef __MQL5__
/**
 * The structure of Results of a Trade Request Check (MqlTradeCheckResult).
 * The check is performed using the OrderCheck() function.
 *
 * @see: https://www.mql5.com/en/docs/constants/structures/mqltradecheckresult
 */
struct MqlTradeCheckResult {
  unsigned int retcode;  // Reply code.
  double balance;        // Balance after the execution of the deal.
  double equity;         // Equity after the execution of the deal.
  double profit;         // Floating profit.
  double margin;         // Margin requirements.
  double margin_free;    // Free margin.
  double margin_level;   // Margin level.
  string comment;        // Comment to the reply code (description of the error).
};
#endif

/**
 * The structure for order parameters.
 */
struct OrderParams {
  struct OrderCloseCond {
    ENUM_ORDER_CONDITION cond;         // Close condition.
    ARRAY(DataParamEntry, cond_args);  // Close condition argument.
    // Getters.
    ENUM_ORDER_CONDITION GetCondition() { return cond; }
    template <typename T>
    T GetConditionArgValue(int _index = 0) {
      return cond_args[_index].ToValue<T>();
    }
    // Setters.
    void SetCondition(ENUM_ORDER_CONDITION _cond) { cond = _cond; }
    template <typename T>
    void SetConditionArg(T _value, int _index = 0) {
      DataParamEntry _arg = DataParamEntry::FromValue(_value);
      SetConditionArg(_arg, _index);
    }
    void SetConditionArg(DataParamEntry &_arg, int _index = 0) {
      int _size = ArraySize(cond_args);
      if (_size <= _index) {
        ArrayResize(cond_args, _index + 1);
      }
      cond_args[_index] = _arg;
    }
    void SetConditionArgs(ARRAY_REF(DataParamEntry, _args)) {
      ArrayResize(cond_args, ArraySize(_args));
      for (int i = 0; i < ArraySize(_args); i++) {
        cond_args[i] = _args[i];
      }
    }
    // Static methods.
    static bool Resize(ARRAY_REF(OrderCloseCond, _cond_close), int _index = 0) {
      bool _result = true;
      int _size = ArraySize(_cond_close);
      if (_size <= _index) {
        _result &= ArrayResize(_cond_close, _size + 1);
      }
      return _result;
    }
    // Serializers.
    SerializerNodeType Serialize(Serializer &s) {
      s.PassEnum(THIS_REF, "cond", cond);
      // s.Pass(THIS_REF, "cond_args", cond_args);
      return SerializerNodeObject;
    }
  } cond_close[];
  bool dummy;                   // Whether order is dummy (fake) or not (real).
  color color_arrow;            // Color of the opening arrow on the chart.
  unsigned short refresh_freq;  // How often to refresh order values (in secs).
  unsigned short update_freq;   // How often to update order stops (in secs).
  // Special struct methods.
  OrderParams() : dummy(false), color_arrow(clrNONE), refresh_freq(10), update_freq(60){};
  OrderParams(bool _dummy) : dummy(_dummy), color_arrow(clrNONE), refresh_freq(10), update_freq(60){};
  // Getters.
  template <typename T>
  T Get(ENUM_ORDER_PARAM _param, int _index1 = 0, int _index2 = 0) {
    switch (_param) {
      case ORDER_PARAM_COLOR_ARROW:
        return (T)color_arrow;
      case ORDER_PARAM_COND_CLOSE:
        return (T)cond_close[_index1].cond;
      case ORDER_PARAM_COND_CLOSE_ARG_VALUE:
        return (T)cond_close[_index1].GetConditionArgValue<T>(_index2);
      case ORDER_PARAM_COND_CLOSE_NUM:
        return (T)ArraySize(cond_close);
      case ORDER_PARAM_DUMMY:
        return (T)dummy;
      case ORDER_PARAM_REFRESH_FREQ:
        return (T)refresh_freq;
      case ORDER_PARAM_UPDATE_FREQ:
        return (T)update_freq;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
  // State checkers
  bool HasCloseCondition() { return ArraySize(cond_close) > 0; }
  bool IsDummy() { return dummy; }
  // Setters.
  void AddConditionClose(ENUM_ORDER_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    SetConditionClose(_cond, _args, ArraySize(cond_close));
  }
  template <typename T>
  void Set(ENUM_ORDER_PARAM _param, T _value, int _index1 = 0, int _index2 = 0) {
    switch (_param) {
      case ORDER_PARAM_COLOR_ARROW:
        color_arrow = (color)_value;
        return;
      case ORDER_PARAM_COND_CLOSE:
        SetConditionClose((ENUM_ORDER_CONDITION)_value, _index1);
        return;
      case ORDER_PARAM_COND_CLOSE_ARG_VALUE:
        cond_close[_index1].SetConditionArg(_value, _index2);
        return;
      case ORDER_PARAM_DUMMY:
        dummy = _value;
        return;
      case ORDER_PARAM_REFRESH_FREQ:
        refresh_freq = (unsigned short)_value;
        return;
      case ORDER_PARAM_UPDATE_FREQ:
        update_freq = (unsigned short)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void SetConditionClose(ENUM_ORDER_CONDITION _cond, int _index = 0) {
    DataParamEntry _args[];
    SetConditionClose(_cond, _args, _index);
  }
  void SetConditionClose(ENUM_ORDER_CONDITION _cond, ARRAY_REF(DataParamEntry, _args), int _index = 0) {
    OrderCloseCond::Resize(cond_close, _index);
    cond_close[_index].SetCondition(_cond);
    cond_close[_index].SetConditionArgs(_args);
  }
  void SetRefreshRate(unsigned short _value) { refresh_freq = _value; }
  // Serializers.
  SerializerNodeType Serialize(Serializer &s) {
    s.Pass(THIS_REF, "dummy", dummy);
    s.Pass(THIS_REF, "color_arrow", color_arrow);
    s.Pass(THIS_REF, "refresh_freq", refresh_freq);
    // s.Pass(THIS_REF, "cond_close", cond_close);
    return SerializerNodeObject;
  }
};

/**
 * The structure for order data.
 */
struct OrderData {
 protected:
  unsigned long magic;                   // Magic number.
  unsigned long position_id;             // Position ID.
  unsigned long position_by_id;          // Position By ID.
  unsigned long ticket;                  // Ticket number.
  ENUM_ORDER_STATE state;                // State.
  datetime time_closed;                  // Closed time.
  datetime time_done;                    // Execution/cancellation time.
  datetime time_expiration;              // Order expiration time (for the orders of ORDER_TIME_SPECIFIED type).
  datetime time_setup;                   // Setup time.
  datetime time_last_refresh;            // Last refresh of order values.
  datetime time_last_update;             // Last update of order stops.
  double commission;                     // Commission.
  double profit;                         // Profit.
  double total_profit;                   // Total profit (profit minus fees).
  double price_open;                     // Open price.
  double price_close;                    // Close price.
  double price_current;                  // Current price.
  double price_stoplimit;                // The limit order price for the StopLimit order.
  double swap;                           // Order cumulative swap.
  double total_fees;                     // Total fees.
  double sl;                             // Current Stop loss level of the order.
  double tp;                             // Current Take Profit level of the order.
  long time_setup_msc;                   // The time of placing the order (in msc).
  long time_done_msc;                    // The time of execution/cancellation time (in msc).
  ENUM_ORDER_TYPE type;                  // Type.
  ENUM_ORDER_TYPE_FILLING type_filling;  // Filling type.
  ENUM_ORDER_TYPE_TIME type_time;        // Lifetime (the order validity period).
  ENUM_ORDER_REASON reason;              // Reason or source for placing an order.
  ENUM_ORDER_REASON_CLOSE reason_close;  // Reason or source for closing an order.
  unsigned int last_error;               // Last error code.
  double volume_curr;                    // Current volume.
  double volume_init;                    // Initial volume.
  string comment;                        // Comment.
  string ext_id;                         // External trading system identifier.
  string symbol;                         // Symbol of the order.
 public:
  OrderData()
      : magic(0),
        position_id(0),
        position_by_id(0),
        ticket(0),
        state(ORDER_STATE_STARTED),
        comment(""),
        commission(0),
        profit(0),
        price_open(0),
        price_close(0),
        price_current(0),
        price_stoplimit(0),
        swap(0),
        time_closed(0),
        time_done(0),
        time_done_msc(0),
        time_expiration(0),
        time_last_refresh(0),
        time_last_update(0),
        time_setup(0),
        time_setup_msc(0),
        sl(0),
        tp(0),
        last_error(ERR_NO_ERROR),
        symbol(NULL),
        volume_curr(0),
        volume_init(0) {}
  // Copy constructor.
  OrderData(OrderData &_odata) { this = _odata; }
  // Getters.
  template <typename T>
  T Get(ENUM_ORDER_PROPERTY_CUSTOM _prop_name) {
    double _tick_value = SymbolInfoStatic::GetTickValue(symbol);
    switch (_prop_name) {
      case ORDER_PROP_COMMISSION:
        return (T)commission;
      case ORDER_PROP_LAST_ERROR:
        return (T)last_error;
      case ORDER_PROP_PRICE_CLOSE:
        return (T)price_close;
      case ORDER_PROP_PRICE_OPEN:
        return (T)price_open;
      case ORDER_PROP_PRICE_STOPLIMIT:
        return (T)price_stoplimit;
      case ORDER_PROP_PROFIT:
        return (T)profit;
      case ORDER_PROP_PROFIT_PIPS:
        return (T)(profit * pow(10, SymbolInfoStatic::GetDigits(symbol)));
      case ORDER_PROP_PROFIT_VALUE:
        return (T)(Get<int>(ORDER_PROP_PROFIT_PIPS) * volume_curr * SymbolInfoStatic::GetTickValue(symbol));
      case ORDER_PROP_PROFIT_TOTAL:
        return (T)(profit - total_fees);
      case ORDER_PROP_REASON_CLOSE:
        return (T)reason_close;
      case ORDER_PROP_TICKET:
        return (T)ticket;
      case ORDER_PROP_TIME_CLOSED:
        return (T)time_closed;
      case ORDER_PROP_TIME_LAST_REFRESH:
        return (T)time_last_refresh;
      case ORDER_PROP_TIME_LAST_UPDATE:
        return (T)time_last_update;
      case ORDER_PROP_TIME_OPENED:
        return (T)time_done;
      case ORDER_PROP_TOTAL_FEES:
        return (T)total_fees;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
  template <typename T>
  T Get(ENUM_ORDER_PROPERTY_DOUBLE _prop_name) {
    // See: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
    switch (_prop_name) {
      case ORDER_VOLUME_CURRENT:
        return (T)volume_curr;
      case ORDER_VOLUME_INITIAL:
        return (T)volume_init;
      case ORDER_PRICE_OPEN:
        return (T)price_open;
      case ORDER_SL:
        return (T)sl;
      case ORDER_TP:
        return (T)tp;
      case ORDER_PRICE_CURRENT:
        return (T)price_current;
      case ORDER_PRICE_STOPLIMIT:
        return (T)price_stoplimit;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
  template <typename T>
  T Get(ENUM_ORDER_PROPERTY_INTEGER _prop_name) {
    // See: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
    switch (_prop_name) {
      // case ORDER_TIME_SETUP: return time_setup; // @todo
      case ORDER_TYPE:
        return (T)type;
      case ORDER_STATE:
        return (T)state;
      case ORDER_TIME_EXPIRATION:
        return (T)time_expiration;
      case ORDER_TIME_DONE:
        return (T)time_done;
      case ORDER_TIME_DONE_MSC:
        return (T)time_done_msc;
      case ORDER_TIME_SETUP:
        return (T)time_setup;
      case ORDER_TIME_SETUP_MSC:
        return (T)time_setup_msc;
      case ORDER_TYPE_FILLING:
        return (T)type_filling;
      case ORDER_TYPE_TIME:
        return (T)type_time;
      case ORDER_MAGIC:
        return (T)magic;
#ifndef __MQL4__
      case ORDER_POSITION_ID:
        return (T)position_id;
      case ORDER_POSITION_BY_ID:
        return (T)position_by_id;
      case ORDER_REASON:
        return (T)reason;
      case ORDER_TICKET:
        return (T)ticket;
#endif
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
  string Get(ENUM_ORDER_PROPERTY_STRING _prop_name) {
    // See: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
    switch (_prop_name) {
      case ORDER_COMMENT:
        return comment;
#ifndef __MQL4__
      case ORDER_EXTERNAL_ID:
        return ext_id;
#endif
      case ORDER_SYMBOL:
        return symbol;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return "";
  }
  /*
   * Returns order type value.
   *
   * @param
   *   _type ENUM_ORDER_TYPE Order operation type of the order.
   *
   * @return
   *   Returns 1 for buy, -1 for sell orders, otherwise 0.
   */
  short GetTypeValue() { return GetTypeValue(type); }
  /*
   * Returns order type value.
   *
   * @param
   *   _type ENUM_ORDER_TYPE Order operation type of the order.
   *
   * @return
   *   Returns 1 for buy, -1 for sell orders, otherwise 0.
   */
  static short GetTypeValue(ENUM_ORDER_TYPE _type) {
    switch (_type) {
      case ORDER_TYPE_SELL:
      case ORDER_TYPE_SELL_LIMIT:
      case ORDER_TYPE_SELL_STOP:
        // All sell orders are -1.
        return -1;
      case ORDER_TYPE_BUY:
      case ORDER_TYPE_BUY_LIMIT:
      case ORDER_TYPE_BUY_STOP:
        // All buy orders are -1.
        return 1;
      default:
        return 0;
    }
  }
  /*
  template <typename T>
  T Get(int _prop_name) {
    // MQL4 back-compatibility version for non-enum properties.
    return Get<T>((ENUM_ORDER_PROPERTY_INTEGER)_prop_name);
  }
  */
  string GetReasonCloseText() {
    switch (reason_close) {
      case ORDER_REASON_CLOSED_ALL:
        return "Closed all";
      case ORDER_REASON_CLOSED_BY_ACTION:
        return "Closed by action";
      case ORDER_REASON_CLOSED_BY_EXPIRE:
        return "Expired";
      case ORDER_REASON_CLOSED_BY_OPPOSITE:
        return "Closed by opposite trade";
      case ORDER_REASON_CLOSED_BY_SIGNAL:
        return "Closed by signal";
      case ORDER_REASON_CLOSED_BY_SL:
        return "Closed by stop loss";
      case ORDER_REASON_CLOSED_BY_TEST:
        return "Closed by test";
      case ORDER_REASON_CLOSED_BY_TP:
        return "Closed by take profit";
      case ORDER_REASON_CLOSED_BY_USER:
        return "Closed by user";
      case ORDER_REASON_CLOSED_UNKNOWN:
        return "Unknown";
    }
    return "Unknown";
  }
  // Setters.
  template <typename T>
  void Set(ENUM_ORDER_PROPERTY_CUSTOM _prop_name, T _value) {
    switch (_prop_name) {
      case ORDER_PROP_COMMISSION:
        commission = (double)_value;
        return;
      case ORDER_PROP_LAST_ERROR:
        last_error = (unsigned int)_value;
        return;
      case ORDER_PROP_PRICE_CLOSE:
        price_close = (double)_value;
        return;
      case ORDER_PROP_PRICE_OPEN:
        price_open = (double)_value;
        return;
      case ORDER_PROP_PRICE_STOPLIMIT:
        price_stoplimit = (double)_value;
        return;
      case ORDER_PROP_PROFIT:
        profit = (double)_value;
        return;
      case ORDER_PROP_REASON_CLOSE:
        reason_close = (ENUM_ORDER_REASON_CLOSE)_value;
        return;
      case ORDER_PROP_TICKET:
        ticket = (unsigned long)_value;
        return;
      case ORDER_PROP_TIME_CLOSED:
        time_closed = (datetime)_value;
        return;
      case ORDER_PROP_TIME_LAST_REFRESH:
        time_last_refresh = (datetime)_value;
        return;
      case ORDER_PROP_TIME_LAST_UPDATE:
        time_last_update = (datetime)_value;
        return;
      case ORDER_PROP_TIME_OPENED:
        time_setup = (datetime)_value;
        return;
      case ORDER_PROP_TOTAL_FEES:
        total_fees = (double)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(ENUM_ORDER_PROPERTY_DOUBLE _prop_name, double _value) {
    switch (_prop_name) {
      case ORDER_VOLUME_CURRENT:
        volume_curr = _value;
        return;
      case ORDER_VOLUME_INITIAL:
        volume_init = _value;
        return;
      case ORDER_PRICE_OPEN:
        price_open = _value;
        return;
      case ORDER_SL:
        sl = _value;
        return;
      case ORDER_TP:
        tp = _value;
        return;
      case ORDER_PRICE_CURRENT:
        price_current = _value;
        RefreshProfit();
        return;
      case ORDER_PRICE_STOPLIMIT:
        price_stoplimit = _value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(ENUM_ORDER_PROPERTY_INTEGER _prop_name, long _value) {
    switch (_prop_name) {
      case ORDER_TYPE:
        type = (ENUM_ORDER_TYPE)_value;
        return;
      case ORDER_STATE:
        state = (ENUM_ORDER_STATE)_value;
        return;
      case ORDER_TIME_EXPIRATION:
        time_expiration = (datetime)_value;
        return;
      case ORDER_TIME_DONE:
        time_done = (datetime)_value;
        return;
      case ORDER_TIME_DONE_MSC:
        time_done_msc = _value;
        return;
      case ORDER_TIME_SETUP:
        time_setup = (datetime)_value;
        return;
      case ORDER_TIME_SETUP_MSC:
        time_setup_msc = _value;
        return;
      case ORDER_TYPE_FILLING:
        type_filling = (ENUM_ORDER_TYPE_FILLING)_value;
        return;
      case ORDER_TYPE_TIME:
        type_time = (ENUM_ORDER_TYPE_TIME)_value;
        return;
      case ORDER_MAGIC:
        magic = _value;
        return;
#ifndef __MQL4__
      case ORDER_POSITION_ID:
        position_id = _value;
        return;
      case ORDER_POSITION_BY_ID:
        position_by_id = _value;
        return;
      case ORDER_REASON:
        reason = (ENUM_ORDER_REASON)_value;
        return;
      case ORDER_TICKET:
        ticket = _value;
        return;
#endif
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(ENUM_ORDER_PROPERTY_STRING _prop_name, string _value) {
    switch (_prop_name) {
      case ORDER_COMMENT:
        comment = _value;
        return;
#ifndef __MQL4__
      case ORDER_EXTERNAL_ID:
        ext_id = _value;
        return;
#endif
      case ORDER_SYMBOL:
        symbol = _value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  /*
  template <typename T>
  T Set(long _prop_name) {
    // MQL4 back-compatibility version for non-enum properties.
    return Set<T>((ENUM_ORDER_PROPERTY_INTEGER)_prop_name);
  }
  */
  void ProcessLastError() { last_error = MathMax(last_error, (unsigned int)Terminal::GetLastError()); }
  void ResetError() {
    ResetLastError();
    last_error = ERR_NO_ERROR;
  }
  void RefreshProfit() { profit = (price_current - price_open) * GetTypeValue(); }
  // Serializers.
  SerializerNodeType Serialize(Serializer &s) {
    s.Pass(THIS_REF, "magic", magic);
    s.Pass(THIS_REF, "position_id", position_id);
    s.Pass(THIS_REF, "position_by_id", position_by_id);
    s.Pass(THIS_REF, "ticket", ticket);
    s.PassEnum(THIS_REF, "state", state);
    s.Pass(THIS_REF, "commission", commission);
    s.Pass(THIS_REF, "profit", profit);
    s.Pass(THIS_REF, "total_profit", total_profit);
    s.Pass(THIS_REF, "price_open", price_open);
    s.Pass(THIS_REF, "price_close", price_close);
    s.Pass(THIS_REF, "price_current", price_current);
    s.Pass(THIS_REF, "price_stoplimit", price_stoplimit);
    s.Pass(THIS_REF, "swap", swap);
    s.Pass(THIS_REF, "time_closed", time_closed);
    s.Pass(THIS_REF, "time_done", time_done);
    s.Pass(THIS_REF, "time_done_msc", time_done_msc);
    s.Pass(THIS_REF, "time_expiration", time_expiration);
    s.Pass(THIS_REF, "time_last_update", time_last_update);
    s.Pass(THIS_REF, "time_setup", time_setup);
    s.Pass(THIS_REF, "time_setup_msc", time_setup_msc);
    s.Pass(THIS_REF, "total_fees", total_fees);
    s.Pass(THIS_REF, "sl", sl);
    s.Pass(THIS_REF, "tp", tp);
    s.PassEnum(THIS_REF, "type", type);
    s.PassEnum(THIS_REF, "type_filling", type_filling);
    s.PassEnum(THIS_REF, "type_time", type_time);
    s.PassEnum(THIS_REF, "reason", reason);
    s.Pass(THIS_REF, "last_error", last_error);
    s.Pass(THIS_REF, "volume_current", volume_curr);
    s.Pass(THIS_REF, "volume_init", volume_init);
    s.Pass(THIS_REF, "comment", comment);
    s.Pass(THIS_REF, "ext_id", ext_id);
    s.Pass(THIS_REF, "symbol", symbol);

    return SerializerNodeObject;
  }
};

// Structure for order static methods.
struct OrderStatic {
  /**
   * Selects an order/position for further processing.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderselect
   * - https://www.mql5.com/en/docs/trading/positiongetticket
   */
  static bool SelectByPosition(int _pos) {
#ifdef __MQL4__
    return ::OrderSelect(_pos, SELECT_BY_POS, MODE_TRADES);
#else
    return ::PositionGetTicket(_pos) > 0;
#endif
  }

  /**
   * Returns expiration date of the selected pending order/position.
   *
   * @see
   * - https://docs.mql4.com/trading/orderexpiration
   */
  static datetime Expiration() {
#ifdef __MQL4__
    return ::OrderExpiration();
#else
    // Not supported.
    return 0;
#endif
  }

  /**
   * Returns open time of the currently selected order/position.
   *
   * @see
   * - http://docs.mql4.com/trading/orderopentime
   * - https://www.mql5.com/en/docs/trading/positiongetinteger
   */
  static datetime OpenTime() {
#ifdef __MQL4__
    return ::OrderOpenTime();
#else
    return (datetime)::PositionGetInteger(POSITION_TIME);
#endif
  }

  /*
   * Returns close time of the currently selected order/position.
   *
   * @see:
   * - https://docs.mql4.com/trading/orderclosetime
   */
  static datetime CloseTime() {
#ifdef __MQL4__
    return ::OrderCloseTime();
#else
    // Not supported.
    return 0;
#endif
  }

  /**
   * Returns close price of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordercloseprice
   */
  static double ClosePrice() {
#ifdef __MQL4__
    return ::OrderClosePrice();
#else
    // Not supported.
    return 0;
#endif
  }

  /**
   * Returns calculated commission of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordercommission
   */
  static double Commission() {
#ifdef __MQL4__
    return ::OrderCommission();
#else  // __MQL5__
    // Not supported.
    return 0;
#endif
  }

  /**
   * Returns amount of lots/volume of the selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderlots
   * - https://www.mql5.com/en/docs/trading/positiongetdouble
   */
  static double Lots() {
#ifdef __MQL4__
    return ::OrderLots();
#else
    return ::PositionGetDouble(POSITION_VOLUME);
#endif
  }

  /**
   * Returns open price of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderopenprice
   * - https://www.mql5.com/en/docs/trading/positiongetdouble
   */
  static double OpenPrice() {
#ifdef __MQL4__
    return ::OrderOpenPrice();
#else
    return ::PositionGetDouble(POSITION_PRICE_OPEN);
#endif
  }

  /**
   * Returns profit of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderprofit
   *
   * @return
   * Returns the order's net profit value (without swaps or commissions).
   */
  static double Profit() {
#ifdef __MQL4__
    // Returns the net profit value (without swaps or commissions) for the selected order.
    // For open orders, it is the current unrealized profit.
    // For closed orders, it is the fixed profit.
    return ::OrderProfit();
#else
    // Not supported.
    return 0;
#endif
  }

  /**
   * Returns stop loss value of the currently selected order.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderstoploss
   * - https://www.mql5.com/en/docs/trading/positiongetdouble
   */
  static double StopLoss() {
#ifdef __MQL4__
    return ::OrderStopLoss();
#else
    return ::PositionGetDouble(POSITION_SL);
#endif
  }

  /**
   * Returns cumulative swap of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderswap
   * - https://www.mql5.com/en/docs/trading/positiongetdouble
   */
  static double Swap() {
#ifdef __MQL4__
    return ::OrderSwap();
#else
    return ::PositionGetDouble(POSITION_SWAP);
#endif
  }

  /**
   * Returns take profit value of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordertakeprofit
   * - https://www.mql5.com/en/docs/trading/positiongetdouble
   *
   * @return
   * Returns take profit value of the currently selected order/position.
   */
  static double TakeProfit() {
#ifdef __MQL4__
    return ::OrderTakeProfit();
#else
    return ::PositionGetDouble(POSITION_TP);
#endif
  }

  /**
   * Returns an identifying number of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/ordermagicnumber
   * - https://www.mql5.com/en/docs/trading/positiongetinteger
   *
   * @return
   * Identifying (magic) number of the currently selected order/position.
   */
  static long MagicNumber() {
#ifdef __MQL4__
    return ::OrderMagicNumber();
#else
    return ::PositionGetInteger(POSITION_MAGIC);
#endif
  }

  /**
   * Returns order operation type of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/ordertype
   * - https://www.mql5.com/en/docs/trading/positiongetinteger
   *
   * @return
   * Order/position operation type.
   */
  static int Type() {
#ifdef __MQL4__
    // @see: ENUM_ORDER_TYPE
    return ::OrderType();
#else
    // @see: ENUM_POSITION_TYPE
    return (int)::PositionGetInteger(POSITION_TYPE);
#endif
  }

  /**
   * Returns comment of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordercomment
   * - https://www.mql5.com/en/docs/trading/positiongetstring
   */
  static string Comment() {
#ifdef __MQL4__
    return ::OrderComment();
#else
    return ::PositionGetString(POSITION_COMMENT);
#endif
  }

  /**
   * Returns symbol name of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordersymbol
   * - https://www.mql5.com/en/docs/trading/positiongetstring
   */
  static string Symbol() {
#ifdef __MQL4__
    return ::OrderSymbol();
#else
    return ::PositionGetString(POSITION_SYMBOL);
#endif
  }

  /**
   * Returns a ticket number of the currently selected order/position.
   *
   * It is a unique number assigned to each order.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderticket
   * - https://www.mql5.com/en/docs/trading/positiongetticket
   */
  static unsigned long Ticket() {
#ifdef __MQL4__
    return ::OrderTicket();
#else
    return ::PositionGetInteger(POSITION_TICKET);
#endif
  }

  /**
   * Prints information about the selected order in the log.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderprint
   */
  static void Print() {
#ifdef __MQL4__
    ::OrderPrint();
#else
    PrintFormat("%d", OrderStatic::Ticket());
#endif
  }
};

/**
 * Proxy class used to serialize MqlTradeRequest object.
 *
 * Usage: SerializerConverter::FromObject(MqlTradeRequestProxy(_request)).ToString<SerializerJson>());
 */
struct MqlTradeRequestProxy : MqlTradeRequest {
  MqlTradeRequestProxy(MqlTradeRequest &r) { THIS_REF = r; }

  SerializerNodeType Serialize(Serializer &s) {
    s.PassEnum(THIS_REF, "action", action);
    s.Pass(THIS_REF, "magic", magic);
    s.Pass(THIS_REF, "order", order);
    s.Pass(THIS_REF, "symbol", symbol);
    s.Pass(THIS_REF, "volume", volume);
    s.Pass(THIS_REF, "price", price);
    s.Pass(THIS_REF, "stoplimit", stoplimit);
    s.Pass(THIS_REF, "sl", sl);
    s.Pass(THIS_REF, "tp", tp);
    s.Pass(THIS_REF, "deviation", deviation);
    s.PassEnum(THIS_REF, "type", type);
    s.PassEnum(THIS_REF, "type_filling", type_filling);
    s.PassEnum(THIS_REF, "type_time", type_time);
    s.Pass(THIS_REF, "expiration", expiration);
    s.Pass(THIS_REF, "comment", comment);
    s.Pass(THIS_REF, "position", position);
    s.Pass(THIS_REF, "position_by", position_by);
    return SerializerNodeObject;
  }
};

/**
 * Proxy class used to serialize MqlTradeResult object.
 *
 * Usage: SerializerConverter::FromObject(MqlTradeResultProxy(_request)).ToString<SerializerJson>());
 */
struct MqlTradeResultProxy : MqlTradeResult {
  MqlTradeResultProxy(MqlTradeResult &r) { THIS_REF = r; }

  SerializerNodeType Serialize(Serializer &s) {
    s.Pass(THIS_REF, "retcode", retcode);
    s.Pass(THIS_REF, "deal", deal);
    s.Pass(THIS_REF, "order", order);
    s.Pass(THIS_REF, "volume", volume);
    s.Pass(THIS_REF, "price", price);
    s.Pass(THIS_REF, "bid", bid);
    s.Pass(THIS_REF, "ask", ask);
    s.Pass(THIS_REF, "comment", comment);
    s.Pass(THIS_REF, "request_id", request_id);
    s.Pass(THIS_REF, "retcode_external", retcode_external);
    return SerializerNodeObject;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Order.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Action.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Includes Action's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Prevents processing this includes file for the second time.
#ifndef ACTION_ENUM_H
#define ACTION_ENUM_H

/* Defines action entry flags. */
enum ENUM_ACTION_ENTRY_FLAGS {
  ACTION_ENTRY_FLAG_NONE = 0,
  ACTION_ENTRY_FLAG_IS_ACTIVE = 1,
  ACTION_ENTRY_FLAG_IS_DONE = 2,
  ACTION_ENTRY_FLAG_IS_FAILED = 4,
  ACTION_ENTRY_FLAG_IS_INVALID = 8
};

/* Defines action types. */
enum ENUM_ACTION_TYPE {
  ACTION_TYPE_NONE = 0,   // None.
  ACTION_TYPE_ACTION,     // Action of action.
  ACTION_TYPE_EA,         // EA action.
  ACTION_TYPE_INDICATOR,  // Order action.
  ACTION_TYPE_ORDER,      // Order action.
  ACTION_TYPE_STRATEGY,   // Strategy action.
  ACTION_TYPE_TASK,       // Task action.
  ACTION_TYPE_TRADE,      // Trade action.
  ACTION_TYPE_TERMINAL,   // Terminal action.
  FINAL_ACTION_TYPE_ENTRY
};

/* Defines action types for Action class. */
enum ENUM_ACTION_ACTION {
  ACTION_ACTION_NONE = 0,          // Does nothing.
  ACTION_ACTION_DISABLE,           // Disables action.
  ACTION_ACTION_EXECUTE,           // Executes action.
  ACTION_ACTION_MARK_AS_DONE,      // Marks as done.
  ACTION_ACTION_MARK_AS_INVALID,   // Marks as invalid.
  ACTION_ACTION_MARK_AS_FAILED,    // Marks as failed.
  ACTION_ACTION_MARK_AS_FINISHED,  // Marks as finished.
  FINAL_ACTION_ACTION_ENTRY
};

/* EA actions. */
enum ENUM_EA_ACTION {
  EA_ACTION_DISABLE = 0,        // Disables EA.
  EA_ACTION_ENABLE,             // Enables EA.
  EA_ACTION_EXPORT_DATA,        // Trigger export data.
  EA_ACTION_STRATS_EXE_ACTION,  // Executes strategy's set action for all.
  EA_ACTION_TASKS_CLEAN,        // Clean tasks.
  FINAL_EA_ACTION_ENTRY
};

#endif  // End: ACTION_ENUM_H

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Action.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Deal.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2022, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Deal's enums.
 */

#ifndef __MQL__
enum ENUM_DEAL_TYPE {
  DEAL_TYPE_BUY,
  DEAL_TYPE_SELL,
  DEAL_TYPE_BALANCE,
  DEAL_TYPE_CREDIT,
  DEAL_TYPE_CHARGE,
  DEAL_TYPE_CORRECTION,
  DEAL_TYPE_BONUS,
  DEAL_TYPE_COMMISSION,
  DEAL_TYPE_COMMISSION_DAILY,
  DEAL_TYPE_COMMISSION_MONTHLY,
  DEAL_TYPE_COMMISSION_AGENT_DAILY,
  DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
  DEAL_TYPE_INTEREST,
  DEAL_TYPE_BUY_CANCELED,
  DEAL_TYPE_SELL_CANCELED,
  DEAL_DIVIDEND,
  DEAL_DIVIDEND_FRANKED,
  DEAL_TAX
};

enum ENUM_DEAL_ENTRY { DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT, DEAL_ENTRY_OUT_BY };

enum ENUM_DEAL_REASON {
  DEAL_REASON_CLIENT,
  DEAL_REASON_MOBILE,
  DEAL_REASON_WEB,
  DEAL_REASON_EXPERT,
  DEAL_REASON_SL,
  DEAL_REASON_TP,
  DEAL_REASON_SO,
  DEAL_REASON_ROLLOVER,
  DEAL_REASON_VMARGIN,
  DEAL_REASON_SPLIT
};

enum ENUM_DEAL_PROPERTY_DOUBLE { DEAL_VOLUME, DEAL_PRICE, DEAL_COMMISSION, DEAL_SWAP, DEAL_PROFIT, DEAL_FEE };

enum ENUM_DEAL_PROPERTY_INTEGER {
  DEAL_TICKET,
  DEAL_ORDER,
  DEAL_TIME,
  DEAL_TIME_MSC,
  DEAL_TYPE,
  DEAL_ENTRY,
  DEAL_MAGIC,
  DEAL_REASON,
  DEAL_POSITION_ID
};

enum ENUM_DEAL_PROPERTY_STRING { DEAL_SYMBOL, DEAL_COMMENT, DEAL_EXTERNAL_ID };
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Deal.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Log.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Collection.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef COLLECTION_MQH
#define COLLECTION_MQH

// Includes.


/**
 * Class to deal with collection of objects.
 */
template<typename X>
class Collection {
 protected:
  // Variables.
  string name;
  int index;
  ARRAY(Ref<X>, data);

 public:
  /**
   * Class constructor.
   */
  Collection() {}
  Collection(string _name) : name(_name) {}
  Collection(void *_obj) { Add(_obj); }
  ~Collection() {
  }

  /* Setters */

  /**
   * Add the object into the collection.
   */
  X *Add(X *_object) {
    int _size = ArraySize(data);
    int _count = ArrayResize(data, _size + 1, 100);
    if (_count > 0) {
      data[_size] = _object;
    } else {
      PrintFormat("ERROR at %s(): Cannot resize array!", __FUNCTION__);
    }
    return _count > 0 ? _object : NULL;
  }

  /* Getters */

  /**
   * Returns pointer to the collection item.
   */
  X *Get(X *_object) {
    if (_object != NULL) {
      int i;
      for (i = 0; i < ArraySize(data); i++) {
        if (_object == data[i].Ptr()) {
          return data[i].Ptr();
        }
      }
      return Add(_object);
    }
    return NULL;
  }

  /**
   * Returns pointer to the first valid object.
   */
  void *GetFirstItem() {
    int i;
    for (i = 0; i < ArraySize(data); i++) {
      if (data[i].Ptr() != NULL) {
        index = i;
        return data[i].Ptr();
      }
    }
    return NULL;
  }

  /**
   * Returns pointer to the current object.
   */
  X* GetCurrentItem() { return data[index].Ptr() != NULL ? data[index].Ptr() : NULL; }

  /**
   * Returns ID of the current object.
   */
  int GetCurrentIndex() { return index; }

  /**
   * Returns pointer to the next valid object.
   */
  X *GetNextItem() {
    int i;
    for (i = ++index; i < ArraySize(data); i++) {
      if (data[i].Ptr() != NULL) {
        index = i;
        return data[i].Ptr();
      }
    }
    return NULL;
  }

  /**
   * Returns pointer to the last valid object.
   */
  X *GetLastItem() {
    int i;
    for (i = ArraySize(data) - 1; i >= 0; i--) {
      if (data[i].Ptr() != NULL) {
        return data[i].Ptr();
      }
    }
    return NULL;
  }

  /**
   * Returns object item by array index.
   */
  X *GetByIndex(int _index) { return data[_index].Ptr(); }

  /**
   * Returns object item by object id.
   */
  X *GetById(long _id) {
    int i;
    X *_object = GetSize() > 0 ? data[0].Ptr() : NULL;
    for (i = 0; i < ArraySize(data); i++) {
      if (data[i].Ptr().GetId() == _id) {
        _object = data[i].Ptr();
      }
    }
    return _object;
  }

  /**
   * Returns pointer to the collection item with the lowest weight.
   */
  X *GetLowest() {
    int i;
    X *_object = GetSize() > 0 ? data[0].Ptr() : NULL;
    for (i = 0; i < ArraySize(data); i++) {
      double _weight = data[i].Ptr().GetWeight();
      if (_weight < _object.GetWeight()) {
        _object = data[i].Ptr();
      }
    }
    return _object;
  }

  /**
   * Returns pointer to the collection item with the highest weight.
   */
  X *GetHighest() {
    int i;
    X *_object = GetSize() > 0 ? data[0].Ptr() : NULL;
    for (i = 0; i < ArraySize(data); i++) {
      double _weight = data[i].Ptr().GetWeight();
      if (_weight > _object.GetWeight()) {
        _object = data[i].Ptr();
      }
    }
    return _object;
  }

  /**
   * Returns name of the collection.
   */
  string GetName() { return name; }

  /**
   * Returns size of the collection.
   */
  int GetSize() { return ArraySize(data); }

  /* Printers */

  /**
   * Fetch object textual data by calling each ToString() method.
   */
  string ToString(double _min_weight = 0, string _dlm = ";") {
    int i;
    string _out = name + ": ";
    for (i = 0; i < ArraySize(data); i++) {
      if (data[i].Ptr() != NULL) {
        if (data[i].Ptr().GetWeight() >= _min_weight) {
          _out += data[i].Ptr().ToString() + _dlm;
        }
      }
    }
    return _out;
  }
};
#endif  // COLLECTION_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Collection.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictStruct.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Array.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DateTime.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Array.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.struct.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Class to work with data of datetime type.
 *
 * @docs
 * - https://docs.mql4.com/dateandtime
 * - https://www.mql5.com/en/docs/dateandtime
 */

// Prevents processing this includes file for the second time.
#ifndef DATETIME_MQH
#define DATETIME_MQH

// Forward declarations.
struct DataParamEntry;

// Includes class enum and structs.





#ifndef __MQL4__
// Defines global functions (for MQL4 backward compatibility).
string TimeToStr(datetime _value, int _mode) { return DateTimeStatic::TimeToStr(_value, _mode); }
#endif

/*
 * Class to provide functions that deals with date and time.
 */
class DateTime {
 public:
  // Struct variables.
  DateTimeEntry dt_curr, dt_last;

  /* Special methods */

  /**
   * Class constructor.
   */
  DateTime() { TimeToStruct(TimeCurrent(), dt_curr); }
  DateTime(DateTimeEntry &_dt) { dt_curr = _dt; }
  DateTime(MqlDateTime &_dt) { dt_curr = _dt; }
  DateTime(datetime _dt) { dt_curr.Set(_dt); }

  /**
   * Class deconstructor.
   */
  ~DateTime() {}

  /* Getters */

  /**
   * Returns the DateTimeEntry struct.
   */
  DateTimeEntry GetEntry() const { return dt_curr; }

  /**
   * Returns started periods (e.g. new minute, hour).
   *
   * @param
   * _unit - given periods to check
   * _update - whether to update datetime before check
   *
   * @return int
   * Returns bitwise flag of started periods.
   */
  unsigned int GetStartedPeriods(bool _update = true, bool _update_last = true) {
    unsigned int _result = DATETIME_NONE;
    if (_update) {
      Update();
    }

    if (dt_curr.GetValue(DATETIME_YEAR) != dt_last.GetValue(DATETIME_YEAR)) {
      // New year started.
      _result |= DATETIME_YEAR | DATETIME_MONTH | DATETIME_DAY | DATETIME_HOUR | DATETIME_MINUTE | DATETIME_SECOND;
    } else if (dt_curr.GetValue(DATETIME_MONTH) != dt_last.GetValue(DATETIME_MONTH)) {
      // New month started.
      _result |= DATETIME_MONTH | DATETIME_DAY | DATETIME_HOUR | DATETIME_MINUTE | DATETIME_SECOND;
    } else if (dt_curr.GetValue(DATETIME_DAY) != dt_last.GetValue(DATETIME_DAY)) {
      // New day started.
      _result |= DATETIME_DAY | DATETIME_HOUR | DATETIME_MINUTE | DATETIME_SECOND;
    } else if (dt_curr.GetValue(DATETIME_HOUR) != dt_last.GetValue(DATETIME_HOUR)) {
      // New hour started.
      _result |= DATETIME_HOUR | DATETIME_MINUTE | DATETIME_SECOND;
    } else if (dt_curr.GetValue(DATETIME_MINUTE) != dt_last.GetValue(DATETIME_MINUTE)) {
      // New minute started.
      _result |= DATETIME_MINUTE | DATETIME_SECOND;
    } else if (dt_curr.GetValue(DATETIME_SECOND) != dt_last.GetValue(DATETIME_SECOND)) {
      // New second started.
      _result |= DATETIME_SECOND;
    }

    if (dt_curr.GetValue(DATETIME_DAY | DATETIME_WEEK) != dt_last.GetValue(DATETIME_DAY | DATETIME_WEEK)) {
      // New week started.
      _result |= DATETIME_WEEK;
    }

#ifdef __debug__
    string _passed =
        "time now " + (string)dt_curr.GetTimestamp() + ", time last " + (string)dt_last.GetTimestamp() + " ";

    if (_update) {
      _passed += "updating time ";
    }

    if ((_result & DATETIME_MONTH) != 0) {
      _passed += "[month passed] ";
    }

    if ((_result & DATETIME_WEEK) != 0) {
      _passed += "[week passed] ";
    }

    if ((_result & DATETIME_DAY) != 0) {
      _passed += "[day passed] ";
    }

    if ((_result & DATETIME_HOUR) != 0) {
      _passed += "[hour passed] ";
    }

    if ((_result & DATETIME_MINUTE) != 0) {
      _passed += "[minute passed] ";
    }

    if ((_result & DATETIME_SECOND) != 0) {
      _passed += "[second passed] ";
    }

    if (_update_last) {
      _passed += "(setting last time) ";
    }

    if (_passed != "") {
      Print(_passed);
    }
#endif

    if (_update_last) {
      dt_last = dt_curr;
    }

    return _result;
  }

  /* Setters */

  /**
   * Sets the new DateTimeEntry struct.
   */
  void SetEntry(DateTimeEntry &_dt) { dt_curr = _dt; }

  /* Dynamic methods */

  /**
   * Checks if new minute started.
   *
   * @return bool
   * Returns true when new minute started.
   */
  bool IsNewMinute(bool _update = true) {
    bool _result = false;
    if (_update) {
      dt_last = dt_curr;
      Update();
    }
    int _prev_secs = dt_last.GetSeconds();
    int _curr_secs = dt_curr.GetSeconds();
    if (dt_curr.GetSeconds() < dt_last.GetSeconds()) {
      _result = true;
    }
    dt_last = dt_curr;
    return _result;
  }

  /**
   * Updates datetime to the current one.
   */
  void Update() { dt_curr.Set(TimeCurrent()); }

  /* Conditions */

  /**
   * Checks for datetime condition.
   *
   * @param ENUM_DATETIME_CONDITION _cond
   *   Datetime condition.
   * @param MqlParam[] _args
   *   Condition arguments.
   * @return
   *   Returns true when the condition is met.
   */
  static bool CheckCondition(ENUM_DATETIME_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    switch (_cond) {
      case DATETIME_COND_IS_PEAK_HOUR:
        return DateTimeStatic::IsPeakHour();
      case DATETIME_COND_NEW_HOUR:
        return DateTimeStatic::Minute() == 0;
      case DATETIME_COND_NEW_DAY:
        return DateTimeStatic::Hour() == 0 && DateTimeStatic::Minute() == 0;
      case DATETIME_COND_NEW_WEEK:
        return DateTimeStatic::DayOfWeek() == 1 && DateTimeStatic::Hour() == 0 && DateTimeStatic::Minute() == 0;
      case DATETIME_COND_NEW_MONTH:
        return DateTimeStatic::Day() == 1 && DateTimeStatic::Hour() == 0 && DateTimeStatic::Minute() == 0;
      case DATETIME_COND_NEW_YEAR:
        return DateTimeStatic::DayOfYear() == 1 && DateTimeStatic::Hour() == 0 && DateTimeStatic::Minute() == 0;
      default:
#ifdef __debug__
        Print(StringFormat("%s: Error: Invalid datetime condition: %d!", __FUNCTION__, _cond));
#endif
        return false;
    }
  }
  static bool CheckCondition(ENUM_DATETIME_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return DateTime::CheckCondition(_cond, _args);
  }
};
#endif  // DATETIME_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DateTime.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.






// Prevents processing this includes file for the second time.
#ifndef LOG_MQH
#define LOG_MQH

// Define assert macros.
// Alias for function and line macros combined together.
#define __FUNCTION_LINE__ string(__FUNCTION__) + ":" + IntegerToString(__LINE__)

// Log verbosity level.
enum ENUM_LOG_LEVEL {
  V_NONE = 0,     // None
  V_ERROR = 1,    // Errors only
  V_WARNING = 2,  // Errors and warnings
  V_INFO = 3,     // All (info, errors and warnings)
  V_DEBUG = 4,    // All with debug!
  V_TRACE = 5     // All with debug and trace!
};

/**
 * Class to provide logging functionality.
 */
class Log : public Object {
 private:
  struct log_entry {
    datetime timestamp;
    ENUM_LOG_LEVEL log_level;
    string msg;
  };
  DictStruct<int, Ref<Log>> logs;
  string filename;
  ARRAY(log_entry, data);
  int last_entry;
  datetime last_flush;
  ENUM_LOG_LEVEL log_level;

 public:
  /**
   * Class constructor.
   */
  Log(ENUM_LOG_LEVEL _log_level = V_INFO, string new_filename = "")
      : last_entry(-1), last_flush(0), log_level(_log_level), filename(new_filename != "" ? new_filename : "Log.txt") {}

  /**
   * Class deconstructor.
   */
  ~Log() { Flush(); }

  /* Getters */

  /**
   * Get last message.
   */
  string GetLastMsg(ENUM_LOG_LEVEL _level = V_INFO, bool _dt = false) {
    int i;
    string _output = "";
    for (i = last_entry; i == 0; i--) {
      if (data[i].log_level <= _level) {
        _output += (_dt ? DateTimeStatic::TimeToStr(data[i].timestamp) + ": " : "") + data[i].msg;
        break;
      }
    }
    return _output;
  }

  /**
   * Returns log level.
   */
  ENUM_LOG_LEVEL GetLevel() { return log_level; }

  /**
   * Returns level name.
   */
  string GetLevelName(ENUM_LOG_LEVEL _log_level) { return StringSubstr(EnumToString(_log_level), 2); }

  /* Setters */

  /**
   * Sets new log level.
   */
  void SetLevel(ENUM_LOG_LEVEL _log_level) { log_level = _log_level; }

  /* Other methods */

  /**
   * Adds a log entry.
   */
  bool Add(ENUM_LOG_LEVEL _log_level, string msg, string prefix, string suffix) {
    if (_log_level > log_level) {
      // Ignore entry if verbosity is higher than set.
      return false;
    }
    int _size = ArraySize(data);
    if (last_entry > 0 && msg == data[last_entry].msg) {
      // Avoid adding duplicate messages.
      return false;
    }
    if (++last_entry >= _size) {
      if (!ArrayResize(data, (_size + 100), 100)) {
        return false;
      }
    }
    msg = GetLevelName(_log_level) + ": " + (prefix != "" ? prefix + ": " : "") + msg +
          (suffix != "" ? "; " + suffix : "");
    data[last_entry].timestamp = TimeCurrent();
    data[last_entry].log_level = _log_level;
    data[last_entry].msg = msg;
    return true;
  }

  /**
   * Adds a log entry.
   */
  bool Add(string msg, string prefix, string suffix, ENUM_LOG_LEVEL entry_log_level = V_INFO) {
    return Add(prefix, msg, suffix, entry_log_level);
  }
  bool Add(ARRAY_REF(double, arr), string prefix, string suffix, ENUM_LOG_LEVEL entry_log_level = V_INFO) {
    return Add(prefix, Array::ArrToString(arr), suffix, entry_log_level);
  }

  /**
   * Reports an last error.
   */
  bool AddLastError(string prefix = "", string suffix = "");
  bool AddLastError(string prefix, long suffix);

  /**
   * Reports an error.
   */
  bool Error(string msg, string prefix = "", string suffix = "") { return Add(V_ERROR, msg, prefix, suffix); }

  /**
   * Reports a warning.
   */
  bool Warning(string msg, string prefix = "", string suffix = "") { return Add(V_WARNING, msg, prefix, suffix); }

  /**
   * Reports an info message.
   */
  bool Info(string msg, string prefix = "", string suffix = "") { return Add(V_INFO, msg, prefix, suffix); }

  /**
   * Reports a debug message for debugging purposes.
   */
  bool Debug(string msg, string prefix = "", string suffix = "") { return Add(V_DEBUG, msg, prefix, suffix); }

  /**
   * Reports a debug message for debugging purposes.
   */
  bool Trace(string msg, string prefix = "", string suffix = "") { return Add(V_TRACE, msg, prefix, suffix); }

  /**
   * Link this instance with another log instance.
   */
  void Link(Log *_log) {
    PTR_ATTRIB(_log, SetLevel(log_level));  // Sets the same level as this instance.
    // @todo: Make sure we're not linking the same instance twice.
    logs.Push(_log);
  }

  /**
   * Copy logs into another array.
   */
  bool Copy(ARRAY_REF(log_entry, _logs)) {
    // @fixme
    // Error: 'ArrayCopy<log_entry>' - cannot to apply function template
    // Array::ArrayCopy(_logs, data, 0, 0, WHOLE_ARRAY);
    if (!ArrayResize(_logs, last_entry)) {
      return false;
    }
    for (int i = 0; i < last_entry; i++) {
      _logs[i] = data[i];
    }
    return ArraySize(_logs) > 0;
  }

  /**
   * Append logs into another array.
   */
  bool Append(ARRAY_REF(log_entry, _logs)) {
    // @fixme
    // Error: 'ArrayCopy<log_entry>' - cannot to apply function template
    // Array::ArrayCopy(_logs, data, 0, 0, WHOLE_ARRAY);
    uint _size = ArraySize(_logs);
    if (!ArrayResize(_logs, _size + last_entry)) {
      return false;
    }
    for (int i = 0; i < last_entry; i++) {
      _logs[_size + i] = data[i];
    }
    return ArraySize(_logs) > 0;
  }

/**
 * Flushes all log entries by printing them to the output.
 */
#ifdef __MQL__
  template <>
#endif
  void Flush(int _freq = 0, bool _dt = true) {
    if (_freq > 0 && last_flush + _freq >= TimeCurrent()) {
      // Avoids flushing logs too often.
      return;
    }
    for (int i = 0; i <= last_entry; i++) {
      if (data[i].timestamp > last_flush) {
        Print((_dt ? DateTimeStatic::TimeToStr(data[i].timestamp) + ": " : ""), data[i].msg);
      }
    }
    // Flush logs from another linked instances.
    for (DictStructIterator<int, Ref<Log>> _li = logs.Begin(); _li.IsValid(); ++_li) {
      Log *_log = _li.Value().Ptr();
      if (Object::IsValid(_log)) {
        PTR_ATTRIB(_log, Flush());
      }
    }

    last_entry = -1;
    last_flush = TimeCurrent();
  }

  /**
   * Flushes all log entries by printing them to the output.
   */
  /*
 void Flush(bool _dt = true) {
   Flush(log_level, _dt);
 }
 */

  virtual const string ToString() {
    string result;

    unsigned int lid;
    int i;
    for (i = 0; i <= last_entry; i++) {
      result += DateTimeStatic::TimeToStr(data[i].timestamp) + ": " + data[i].msg + "\n";
    }

    Log *_log;
    // Flush logs from another linked instances.
    for (lid = 0; lid < logs.Size(); lid++) {
      _log = logs[lid].Ptr();
      if (Object::IsValid(_log)) {
        result += PTR_ATTRIB(_log, ToString());
      }
    }

    return result;
  }

  /**
   * Save logs to file in CSV format.
   */
  bool SaveToFile(string new_filename, ENUM_LOG_LEVEL _log_level) {
    string filepath = new_filename != "" ? new_filename : filename;
    int handle = FileOpen(filepath, FILE_WRITE | FILE_CSV, ':');
    if (handle != INVALID_HANDLE) {
      for (int i = 0; i < ArraySize(data); i++) {
        if (data[i].log_level <= _log_level) {
          FileWrite(handle, TimeToString(data[i].timestamp, TIME_DATE | TIME_MINUTES), ": ", data[i].msg);
        }
      }
      FileClose(handle);
      return true;
    } else {
      FileClose(handle);
      return false;
    }
  }

  bool SaveToFile(string new_filename = "") { return SaveToFile(new_filename, log_level); }

  template <typename T>
  void Erase(ARRAY_REF(T, A), int iPos) {
    int iLast = ArraySize(A) - 1;
    A[iPos].timestamp = A[iLast].timestamp;
    A[iPos].msg = A[iLast].msg;
    ArrayResize(A, iLast);
  }

  bool DeleteByTimestamp(datetime timestamp) {
    int size = ArraySize(data);
    if (size > 0) {
      int offset = 0;
      for (int i = 0; i < size; i++) {
        if (data[i].timestamp == timestamp) {
          Erase(data, i);
          return true;
          break;
        }
      }
    }
    return false;
  }
};



/**
 * Reports last error.
 */
bool Log::AddLastError(string prefix, string suffix) {
  return Add(V_ERROR, Terminal::GetLastErrorText(), prefix, suffix);
}
bool Log::AddLastError(string prefix, long suffix) {
  return Add(V_ERROR, Terminal::GetLastErrorText(), prefix, StringFormat("%d", suffix));
}

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Log.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SerializerJson.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictBase.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef SERIALIZER_JSON_MQH
#define SERIALIZER_JSON_MQH

// Includes.





class Log;

enum ENUM_SERIALIZER_JSON_FLAGS {
  SERIALIZER_JSON_NO_WHITESPACES = 1,
  SERIALIZER_JSON_INDENT_2_SPACES = 2,
  SERIALIZER_JSON_INDENT_4_SPACES = 4
};

class SerializerJson {
 public:
  /**
   * Serializes node and its children into string in generic format (JSON at now).
   */
  static string Stringify(SerializerNode* _node, unsigned int stringify_flags = 0, void* stringify_aux_arg = NULL,
                          unsigned int indent = 0) {
    string repr;
    string ident;

    bool trimWhitespaces = bool(stringify_flags & SERIALIZER_JSON_NO_WHITESPACES);

    int indentSize;

    if (bool(stringify_flags & SERIALIZER_JSON_INDENT_2_SPACES))
      indentSize = 2;
    else if (bool(stringify_flags & SERIALIZER_JSON_INDENT_4_SPACES))
      indentSize = 4;
    else
      indentSize = 2;

    if (!trimWhitespaces)
      for (unsigned int i = 0; i < indent * indentSize; ++i) ident += " ";

    repr += ident;

    if (PTR_ATTRIB(_node, GetKeyParam()) != NULL && PTR_ATTRIB(PTR_ATTRIB(_node, GetKeyParam()), AsString(false, false)) != "")
      repr += PTR_ATTRIB(PTR_ATTRIB(_node, GetKeyParam()), AsString(false, true)) + ":" + (trimWhitespaces ? "" : " ");

    if (PTR_ATTRIB(_node, GetValueParam()) != NULL) repr += PTR_ATTRIB(PTR_ATTRIB(_node, GetValueParam()), AsString(false, true));

    switch (PTR_ATTRIB(_node, GetType())) {
      case SerializerNodeObject:
        repr += string("{") + (trimWhitespaces ? "" : "\n");
        break;
      case SerializerNodeArray:
        repr += string("[") + (trimWhitespaces ? "" : "\n");
        break;
    }

    if (PTR_ATTRIB(_node, HasChildren())) {
      for (unsigned int j = 0; j < PTR_ATTRIB(_node, NumChildren()); ++j) {
        repr += PTR_ATTRIB(PTR_ATTRIB(_node, GetChild(j)), ToString(trimWhitespaces, indentSize, indent + 1));
      }
    }

    switch (PTR_ATTRIB(_node, GetType())) {
      case SerializerNodeObject:
        repr += ident + "}";
        break;
      case SerializerNodeArray:
        repr += ident + "]";
        break;
    }

    if (!PTR_ATTRIB(_node, IsLast())) repr += ",";

    // Appending newline only when inside the root node.
    if (indent != 0) repr += (trimWhitespaces ? "" : "\n");

    return repr;
  }

  template <typename X>
  static bool Parse(string data, X* obj, Log* logger = NULL) {
    return Parse(data, *obj, logger);
  }

  template <typename X>
  static bool Parse(string data, X& obj, Log* logger = NULL) {
    SerializerNode* node = Parse(data);

    if (!node) {
      // Parsing failed.
      return false;
    }

    Serializer serializer(node, JsonUnserialize);

    if (logger != NULL) serializer.Logger().Link(logger);

    // We don't use result. We parse data as it is.
    obj.Serialize(serializer);

    return true;
  }

  static SerializerNode* Parse(string data, unsigned int converter_flags = 0) {
    SerializerNodeType type;
    if (StringGetCharacter(data, 0) == '{')
      type = SerializerNodeObject;
    else if (StringGetCharacter(data, 0) == '[')
      type = SerializerNodeArray;
    else {
      return GracefulReturn("Failed to parse JSON. It must start with either \"{\" or \"[\".", 0, NULL, NULL);
    }

    SerializerNode* root = NULL;
    SerializerNode* current = NULL;
    SerializerNode* node = NULL;

    string extracted;

    bool isOuterScope = true;
    bool expectingKey = false;
    bool expectingValue = false;
    bool expectingSemicolon = false;
    SerializerNodeParam* key = NULL;
    SerializerNodeParam* value = NULL;
    unsigned short ch, ch2;
    unsigned int k;

    for (unsigned int i = 0; i < (unsigned int)StringLen(data); ++i) {
      ch = StringGetCharacter(data, i);

      // ch2 will be an another non-whitespace character.
      k = i + 1;
      do {
        ch2 = StringGetCharacter(data, k++);
        if (GetLastError() == 5041) {
          ResetLastError();
          ch2 = 0;
          break;
        }
      } while (ch2 == ' ' || ch2 == '\t' || ch2 == '\n' || ch2 == '\r');

      if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') continue;

      if (ch == '"') {
        extracted = ExtractString(data, i + 1);

        if (extracted == "") {
          return GracefulReturn("Unexpected end of file when parsing string", i, root, key);
        }
        if (expectingKey) {
          key = SerializerNodeParam::FromString(extracted);
          expectingKey = false;
          expectingSemicolon = true;
        } else if (expectingValue) {
          PTR_ATTRIB(current, AddChild(new SerializerNode(
              PTR_ATTRIB(current, GetType()) == SerializerNodeObject ? SerializerNodeObjectProperty : SerializerNodeArrayItem,
              current, key, SerializerNodeParam::FromString(extracted))));

#ifdef __debug__
          Print("SerializerJson: Value \"" + extracted + "\" for key " +
                (key != NULL ? ("\"" + key.ToString() + "\"") : "<none>"));
#endif

          expectingValue = false;
        } else {
          return GracefulReturn("Unexpected '\"' symbol", i, root, key);
        }

        // Skipping double quotes.
        i += StringLen(extracted) + 1;
      } else if (expectingSemicolon) {
        if (ch != ':') {
          return GracefulReturn("Expected semicolon", i, root, key);
        }
        expectingSemicolon = false;
        expectingValue = true;
      } else if (ch == '{') {
        if (expectingKey) {
          return GracefulReturn("Cannot use object as a key", i, root, key);
        }

#ifdef __debug__
        Print("SerializerJson: Entering object for key " + (key != NULL ? ("\"" + key.ToString() + "\"") : "<none>"));
#endif

        node = new SerializerNode(SerializerNodeObject, current, key);

        if (!root) root = node;

        if (expectingValue) PTR_ATTRIB(current, AddChild(node));

        current = node;

        isOuterScope = false;
        expectingValue = false;
        expectingKey = ch2 != '}';
        key = NULL;
      } else if (ch == '}') {
        if (expectingKey || expectingValue || PTR_ATTRIB(current, GetType()) != SerializerNodeObject) {
          return GracefulReturn("Unexpected end of object", i, root, key);
        }

#ifdef __debug__
        Print("SerializerJson: Leaving object for key " + (current != NULL && current.GetKeyParam() != NULL
                                                               ? ("\"" + current.GetKeyParam().ToString() + "\"")
                                                               : "<none>"));
#endif

        current = PTR_ATTRIB(current, GetParent());
        expectingValue = false;
      } else if (ch == '[') {
#ifdef __debug__
        Print("SerializerJson: Entering list for key " + (key != NULL ? ("\"" + key.ToString() + "\"") : "<none>"));
#endif

        if (expectingKey) {
          return GracefulReturn("Cannot use array as a key", i, root, key);
        }

        node = new SerializerNode(SerializerNodeArray, current, key);

        if (!root) root = node;

        if (expectingValue) PTR_ATTRIB(current, AddChild(node));

        current = node;
        expectingValue = ch2 != ']';
        isOuterScope = false;
        key = NULL;
      } else if (ch == ']') {
#ifdef __debug__
        Print("SerializerJson: Leaving list for key " + (key != NULL ? ("\"" + key.ToString() + "\"") : "<none>"));
#endif

        if (expectingKey || expectingValue || PTR_ATTRIB(current, GetType()) != SerializerNodeArray) {
          return GracefulReturn("Unexpected end of array", i, root, key);
        }

        current = PTR_ATTRIB(current, GetParent());
        expectingValue = false;
      } else if (ch >= '0' && ch <= '9') {
        if (!expectingValue) {
          return GracefulReturn("Unexpected numeric value", i, root, key);
        }

        if (!ExtractNumber(data, i, extracted)) {
          return GracefulReturn("Cannot parse numeric value", i, root, key);
        }

        value = StringFind(extracted, ".") != -1 ? SerializerNodeParam::FromValue(StringToDouble(extracted))
                                                 : SerializerNodeParam::FromValue(StringToInteger(extracted));
#ifdef __debug__
        Print("SerializerJson: Value " + value.AsString() + " for key " +
              (key != NULL ? ("\"" + key.ToString() + "\"") : "<none>"));
#endif

        PTR_ATTRIB(current, AddChild(new SerializerNode(
            PTR_ATTRIB(current, GetType()) == SerializerNodeObject ? SerializerNodeObjectProperty : SerializerNodeArrayItem, current,
            key, value)));
        expectingValue = false;

        // Skipping value.
        i += StringLen(extracted) - 1;

        // We don't want to delete it twice.
        key = NULL;
      } else if (ch == 't' || ch == 'f') {
        // Assuming true/false.

        value = SerializerNodeParam::FromValue(ch == 't' ? true : false);

#ifdef __debug__
        Print("SerializerJson: Value " + (value.ToBool() ? "true" : "false") + " for key " +
              (key != NULL ? ("\"" + key.ToString() + "\"") : "<none>"));
#endif

        // Skipping value.
        i += ch == 't' ? 3 : 4;

        PTR_ATTRIB(current, AddChild(new SerializerNode(
            PTR_ATTRIB(current, GetType()) == SerializerNodeObject ? SerializerNodeObjectProperty : SerializerNodeArrayItem, current,
            key, value)));
        expectingValue = false;

        // We don't want to delete it twice.
        key = NULL;
      } else if (ch == ',') {
        if (expectingKey || expectingValue || expectingSemicolon) {
          return GracefulReturn("Unexpected comma", i, root, key);
        }

        if (PTR_ATTRIB(current, GetType()) == SerializerNodeObject)
          expectingKey = true;
        else
          expectingValue = true;
      }
    }

    if (key) delete key;

    return root;
  }

  static SerializerNode* GracefulReturn(string error, unsigned int index, SerializerNode* root,
                                        SerializerNodeParam* key) {
    Print(error + " at index ", index);

    if (root != NULL) delete root;

    if (key != NULL) delete key;

    return NULL;
  }

  static bool ExtractNumber(string& data, unsigned int index, string& number) {
    string str;

    for (unsigned int i = index; i < (unsigned int)StringLen(data); ++i) {
#ifdef __MQL5__
      unsigned short ch = StringGetCharacter(data, i);
#else
      unsigned short ch = StringGetChar(data, i);
#endif

      if (ch >= '0' && ch <= '9') {
        str += ShortToString(ch);
      } else if (ch == '.') {
        if (i == index) {
          return false;
        }
        str += ShortToString(ch);
      } else {
        // End of the number.
        number = str;
        return true;
      }
    }

    return true;
  }

  static string ExtractString(string& data, unsigned int index) {
    for (unsigned int i = index; i < (unsigned int)StringLen(data); ++i) {
      unsigned short ch = StringGetCharacter(data, i);

      if (ch == '"') {
        return StringSubstr(data, index, i - index);
      }
    }

    return NULL;
  }
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SerializerJson.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Order.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                     Copyright 2016-2021, EA31337 |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Order's defines.
 */

#ifndef __MQL4__
// Mode constants.
#define MODE_TRADES 0
#define MODE_HISTORY 1
// Order operations.
#define OP_BUY ORDER_TYPE_BUY               // Buy
#define OP_SELL ORDER_TYPE_SELL             // Sell
#define OP_BUYLIMIT ORDER_TYPE_BUY_LIMIT    // Pending order of BUY LIMIT type
#define OP_SELLLIMIT ORDER_TYPE_SELL_LIMIT  // Pending order of SELL LIMIT type
#define OP_BUYSTOP ORDER_TYPE_BUY_STOP      // Pending order of BUY STOP type
#define OP_SELLSTOP ORDER_TYPE_SELL_STOP    // Pending order of SELL STOP type
#define OP_BALANCE 6
// --
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Order.define.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SymbolInfo.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SymbolInfo.struct.static.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SymbolInfo.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: ISerializable.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: MqlTick.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SymbolInfo.struct.static.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes SymbolInfo's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.




// Defines struct to store symbol data.
struct SymbolInfoEntry
#ifndef __MQL__
    : public ISerializable
#endif
{
  double bid;            // Current Bid price.
  double ask;            // Current Ask price.
  double last;           // Price of the last deal.
  double spread;         // Current spread.
  unsigned long volume;  // Volume for the current last price.
  // Constructor.
  SymbolInfoEntry() : bid(0), ask(0), last(0), spread(0), volume(0) {}
  SymbolInfoEntry(const MqlTick& _tick, const string _symbol = "") {
    bid = _tick.bid;
    ask = _tick.ask;
    last = _tick.last;
    volume = _tick.volume;
    spread = (unsigned int)round((ask - bid) * pow(10, SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_DIGITS)));
  }
  // Getters
  string ToCSV() { return StringFormat("%g,%g,%g,%g,%d", bid, ask, last, spread, volume); }
// Serializers.
#ifdef __MQL__
  template <>
#endif
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {
  }
  SerializerNodeType Serialize(Serializer& _s);
};

// Defines structure for SymbolInfo properties.
struct SymbolInfoProp {
  double pip_value;          // Pip value.
  unsigned int pip_digits;   // Pip digits (precision).
  unsigned int pts_per_pip;  // Points per pip.
  unsigned int vol_digits;   // Volume digits.
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer& _s);
};



SerializerNodeType SymbolInfoEntry::Serialize(Serializer& _s) {
  _s.Pass(THIS_REF, "ask", ask);
  _s.Pass(THIS_REF, "bid", bid);
  _s.Pass(THIS_REF, "last", last);
  _s.Pass(THIS_REF, "spread", spread);
  _s.Pass(THIS_REF, "volume", volume);
  return SerializerNodeObject;
}

SerializerNodeType SymbolInfoProp::Serialize(Serializer& _s) {
  _s.Pass(THIS_REF, "pip_value", pip_value);
  _s.Pass(THIS_REF, "pip_digits", pip_digits);
  _s.Pass(THIS_REF, "pts_per_pip", pts_per_pip);
  _s.Pass(THIS_REF, "vol_digits", vol_digits);
  return SerializerNodeObject;
}

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SymbolInfo.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SymbolInfo.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * SymbolInfo's defines.
 */

/* Defines */

#ifdef __MQL5__
// --
#define Point _Point
#define Digits _Digits
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SymbolInfo.define.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerNode.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Log.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SymbolInfo.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SymbolInfo.enum.symbols.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes SymbolInfo's symbol enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/**
 * Enumeration for the Crypto symbols.
 */
enum ENUM_SYMBOL_LIST_CRYPTO {
  SYMBOL_CRYPTO_BTCEUR,  // BTCEUR
  SYMBOL_CRYPTO_BTCCNH,  // BTCCNH
  SYMBOL_CRYPTO_BTCCNY,  // BTCCNY
  SYMBOL_CRYPTO_BTCJPY,  // BTCJPY
  SYMBOL_CRYPTO_BTCRUB,  // BTCRUB
  SYMBOL_CRYPTO_DSHUSD,  // DSHUSD
  SYMBOL_CRYPTO_ETCUSD,  // ETCUSD
  SYMBOL_CRYPTO_ETCBTC,  // ETCBTC
  SYMBOL_CRYPTO_ETCETH,  // ETCETH
  SYMBOL_CRYPTO_ETHUSD,  // ETHUSD
  SYMBOL_CRYPTO_ETHBTC,  // ETHBTC
  SYMBOL_CRYPTO_ETHLTC,  // ETHLTC
  SYMBOL_CRYPTO_BTCUSD,  // BTCUSD
  SYMBOL_CRYPTO_ETHRUB,  // ETHRUB
  SYMBOL_CRYPTO_EMCUSD,  // EMCUSD
  SYMBOL_CRYPTO_LTCUSD,  // LTCUSD
  SYMBOL_CRYPTO_BTCBTC,  // BTCBTC
  SYMBOL_CRYPTO_LTCEUR,  // LTCEUR
  SYMBOL_CRYPTO_LTCCNH,  // LTCCNH
  SYMBOL_CRYPTO_LTCCNY,  // LTCCNY
  SYMBOL_CRYPTO_LTCJPY,  // LTCJPY
  SYMBOL_CRYPTO_LTCRUB,  // LTCRUB
  SYMBOL_CRYPTO_MBTUSD,  // MBTUSD
  SYMBOL_CRYPTO_XMRUSD,  // XMRUSD
  SYMBOL_CRYPTO_XRPUSD,  // XRPUSD
  SYMBOL_CRYPTO_ZECUSD,  // ZECUSD
  SYMBOL_CRYPTO_EOSUSD,  // EOSUSD
};

/**
 * Enumeration for the energy symbols.
 */
enum ENUM_SYMBOL_LIST_ENERGY {
  SYMBOL_ENERGY_XBRUSD,  // Brent Oil vs US Dollar (XBRUSD)
  SYMBOL_ENERGY_XNGUSD,  // Natural Gas vs US Dollar (XNGUSD)
  SYMBOL_ENERGY_XTIUSD,  // Crude Oil vs US Dollar (XTIUSD)
};

/**
 * Enumeration for the Forex symbols.
 */
enum ENUM_SYMBOL_LIST_FOREX {
  SYMBOL_FOREX_AUDCAD,  // AUDJPY
  SYMBOL_FOREX_AUDCHF,  // AUDNZD
  SYMBOL_FOREX_AUDJPY,  // AUDUSD
  SYMBOL_FOREX_AUDNZD,  // CADJPY
  SYMBOL_FOREX_AUDUSD,  // CHFJPY
  SYMBOL_FOREX_CADCHF,  // EURAUD
  SYMBOL_FOREX_CADJPY,  // EURCAD
  SYMBOL_FOREX_CHFJPY,  // EURCHF
  SYMBOL_FOREX_EURAUD,  // EURGBP
  SYMBOL_FOREX_EURCAD,  // EURJPY
  SYMBOL_FOREX_EURCHF,  // EURNOK
  SYMBOL_FOREX_EURGBP,  // EURSEK
  SYMBOL_FOREX_EURJPY,  // EURUSD
  SYMBOL_FOREX_EURNOK,  // GBPCHF
  SYMBOL_FOREX_EURNZD,  // GBPJPY
  SYMBOL_FOREX_EURSEK,  // GBPUSD
  SYMBOL_FOREX_EURUSD,  // NZDUSD
  SYMBOL_FOREX_GBPAUD,  // USDCAD
  SYMBOL_FOREX_GBPCAD,  // USDCHF
  SYMBOL_FOREX_GBPCHF,  // USDJPY
  SYMBOL_FOREX_GBPJPY,  // USDNOK
  SYMBOL_FOREX_GBPNZD,  // USDSEK
  SYMBOL_FOREX_GBPUSD,  // USDSGD
  SYMBOL_FOREX_NZDCAD,  // AUDCAD
  SYMBOL_FOREX_NZDCHF,  // AUDCHF
  SYMBOL_FOREX_NZDJPY,  // CADCHF
  SYMBOL_FOREX_NZDUSD,  // EURNZD
  SYMBOL_FOREX_USDCAD,  // GBPAUD
  SYMBOL_FOREX_USDCHF,  // GBPCAD
  SYMBOL_FOREX_USDJPY,  // GBPNZD
  SYMBOL_FOREX_USDNOK,  // NZDCAD
  SYMBOL_FOREX_USDSEK,  // NZDCHF
  SYMBOL_FOREX_USDSGD,  // NZDJPY
};

/**
 * Enumeration for the index symbols.
 */
enum ENUM_SYMBOL_LIST_INDEX {
  SYMBOL_INDEX_FCHI40,  // CAC 40 Index
  SYMBOL_INDEX_GDAXIm,  // DAX 30 Index
  SYMBOL_INDEX_HSI50,   // HSI 50 Index
  SYMBOL_INDEX_ND100m,  // NASDAX 100 Index
  SYMBOL_INDEX_AUS200,  // ASX 200 Index
  SYMBOL_INDEX_NI225,   // Nikkei 225 Index
  SYMBOL_INDEX_UK100,   // FTSE 100 Index
  SYMBOL_INDEX_SP500m,  // Standard & Poor's 500
  SYMBOL_INDEX_SPN35,   // IBEX 35 Index
  SYMBOL_INDEX_STOX50,  // EUR STOXX 50
};

/**
 * Enumeration for the precious metal symbols.
 */
enum ENUM_SYMBOL_LIST_METALS {
  SYMBOL_METAL_XAGEUR,  // Silver vs Euro (XAGEUR)
  SYMBOL_METAL_XAGUSD,  // Silver vs US Dollar (XAGUSD)
  SYMBOL_METAL_XAUAUD,  // Gold vs Australian Dollar (XAUAUD)
  SYMBOL_METAL_XAUEUR,  // Gold vs Euro (XAUEUR)
  SYMBOL_METAL_XAUUSD,  // Gold vs US Dollar (XAUUSD)
  SYMBOL_METAL_XPDUSD,  // Palladium vs US Dollar (XPDUSD)
  SYMBOL_METAL_XPTUSD,  // Platinum vs US Dollar (XPTUSD)
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SymbolInfo.enum.symbols.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef SYMBOLINFO_MQH
#define SYMBOLINFO_MQH

// Forward declaration.
class SymbolInfo;

// Includes symbol defines, enums and structs.






// Includes.




/**
 * Class to provide symbol information.
 */
class SymbolInfo : public Object {
 protected:
  // Variables.
  string symbol;  // Current symbol pair.
  Log logger;
  MqlTick last_tick;          // Stores the latest prices of the symbol.
  ARRAY(MqlTick, tick_data);  // Stores saved ticks.
  SymbolInfoEntry s_entry;    // Symbol entry.
  SymbolInfoProp sprops;      // Symbol properties.
  double pip_size;            // Value of pip size.
  uint symbol_digits;         // Count of digits after decimal point in the symbol price.
  // uint pts_per_pip;          // Number of points per pip.
  double volume_precision;

 public:
  /**
   * Implements class constructor with a parameter.
   */
  SymbolInfo(string _symbol = NULL) : symbol(_symbol), pip_size(GetPipSize()), symbol_digits(GetDigits()) {
    Select();
    last_tick = GetTick();
    // @todo: Test symbol with SymbolExists(_symbol)
    sprops.pip_digits = SymbolInfoStatic::GetPipDigits(_symbol);
    sprops.pip_value = SymbolInfoStatic::GetPipValue(_symbol);
    sprops.pts_per_pip = SymbolInfoStatic::GetPointsPerPip(_symbol);
    sprops.vol_digits = SymbolInfoStatic::GetVolumeDigits(_symbol);
    if (StringLen(symbol) == 0) {
      symbol = _Symbol;
    }
  }

  ~SymbolInfo() {}

  /**
   * Selects current symbol in the Market Watch window.
   *
   * @docs
   * - https://docs.mql4.com/marketinformation/symbolselect
   * - https://www.mql5.com/en/docs/MarketInformation/SymbolSelect
   */
  bool Select() { return (bool)SymbolInfoInteger(symbol, SYMBOL_SELECT); }

  /* Getters */

  /**
   * Get current symbol pair used by the class.
   */
  string GetSymbol() { return symbol; }

  /**
   * Updates and gets the latest tick prices.
   *
   * @docs MQL4 https://docs.mql4.com/constants/structures/mqltick
   * @docs MQL5 https://www.mql5.com/en/docs/constants/structures/mqltick
   */
  MqlTick GetTick() {
    if (!SymbolInfoTick(symbol, last_tick)) {
      GetLogger().Error("Cannot return current prices!", __FUNCTION__);
    }
    return last_tick;
  }

  /**
   * Gets the last tick prices (without updating).
   */
  MqlTick GetLastTick() { return last_tick; }

  /**
   * The latest known seller's price (ask price) for the current symbol.
   * The RefreshRates() function must be used to update.
   *
   * @see http://docs.mql4.com/predefined/ask
   */
  double Ask() {
    return GetTick().ask;

    // @todo?
    // Overriding Ask variable to become a function call.
    // #ifdef __MQL5__ #define Ask Market::Ask() #endif // @fixme
  }

  /**
   * Updates and gets the latest ask price (best buy offer).
   */
  double GetAsk() { return SymbolInfoStatic::GetAsk(symbol); }

  /**
   * Gets the last ask price (without updating).
   */
  double GetLastAsk() { return last_tick.ask; }

  /**
   * The latest known buyer's price (offer price, bid price) of the current symbol.
   * The RefreshRates() function must be used to update.
   *
   * @see http://docs.mql4.com/predefined/bid
   */
  double Bid() {
    return GetTick().bid;

    // @todo?
    // Overriding Bid variable to become a function call.
    // #ifdef __MQL5__ #define Bid Market::Bid() #endif // @fixme
  }

  /**
   * Updates and gets the latest bid price (best sell offer).
   */
  double GetBid() { return SymbolInfoStatic::GetBid(symbol); }

  /**
   * Gets the last bid price (without updating).
   */
  double GetLastBid() { return last_tick.bid; }

  /**
   * Get the last volume for the current last price.
   *
   * @see: https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  ulong GetVolume() { return SymbolInfoStatic::GetTick(symbol).volume; }

  /**
   * Gets the last volume for the current price (without updating).
   */
  ulong GetLastVolume() { return last_tick.volume; }

  /**
   * Get summary volume of current session deals.
   *
   * @see: https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  double GetSessionVolume() { return SymbolInfoStatic::GetSessionVolume(symbol); }

  /**
   * Time of the last quote
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_info_double
   */
  datetime GetQuoteTime() { return SymbolInfoStatic::GetQuoteTime(symbol); }

  /**
   * Get current open price depending on the operation type.
   *
   * @param:
   *   op_type int Order operation type of the order.
   * @return
   *   Current open price.
   */
  double GetOpenOffer(ENUM_ORDER_TYPE _cmd) { return SymbolInfoStatic::GetOpenOffer(symbol, _cmd); }

  /**
   * Get current close price depending on the operation type.
   *
   * @param:
   *   op_type int Order operation type of the order.
   * @return
   * Current close price.
   */
  double GetCloseOffer(ENUM_ORDER_TYPE _cmd) { return SymbolInfoStatic::GetCloseOffer(symbol, _cmd); }

  /**
   * Get pip precision.
   */
  unsigned int GetPipDigits() { return sprops.pip_digits; }

  /**
   * Get pip value.
   */
  double GetPipValue() { return sprops.pip_value; }

  /**
   * Get number of points per pip.
   *
   */
  unsigned int GetPointsPerPip() {
    return sprops.pts_per_pip;
  }

  /**
   * Get the point size in the quote currency.
   *
   * The smallest digit of price quote.
   * A change of 1 in the least significant digit of the price.
   * You may also use Point predefined variable for the current symbol.
   */
  double GetPointSize() { return SymbolInfoStatic::GetPointSize(symbol); }

  /**
   * Return a pip size.
   *
   * In most cases, a pip is equal to 1/100 (.01%) of the quote currency.
   */
  double GetPipSize() { return SymbolInfoStatic::GetPipSize(symbol); }

  /**
   * Get current spread in points.
   *
   * @param
   *   symbol string (optional)
   *   Currency pair symbol.
   *
   * @return
   *   Return symbol trade spread level in points.
   */
  unsigned int GetSpreadInPts() { return GetSpread(); }

  /**
   * Get current spread in float.
   */
  double GetSpreadInPips() { return (GetAsk() - GetBid()) * pow(10, GetPipDigits()); }

  /**
   * Get current spread in percent.
   */
  double GetSpreadInPct() { return SymbolInfoStatic::GetSpreadInPct(symbol); }

  /**
   * Get a tick size in the price value.
   *
   * It is the smallest movement in the price quoted by the broker,
   * which could be several points.
   * In currencies it is equivalent to point size, in metals they are not.
   */
  float GetTickSize() { return (float)SymbolInfoStatic::GetTickSize(symbol); }

  /**
   * Get a tick size in points.
   *
   * It is a minimal price change in points.
   * In currencies it is equivalent to point size, in metals they are not.
   */
  double GetTradeTickSize() { return SymbolInfoStatic::GetTradeTickSize(symbol); }

  /**
   * Get a tick value in the deposit currency.
   *
   * @return
   * Returns the number of base currency units for one pip of movement.
   */
  double GetTickValue() { return SymbolInfoStatic::GetTickValue(symbol); }

  /**
   * Get a calculated tick price for a profitable position.
   *
   * @return
   * Returns the number of base currency units for one pip of movement.
   */
  double GetTickValueProfit() { return SymbolInfoStatic::GetTickValueProfit(symbol); }

  /**
   * Get a calculated tick price for a losing position.
   *
   * @return
   * Returns the number of base currency units for one pip of movement.
   */
  double GetTickValueLoss() { return SymbolInfoStatic::GetTickValueLoss(symbol); }

  /**
   * Get count of digits after decimal point for the symbol price.
   *
   * For the current symbol, it is stored in the predefined variable Digits.
   *
   */
  uint GetDigits() { return SymbolInfoStatic::GetDigits(symbol); }

  /**
   * Get current spread in points.
   *
   * @param
   *   symbol string (optional)
   *   Currency pair symbol.
   *
   * @return
   *   Return symbol trade spread level in points.
   */
  uint GetSpread() { return SymbolInfoStatic::GetSpread(symbol); }

  /**
   * Get real spread based on the ask and bid price (in points).
   */
  unsigned int GetRealSpread() { return SymbolInfoStatic::GetRealSpread(symbol); }

  /**
   * Minimal indention in points from the current close price to place Stop orders.
   *
   * This is due that at placing of a pending order, the open price cannot be too close to the market.
   * The minimal distance of the pending price from the current market one in points can be obtained
   * using the MarketInfo() function with the MODE_STOPLEVEL parameter.
   * Related error messages:
   *   Error 130 (ERR_INVALID_STOPS) happens In case of false open price of a pending order.
   *   Error 145 (ERR_TRADE_MODIFY_DENIED) happens when modification of order was too close to market.
   *
   * @param
   *   symbol string (optional)
   *   Currency pair symbol.
   *
   * @return
   *   Returns the minimal permissible distance value in points for StopLoss/TakeProfit.
   *   A zero value means either absence of any restrictions on the minimal distance.
   *
   * @see: https://book.mql4.com/appendix/limits
   */
  long GetTradeStopsLevel() { return SymbolInfoStatic::SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL); }

  /**
   * Get a contract lot size in the base currency.
   */
  double GetTradeContractSize() {
    return SymbolInfoStatic::SymbolInfoDouble(
        symbol,
        SYMBOL_TRADE_CONTRACT_SIZE);  // Same as: MarketInfo(symbol, MODE_LOTSIZE);
  }

  /**
   * Get a volume precision.
   */
  unsigned int GetVolumeDigits() { return sprops.vol_digits; }

  /**
   * Minimum permitted amount of a lot/volume for a deal.
   */
  double GetVolumeMin() { return SymbolInfoStatic::GetVolumeMin(symbol); }

  /**
   * Maximum permitted amount of a lot/volume for a deal.
   */
  double GetVolumeMax() { return SymbolInfoStatic::GetVolumeMax(symbol); }

  /**
   * Get a lot/volume step for a deal.
   *
   * Minimal volume change step for deal execution
   */
  double GetVolumeStep() { return SymbolInfoStatic::GetVolumeStep(symbol); }

  /**
   * Order freeze level in points.
   *
   * Freeze level is a value that determines the price band,
   * within which the order is considered as 'frozen' (prohibited to change).
   *
   * If the execution price lies within the range defined by the freeze level,
   * the order cannot be modified, cancelled or closed.
   * The possibility of deleting a pending order is regulated by the FreezeLevel.
   *
   * @see: https://book.mql4.com/appendix/limits
   */
  uint GetFreezeLevel() { return SymbolInfoStatic::GetFreezeLevel(symbol); }

  /**
   * Gets flags of allowed order filling modes.
   *
   *  The flags can be combined by the operation of the logical OR (e.g. SYMBOL_FILLING_FOK|SYMBOL_FILLING_IOC).
   *
   * @docs
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   */
  ENUM_ORDER_TYPE_FILLING GetFillingMode() { return SymbolInfoStatic::GetFillingMode(symbol); }

  /**
   * Buy order swap value
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  double GetSwapLong() { return SymbolInfoStatic::GetSwapLong(symbol); }

  /**
   * Sell order swap value
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  double GetSwapShort() { return SymbolInfoStatic::GetSwapShort(symbol); }

  /**
   * Swap calculation model.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants
   */
  ENUM_SYMBOL_SWAP_MODE GetSwapMode() { return SymbolInfoStatic::GetSwapMode(symbol); }

  /**
   * Returns initial margin (a security deposit) requirements for opening an order.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_info_double
   */
  double GetMarginInit(ENUM_ORDER_TYPE _cmd = ORDER_TYPE_BUY) { return SymbolInfoStatic::GetMarginInit(symbol, _cmd); }

  /**
   * Return the maintenance margin to maintain open orders.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_info_double
   */
  double GetMarginMaintenance(ENUM_ORDER_TYPE _cmd = ORDER_TYPE_BUY) {
    return SymbolInfoStatic::GetMarginMaintenance(symbol, _cmd);
  }

  /**
   * Gets symbol entry.
   */
  SymbolInfoEntry GetEntry(MqlTick &_tick) {
    SymbolInfoEntry _entry(_tick, symbol);
    return _entry;
  }
  SymbolInfoEntry GetEntry() {
    MqlTick _tick = GetTick();
    return GetEntry(_tick);
  }
  SymbolInfoEntry GetEntryLast() {
    MqlTick _tick = GetLastTick();
    return GetEntry(_tick);
  }

  /* Tick storage */

  /**
   * Appends a new tick to an array.
   */
  bool SaveTick(MqlTick &_tick) {
    static int _index = 0;
    if (_index++ >= ArraySize(tick_data) - 1) {
      if (ArrayResize(tick_data, _index + 100, 1000) < 0) {
        GetLogger().Error(StringFormat("Cannot resize array (size: %d)!", _index), __FUNCTION__);
        return false;
      }
    }
    tick_data[_index] = GetTick();
    return true;
  }

  /**
   * Empties the tick array.
   */
  bool ResetTicks() { return ArrayResize(tick_data, 0, 100) != -1; }

  /* Setters */

  /**
   * Overrides the last tick.
   */
  void SetTick(MqlTick &_tick) { last_tick = _tick; }

  /* Printer methods */

  /**
   * Returns symbol information in string format.
   */
  const string ToString() {
    return StringFormat(
        string("Symbol: %s, Last Ask/Bid: %g/%g, Last Price/Session Volume: %d/%g, Point size: %g, Pip size: %g, ") +
            "Tick size: %g (%g pts), Tick value: %g (%g/%g), " + "Digits: %d, Spread: %d pts, Trade stops level: %d, " +
            "Trade contract size: %g, Min lot: %g, Max lot: %g, Lot step: %g, " +
            "Freeze level: %d, Swap (long/short/mode): %g/%g/%d, Margin initial (maintenance): %g (%g)",
        GetSymbol(), GetLastAsk(), GetLastBid(), GetLastVolume(), GetSessionVolume(), GetPointSize(), GetPipSize(),
        GetTickSize(), GetTradeTickSize(), GetTickValue(), GetTickValueProfit(), GetTickValueLoss(), GetDigits(),
        GetSpread(), GetTradeStopsLevel(), GetTradeContractSize(), GetVolumeMin(), GetVolumeMax(), GetVolumeStep(),
        GetFreezeLevel(), GetSwapLong(), GetSwapShort(), GetSwapMode(), GetMarginInit(), GetMarginMaintenance());
  }

  /**
   * Returns symbol information in CSV format.
   */
  const string ToCSV(bool _header = false) {
    return !_header
               ? StringFormat(string("%s,%g,%g,%d,%g,%g,%g,") + "%g,%g,%g,%g,%g," + "%d,%d,%d," + "%g,%g,%g,%g," +
                                  "%d,%g,%g,%d,%g,%g",
                              GetSymbol(), GetLastAsk(), GetLastBid(), GetLastVolume(), GetSessionVolume(),
                              GetPointSize(), GetPipSize(), GetTickSize(), GetTradeTickSize(), GetTickValue(),
                              GetTickValueProfit(), GetTickValueLoss(), GetDigits(), GetSpread(), GetTradeStopsLevel(),
                              GetTradeContractSize(), GetVolumeMin(), GetVolumeMax(), GetVolumeStep(), GetFreezeLevel(),
                              GetSwapLong(), GetSwapShort(), GetSwapMode(), GetMarginInit(), GetMarginMaintenance())
               : string("Symbol,Last Ask,Last Bid,Last Volume,Session Volume,Point Size,Pip Size,") +
                     "Tick Size,Tick Size (pts),Tick Value,Tick Value Profit,Tick Value Loss," +
                     "Digits,Spread (pts),Trade Stops," + "Trade Contract Size,Min Lot,Max Lot,Lot Step," +
                     "Freeze level, Swap Long, Swap Short, Swap Mode, Margin Init";
  }

  /* Serializers */

  /**
   * Returns serialized representation of the object instance.
   */
  const SerializerNodeType Serialize(Serializer &_s) {
    _s.Pass(THIS_REF, "symbol", symbol);
    _s.PassStruct(THIS_REF, "symbol-entry", s_entry);
    return SerializerNodeObject;
  }

  /* Class handlers */

  /**
   * Returns Log handler.
   */
  Log *GetLogger() { return GetPointer(logger); }
};
#endif  // SYMBOLINFO_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SymbolInfo.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Implements class for managing orders.
 */

// Prevents processing this includes file for the second time.
#ifndef ORDER_MQH
#define ORDER_MQH

// Includes.















/* Defines for backward compatibility. */

// Index in the order pool.
#ifndef SELECT_BY_POS
#define SELECT_BY_POS 0
#endif

// Index by the order ticket.
#ifndef SELECT_BY_TICKET
#define SELECT_BY_TICKET 1
#endif

#ifndef ORDER_EXTERNAL_ID
// Order identifier in an external trading system (on the Exchange).
// Note: Required for backward compatibility in MQL4.
// @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties#enum_order_property_string
#define ORDER_EXTERNAL_ID ((ENUM_ORDER_PROPERTY_STRING)20)
#endif

#ifndef ORDER_REASON
// The reason or source for placing an order.
// Note: Required for backward compatibility in MQL4.
// @see: https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
#define ORDER_REASON ((ENUM_ORDER_PROPERTY_INTEGER)23)
#endif

#ifndef __MQLBUILD__
// Defines.
// Mode constants.
// @see: https://docs.mql4.com/trading/orderselect
#define MODE_TRADES 0
#define MODE_HISTORY 1
#endif

/**
 * Class to provide methods to deal with the order.
 *
 * @see
 * - https://www.mql5.com/en/docs/trading/ordergetinteger
 * - https://www.mql5.com/en/articles/211
 */
class Order : public SymbolInfo {
 public:
  /*
   * Default enumerations:
   *
   * Trade operation:
   *   0: OP_BUY (Buy operation)
   *   1: OP_SELL (Sell operation)
   *   2: OP_BUYLIMIT (Buy limit pending order)
   *   3: OP_SELLLIMIT (Sell limit pending order)
   *   4: OP_BUYSTOP (Buy stop pending order)
   *   5: OP_SELLSTOP (Sell stop pending order)
   */

 protected:
  // Struct variables.
  Log ologger;                        // Logger.
  MqlTradeRequest orequest;           // Trade Request Structure.
  MqlTradeCheckResult oresult_check;  // Results of a Trade Request Check.
  MqlTradeResult oresult;             // Trade Request Result.
  OrderParams oparams;
  OrderData odata;

#ifndef __MQL4__
  // Used for order selection in MQL5 & C++.
  static unsigned long selected_ticket_id;
  static ENUM_ORDER_SELECT_TYPE selected_ticket_type;
#endif

 public:
  /**
   * Class constructors.
   */
  Order() {}
  Order(long _ticket_no) {
    odata.Set(ORDER_PROP_TICKET, _ticket_no);
    Refresh(true);
  }
  Order(const MqlTradeRequest &_request, bool _send = true) {
    orequest = _request;
    if (_send) {
      if (!IsDummy()) {
        OrderSend();
      } else {
        OrderSendDummy();
      }
    }
  }
  Order(const MqlTradeRequest &_request, const OrderParams &_oparams, bool _send = true) {
    orequest = _request;
    oparams = _oparams;
    if (_send) {
      if (!IsDummy()) {
        OrderSend();
      } else {
        OrderSendDummy();
      }
    }
  }

  /**
   * Loads order based on OrderData struct.
   */
  Order(OrderData &_odata) : odata(_odata) {}

  /**
   * Class copy constructors.
   */
  Order(const Order &_order) {
    oparams = _order.oparams;
    odata = _order.odata;
    orequest = _order.orequest;
    oresult_check = _order.oresult_check;
    oresult = _order.oresult;
  }

  /**
   * Class deconstructor.
   */
  ~Order() {}

  Log *GetLogger() { return GetPointer(ologger); }

  /* Getters */

  /**
   * Gets an order property custom value.
   */
  template <typename T>
  T Get(ENUM_ORDER_PARAM _param) {
    return oparams.Get<T>(_param);
  }

  /**
   * Gets an order property custom value.
   */
  template <typename T>
  T Get(ENUM_ORDER_PROPERTY_CUSTOM _prop) {
    return odata.Get<T>(_prop);
  }

  /**
   * Gets an order property double value.
   */
  template <typename T>
  T Get(ENUM_ORDER_PROPERTY_DOUBLE _prop) {
    return odata.Get<T>(_prop);
  }

  /**
   * Gets an order property integer value.
   */
  template <typename T>
  T Get(ENUM_ORDER_PROPERTY_INTEGER _prop) {
    return odata.Get<T>(_prop);
  }

  /**
   * Gets an order property string value.
   */
  string Get(ENUM_ORDER_PROPERTY_STRING _prop) { return odata.Get(_prop); }

  /**
   * Get order's params.
   */
  // OrderParams GetParams() const { return oparams; }

  /**
   * Get order's data.
   */
  // OrderData GetData() const { return odata; }

  /**
   * Get order's request.
   */
  MqlTradeRequest GetRequest() { return orequest; }

  /**
   * Get order's result.
   */
  MqlTradeResult GetResult() { return oresult; }

  /**
   * Get order's check result.
   */
  MqlTradeCheckResult GetResultCheck() { return oresult_check; }

  /* Setters */

  /**
   * Sets an order property custom value.
   */
  template <typename T>
  void Set(ENUM_ORDER_PARAM _param, T _value, int _index1 = 0, int _index2 = 0) {
    oparams.Set<T>(_param, _value, _index1, _index2);
  }

  /**
   * Sets an order property custom value.
   */
  template <typename T>
  void Set(ENUM_ORDER_PROPERTY_CUSTOM _prop, T _value) {
    odata.Set<T>(_prop, _value);
  }

  /**
   * Sets an order property double value.
   */
  void Set(ENUM_ORDER_PROPERTY_DOUBLE _prop, double _value) { odata.Set(_prop, _value); }

  /**
   * Sets an order property integer value.
   */
  void Set(ENUM_ORDER_PROPERTY_INTEGER _prop, long _value) { odata.Set(_prop, _value); }

  /**
   * Sets an order property string value.
   */
  void Set(ENUM_ORDER_PROPERTY_STRING _prop, string _value) { odata.Set(_prop, _value); }

  /* State checkers */

  /**
   * Is order is open.
   */
  bool IsClosed(bool _refresh = false) {
    if (odata.Get<long>(ORDER_PROP_TIME_CLOSED) == 0) {
      if (_refresh || ShouldRefresh()) {
        if (Order::TryOrderSelect(odata.Get<long>(ORDER_PROP_TICKET), SELECT_BY_TICKET, MODE_HISTORY)) {
          odata.Set<long>(ORDER_PROP_TIME_CLOSED, Order::OrderCloseTime());
          odata.Set<int>(ORDER_PROP_REASON_CLOSE, ORDER_REASON_CLOSED_UNKNOWN);
        }
      }
    }
    return odata.Get<long>(ORDER_PROP_TIME_CLOSED) > 0;
  }

  /**
   * Is order closed.
   */
  bool IsOpen(bool _refresh = false) { return !IsClosed(_refresh); }

  /**
   * Should order be closed.
   *
   * @return
   *   Returns true when order should be closed, otherwise false.
   */
  bool ShouldCloseOrder() {
    bool _result = false;
    if (oparams.HasCloseCondition()) {
      int _num = oparams.Get<int>(ORDER_PARAM_COND_CLOSE_NUM);
      for (int _ci = 0; _ci < _num; _ci++) {
        ENUM_ORDER_CONDITION _cond = oparams.Get<ENUM_ORDER_CONDITION>(ORDER_PARAM_COND_CLOSE, _ci);
        DataParamEntry _cond_args[1];
        _cond_args[0] = oparams.Get<long>(ORDER_PARAM_COND_CLOSE_ARG_VALUE, _ci);
        _result |= _result || Order::CheckCondition(_cond, _cond_args);
      }
    }
    return _result;
  }

  /**
   * Should order be refreshed.
   *
   * @return
   *   Returns true when order values can be refreshed, otherwise false.
   */
  bool ShouldRefresh() {
    return odata.Get<long>(ORDER_PROP_TIME_LAST_REFRESH) + oparams.Get<ushort>(ORDER_PARAM_REFRESH_FREQ) <=
           TimeCurrent();
  }

  /**
   * Should order be updated.
   *
   * @return
   *   Returns true when order stops can be updated, otherwise false.
   */
  bool ShouldUpdate() {
    return odata.Get<long>(ORDER_PROP_TIME_LAST_UPDATE) + oparams.Get<ushort>(ORDER_PARAM_UPDATE_FREQ) <= TimeCurrent();
  }

  /* State checking */

  /**
   * Check whether order is selected and it is same as the class one.
   */
  bool IsSelected() {
    unsigned long ticket_id = Order::OrderTicket();
    bool is_selected;

    if (IsDummy()) {
      is_selected = true;
    } else {
      is_selected = (odata.Get<long>(ORDER_PROP_TICKET) > 0 && ticket_id == odata.Get<long>(ORDER_PROP_TICKET));
    }

    ResetLastError();
    return is_selected;
  }
  bool IsSelectedDummy() {
    // @todo
    return false;
  }
  bool IsDummy() { return oparams.dummy; }

  /* Trade methods */

  /**
   * Gets allowed order filling mode.
   *
   * @docs
   * - https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode
   */
  static ENUM_ORDER_TYPE_FILLING GetOrderFilling(const string _symbol) {
    // Default policy is used only for market orders (Buy and Sell), limit and stop limit orders
    // and only for the symbols with Market or Exchange execution.
    // In case of partial filling a market or limit order with remaining volume is not canceled but processed further.
    ENUM_ORDER_TYPE_FILLING _result = ORDER_FILLING_RETURN;
    const long _filling_mode = SymbolInfoStatic::GetFillingMode(_symbol);
    if ((_filling_mode & SYMBOL_FILLING_IOC) == SYMBOL_FILLING_IOC) {
      // Execute a deal with the volume maximally available in the market within that indicated in the order.
      // In case the order cannot be filled completely, the available volume of the order will be filled, and the
      // remaining volume will be canceled. The possibility of using IOC orders is determined at the trade server.
      _result = ORDER_FILLING_IOC;
    } else if ((_filling_mode & SYMBOL_FILLING_FOK) == SYMBOL_FILLING_FOK) {
      // A deal can be executed only with the specified volume.
      // In MT4, orders are usually on an FOK basis in that you get a complete fill or nothing.
      // If the necessary amount of a financial instrument is currently unavailable in the market, the order will not be
      // executed. The required volume can be filled using several offers available on the market at the moment.
      _result = ORDER_FILLING_FOK;
    }
    return (_result);
  }

  /**
   * Gets order's filling mode.
   */
  ENUM_ORDER_TYPE_FILLING GetOrderFilling() {
    Refresh(ORDER_TYPE_FILLING);
    return odata.Get<ENUM_ORDER_TYPE_FILLING>(ORDER_TYPE_FILLING);
  }

  /**
   * Get allowed order filling modes.
   */
  static ENUM_ORDER_TYPE_FILLING GetOrderFilling(const string _symbol, const long _type) {
    const ENUM_SYMBOL_TRADE_EXECUTION _exe_mode =
        (ENUM_SYMBOL_TRADE_EXECUTION)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_TRADE_EXEMODE);
    const long _filling_mode = SymbolInfoStatic::GetFillingMode(_symbol);
    return ((_filling_mode == 0 || (_type >= ORDER_FILLING_RETURN) || ((_filling_mode & (_type + 1)) != _type + 1))
                ? (((_exe_mode == SYMBOL_TRADE_EXECUTION_EXCHANGE) || (_exe_mode == SYMBOL_TRADE_EXECUTION_INSTANT))
                       ? ORDER_FILLING_RETURN
                       : ((_filling_mode == SYMBOL_FILLING_IOC) ? ORDER_FILLING_IOC : ORDER_FILLING_FOK))
                : (ENUM_ORDER_TYPE_FILLING)_type);
  }

  /* MT ORDER METHODS */

  /* Order getters */

  /**
   * Returns close price of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordercloseprice
   */
  static double OrderClosePrice() {
#ifdef __MQL4__
    return ::OrderClosePrice();
#else  // __MQL5__
    // @docs https://www.mql5.com/en/docs/trading/HistoryDealGetDouble
    double _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        const ENUM_DEAL_ENTRY _deal_entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(_deal_ticket, DEAL_ENTRY);
        if (_deal_entry == DEAL_ENTRY_OUT || _deal_entry == DEAL_ENTRY_OUT_BY) {
          _result = HistoryDealGetDouble(_deal_ticket, DEAL_PRICE);
          break;
        }
      }
    }
    return _result;
#endif
  }
  double GetClosePrice() { return IsClosed() ? odata.Get<double>(ORDER_PROP_PRICE_CLOSE) : 0; }

  /**
   * Returns open time of the currently selected order/position.
   *
   * @see
   * - http://docs.mql4.com/trading/orderopentime
   * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
   */
  static datetime OrderOpenTime() {
#ifdef __MQL4__
    // http://docs.mql4.com/trading/orderopentime
    return (datetime)Order::OrderGetInteger(ORDER_TIME_SETUP);
#else
    long _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        const ENUM_DEAL_ENTRY _deal_entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(_deal_ticket, DEAL_ENTRY);
        if (_deal_entry == DEAL_ENTRY_IN) {
          _result = HistoryDealGetInteger(_deal_ticket, DEAL_TIME);
          break;
        }
      }
    }
    return (datetime)_result;
#endif
  }
  datetime GetOpenTime() {
    if (odata.Get<datetime>(ORDER_PROP_TIME_OPENED) == 0) {
      OrderSelect();
      odata.Set<datetime>(ORDER_PROP_TIME_OPENED, Order::OrderOpenTime());
    }
    return odata.Get<datetime>(ORDER_PROP_TIME_OPENED);
  }

  /*
   * Returns close time of the currently selected order/position.
   *
   * @see:
   * - https://docs.mql4.com/trading/orderclosetime
   */
  static datetime OrderCloseTime() {
#ifdef __MQL4__
    return ::OrderCloseTime();
#else  // __MQL5__
    // @docs https://www.mql5.com/en/docs/trading/historydealgetinteger
    long _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        const ENUM_DEAL_ENTRY _deal_entry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(_deal_ticket, DEAL_ENTRY);
        if (_deal_entry == DEAL_ENTRY_OUT || _deal_entry == DEAL_ENTRY_OUT_BY) {
          _result = HistoryDealGetInteger(_deal_ticket, DEAL_TIME);
          break;
        }
      }
    }
    return (datetime)_result;
#endif
  }
  datetime GetCloseTime() { return IsClosed() ? odata.Get<datetime>(ORDER_PROP_TIME_CLOSED) : 0; }

  /**
   * Returns comment of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordercomment
   * - https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
   */
  static string OrderComment() { return Order::OrderGetString(ORDER_COMMENT); }

  /**
   * Returns calculated commission of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordercommission
   */
  static double OrderCommission() {
#ifdef __MQL4__
    // https://docs.mql4.com/trading/ordercommission
    return ::OrderCommission();
#else  // __MQL5__
    double _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        _result += _deal_ticket > 0 ? HistoryDealGetDouble(_deal_ticket, DEAL_COMMISSION) : 0;
      }
    }
    return _result;
#endif
  }
  /* @todo
  double GetCommission() {
    if (IsSelected()) {
      odata.Set<double>(ORDER_PROP_COMMISSION, Order::OrderCommission());
    }
    return odata.Get<double>(ORDER_PROP_COMMISSION);
  }
  */

  /**
   * Returns total fees of the currently selected order.
   *
   */
  static double OrderTotalFees() {
#ifdef __MQL4__
    return Order::OrderCommission() - Order::OrderSwap();
#else  // __MQL5__
    double _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        if (_deal_ticket > 0) {
          _result += HistoryDealGetDouble(_deal_ticket, DEAL_COMMISSION);
          _result += HistoryDealGetDouble(_deal_ticket, DEAL_FEE);
          _result += HistoryDealGetDouble(_deal_ticket, DEAL_SWAP);
        }
      }
    }
    return _result;
#endif
  }
  double GetTotalFees() {
    if (!IsClosed()) {
      OrderSelect();
      odata.Set<double>(ORDER_PROP_TOTAL_FEES, Order::OrderTotalFees());
    }
    return odata.Get<double>(ORDER_PROP_TOTAL_FEES);
  }

  /**
   * Selects an order/position for further processing.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderselect
   * - https://www.mql5.com/en/docs/trading/positiongetticket
   */
  static datetime OrderExpiration() { return (datetime)Order::OrderGetInteger(ORDER_TIME_EXPIRATION); }
  datetime GetExpiration() { return (datetime)odata.Get<datetime>(ORDER_TIME_EXPIRATION); }

  /**
   * Returns amount of lots/volume of the selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderlots
   * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
   */
  static double OrderLots() {
#ifdef __MQL4__
    return ::OrderLots();
#else
    // @fixme: It returns 0.
    // @fixme: Error 69639.
    return Order::OrderGetDouble(ORDER_VOLUME_CURRENT);
#endif
  }
  double GetVolume() { return orequest.volume; }

  /**
   * Returns an identifying (magic) number of the currently selected order.
   *
   * @see
   * - http://docs.mql4.com/trading/ordermagicnumber
   * - https://www.mql5.com/en/docs/trading/ordergetinteger
   */
  static long OrderMagicNumber() { return Order::OrderGetInteger(ORDER_MAGIC); }
  unsigned long GetMagicNumber() { return orequest.magic; }

  /**
   * Returns open price of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderopenprice
   * - https://www.mql5.com/en/docs/trading/ordergetdouble
   */
  static double OrderOpenPrice() { return Order::OrderGetDouble(ORDER_PRICE_OPEN); }
  double GetOpenPrice() { return odata.Get<double>(ORDER_PRICE_OPEN); }

  /**
   * Returns profit of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderprofit
   *
   * @return
   * Returns the order's net profit value (without swaps or commissions).
   */
  static double OrderProfit() {
#ifdef __MQL4__
    // Returns the net profit value (without swaps or commissions) for the selected order.
    // For open orders, it is the current unrealized profit.
    // For closed orders, it is the fixed profit.
    return ::OrderProfit();
#else
    double _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        _result += _deal_ticket > 0 ? HistoryDealGetDouble(_deal_ticket, DEAL_PROFIT) : 0;
      }
    }
    return _result;
#endif
  }

  /**
   * Returns stop loss value of the currently selected order.
   *
   * @docs
   * - http://docs.mql4.com/trading/orderstoploss
   * - https://www.mql5.com/en/docs/trading/ordergetdouble
   */
  static double OrderStopLoss() { return Order::OrderGetDouble(ORDER_SL); }
  double GetStopLoss(bool _refresh = true) {
    if (ShouldRefresh() || _refresh) {
      Refresh(ORDER_SL);
    }
    return odata.Get<double>(ORDER_SL);
  }

  /**
   * Returns take profit value of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordertakeprofit
   * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
   *
   * @return
   * Returns take profit value of the currently selected order/position.
   */
  static double OrderTakeProfit() { return Order::OrderGetDouble(ORDER_TP); }
  double GetTakeProfit(bool _refresh = true) {
    if (ShouldRefresh() || _refresh) {
      Refresh(ORDER_TP);
    }
    return odata.Get<double>(ORDER_TP);
  }

  /**
   * Returns SL/TP value of the currently selected order.
   */
  static double GetOrderSLTP(ENUM_ORDER_PROPERTY_DOUBLE _mode) {
    switch (_mode) {
      case ORDER_SL:
        return OrderStopLoss();
      case ORDER_TP:
        return OrderTakeProfit();
    }
    return NULL;
  }

  /**
   * Returns cumulative swap of the currently selected order.
   */
  static double OrderSwap() {
#ifdef __MQL4__
    // https://docs.mql4.com/trading/orderswap
    return ::OrderSwap();
#else
    double _result = 0;
    unsigned long _ticket = Order::OrderTicket();
    if (HistorySelectByPosition(_ticket)) {
      for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        // https://www.mql5.com/en/docs/trading/historydealgetticket
        const unsigned long _deal_ticket = HistoryDealGetTicket(i);
        _result += _deal_ticket > 0 ? HistoryDealGetDouble(_deal_ticket, DEAL_SWAP) : 0;
      }
    }
    return _result;
#endif
  }
  /* @fixme
  double GetSwap() {
    if (!IsClosed()) {
      OrderSelect();
      odata.swap = Order::OrderSwap();
    }
    return odata.swap;
  }
  */

  /**
   * Returns symbol name of the currently selected order/position.
   *
   * @docs
   * - https://docs.mql4.com/trading/ordersymbol
   * - https://www.mql5.com/en/docs/trading/positiongetstring
   */
  static string OrderSymbol() {
#ifdef __MQL4__
    return ::OrderSymbol();
#else
    return Order::OrderGetString(ORDER_SYMBOL);
#endif
  }
  string GetSymbol() { return orequest.symbol; }

  /**
   * Returns a ticket number of the currently selected order.
   *
   * It is a unique number assigned to each order.
   *
   * @see https://docs.mql4.com/trading/orderticket
   * @see https://www.mql5.com/en/docs/trading/ordergetticket
   */
  static unsigned long OrderTicket() {
#ifdef __MQL4__
    return ::OrderTicket();
#else
    return selected_ticket_id;
#endif
  }
  // unsigned long GetTicket() const { return odata.Get<unsigned long>(ORDER_PROP_TICKET); }

  /**
   * Returns order operation type of the currently selected order/position.
   *
   * @docs
   * - http://docs.mql4.com/trading/ordertype
   * - https://www.mql5.com/en/docs/constants/tradingconstants/positionproperties
   *
   * @return
   * Order/position operation type.
   */
  static ENUM_ORDER_TYPE OrderType() { return (ENUM_ORDER_TYPE)Order::OrderGetInteger(ORDER_TYPE); }
  ENUM_ORDER_TYPE GetType() {
    if (odata.Get<int>(ORDER_TYPE) < 0 && Select()) {
      Refresh(ORDER_TYPE);
    }
    return odata.Get<ENUM_ORDER_TYPE>(ORDER_TYPE);
  }

  /**
   * Returns order operation type of the currently selected order.
   *
   * Limit and stop orders are on a GTC basis unless an expiry time is set explicitly.
   *
   * @see https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
   */
  static ENUM_ORDER_TYPE_TIME OrderTypeTime() { return (ENUM_ORDER_TYPE_TIME)Order::OrderGetInteger(ORDER_TYPE_TIME); }

  /**
   * Returns the order position based on the ticket.
   *
   * It is set to an order as soon as it is executed.
   * Each executed order results in a deal that opens or modifies an already existing position.
   * The identifier of exactly this position is set to the executed order at this moment.
   */
  static unsigned long OrderGetPositionID() {
#ifdef __MQL4__
    unsigned long _ticket = ::OrderTicket();
    for (int _pos = 0; _pos < OrdersTotal(); _pos++) {
      if (::OrderSelect(_pos, SELECT_BY_POS, MODE_TRADES) && ::OrderTicket() == _ticket) {
        return _pos;
      }
    }
    return -1;
#else  // __MQL5__
    return Order::OrderGetInteger(ORDER_POSITION_ID);
#endif
  }
  /* @todo
  unsigned long GetPositionID() {
#ifdef ORDER_POSITION_ID
    if (odata.position_id == 0) {
      OrderSelect();
      Refresh(ORDER_POSITION_ID);
    }
#endif
    return odata.Get<unsigned long>(ORDER_POSITION_ID);
  }
  */

  /**
   * Returns the ticket of an opposite position.
   *
   * Used when a position is closed by an opposite one open for the same symbol in the opposite direction.
   *
   * @see:
   * - https://www.mql5.com/en/docs/constants/structures/mqltraderequest
   * - https://www.mql5.com/en/docs/constants/tradingconstants/orderproperties
   */
  static unsigned long OrderGetPositionBy() {
#ifdef __MQL4__
    // @todo
    /*
    for (int _pos = 0; _pos < OrdersTotal(); _pos++) {
      if (OrderSelect(_pos, SELECT_BY_POS, MODE_TRADES) && OrderTicket() == _ticket) {
        return _pos;
      }
    }
    */
    return -1;
#else  // __MQL5__
    return Order::OrderGetInteger(ORDER_POSITION_BY_ID);
#endif
  }
  /* @todo
  unsigned long GetOrderPositionBy() {
#ifdef ORDER_POSITION_BY_ID
    if (odata.position_by_id == 0) {
      OrderSelect();
      Refresh(ORDER_POSITION_BY_ID);
    }
#endif
    return odata.Get<unsigned long>(ORDER_POSITION_BY_ID);
  }
  */

  /**
   * Returns the ticket of a position in the list of open positions.
   *
   * @see https://www.mql5.com/en/docs/trading/positiongetticket
   */
  unsigned long PositionGetTicket(int _index) {
#ifdef __MQL4__
    if (::OrderSelect(_index, SELECT_BY_POS, MODE_TRADES)) {
      return ::OrderTicket();
    }
    return -1;
#else  // __MQL5__
    return ::PositionGetTicket(_index);
#endif
  }

  /* Order manipulation */

  /**
   * Closes opened order.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderclose
   * - https://www.mql5.com/en/docs/constants/tradingconstants/enum_trade_request_actions
   *
   * @return
   *   Returns true if successful, otherwise false.
   *   To get details about error, call the GetLastError() function.
   */
  static bool OrderClose(unsigned long _ticket,  // Unique number of the order ticket.
                         double _lots,           // Number of lots.
                         double _price,          // Closing price.
                         int _deviation,  // Maximal possible deviation/slippage from the requested price (in points).
                         color _arrow_color = CLR_NONE  // Color of the closing arrow on the chart.
  ) {
#ifdef __MQL4__
    return ::OrderClose((int)_ticket, _lots, _price, _deviation, _arrow_color);
#else
    if (::OrderSelect(_ticket) || ::PositionSelectByTicket(_ticket) || ::HistoryOrderSelect(_ticket)) {
      MqlTradeRequest _request = {(ENUM_TRADE_REQUEST_ACTIONS)0};
      MqlTradeCheckResult _result_check = {0};
      MqlTradeResult _result = {0};
      _request.action = TRADE_ACTION_DEAL;
      _request.position = ::PositionGetInteger(POSITION_TICKET);
      _request.symbol = ::PositionGetString(POSITION_SYMBOL);
      _request.type = NegateOrderType((ENUM_POSITION_TYPE)::PositionGetInteger(POSITION_TYPE));
      _request.type_filling = GetOrderFilling(_request.symbol);
      _request.volume = _lots;
      _request.price = _price;
      _request.deviation = _deviation;
      return Order::OrderSend(_request, _result, _result_check, _arrow_color);
    }
    return false;
#endif
  }
  bool OrderClose(ENUM_ORDER_REASON_CLOSE _reason = ORDER_REASON_CLOSED_UNKNOWN, string _comment = "") {
    odata.ResetError();
    odata.Set(ORDER_PROP_REASON_CLOSE, _reason);
    if (!OrderSelect()) {
      if (!OrderSelectHistory()) {
        odata.ProcessLastError();
        return false;
      }
    }
    MqlTradeRequest _request = {(ENUM_TRADE_REQUEST_ACTIONS)0};
    MqlTradeResult _result = {0};
    _request.action = TRADE_ACTION_DEAL;
    _request.comment = _comment != "" ? _comment : odata.GetReasonCloseText();
    _request.deviation = orequest.deviation;
    _request.symbol = orequest.symbol;
    _request.type = NegateOrderType(orequest.type);
    _request.type_filling = GetOrderFilling(orequest.symbol);
    _request.position = odata.Get<ulong>(ORDER_PROP_TICKET);
    _request.price = SymbolInfo::GetCloseOffer(orequest.type);
    _request.volume = orequest.volume;
    Order::OrderSend(_request, oresult, oresult_check);
    if (oresult.retcode == TRADE_RETCODE_DONE) {
      // For now, sets the current time.
      odata.Set(ORDER_PROP_TIME_CLOSED, DateTimeStatic::TimeTradeServer());
      // For now, sets using the actual close price.
      odata.Set(ORDER_PROP_PRICE_CLOSE, SymbolInfo::GetCloseOffer(odata.Get<ENUM_ORDER_TYPE>(ORDER_TYPE)));
      odata.Set(ORDER_PROP_LAST_ERROR, ERR_NO_ERROR);
      odata.Set(ORDER_PROP_REASON_CLOSE, _reason);
      Refresh();
      return true;
    } else {
      odata.Set<unsigned int>(ORDER_PROP_LAST_ERROR, oresult.retcode);
      if (OrderSelect()) {
        if (IsClosed()) {
          Refresh();
        }
      }
    }
    return false;
  }

  /**
   * Closes dummy order.
   *
   * @return
   *   Returns true if successful.
   */
  bool OrderCloseDummy(ENUM_ORDER_REASON_CLOSE _reason = ORDER_REASON_CLOSED_UNKNOWN, string _comment = "") {
    odata.Set(ORDER_PROP_LAST_ERROR, ERR_NO_ERROR);
    odata.Set(ORDER_PROP_PRICE_CLOSE, SymbolInfoStatic::GetCloseOffer(symbol, odata.Get<ENUM_ORDER_TYPE>(ORDER_TYPE)));
    odata.Set(ORDER_PROP_REASON_CLOSE, _reason);
    odata.Set(ORDER_PROP_TIME_CLOSED, DateTimeStatic::TimeTradeServer());
    Refresh();
    return true;
  }

  /**
   * Closes a position by an opposite one.
   */
  static bool OrderCloseBy(long _ticket, long _opposite, color _color) {
#ifdef __MQL4__
    return ::OrderCloseBy((int)_ticket, (int)_opposite, _color);
#else
    if (::OrderSelect(_ticket) || ::PositionSelectByTicket(_ticket) || ::HistoryOrderSelect(_ticket)) {
      MqlTradeRequest _request = {(ENUM_TRADE_REQUEST_ACTIONS)0};
      MqlTradeCheckResult _result_check = {0};
      MqlTradeResult _result = {0};
      _request.action = TRADE_ACTION_CLOSE_BY;
      _request.position = ::PositionGetInteger(POSITION_TICKET);
      _request.position_by = _opposite;
      _request.symbol = ::PositionGetString(POSITION_SYMBOL);
      _request.type = NegateOrderType((ENUM_POSITION_TYPE)::PositionGetInteger(POSITION_TYPE));
      _request.volume = ::PositionGetDouble(POSITION_VOLUME);
      return Order::OrderSend(_request, _result);
    }
    return false;
#endif
  }

  /**
   * Closes a position by an opposite one.
   */
  bool OrderCloseBy(long _opposite, color _color) {
    bool _result = OrderCloseBy(odata.Get<long>(ORDER_PROP_TICKET), _opposite, _color);
    if (_result) {
      odata.Set(ORDER_PROP_REASON_CLOSE, ORDER_REASON_CLOSED_BY_OPPOSITE);
    }
    return _result;
  }

  /**
   * Deletes previously opened pending order.
   *
   * @see: https://docs.mql4.com/trading/orderdelete
   */
  static bool OrderDelete(unsigned long _ticket, color _color = NULL) {
#ifdef __MQL4__
    return ::OrderDelete((int)_ticket, _color);
#else
    if (::OrderSelect(_ticket)) {
      MqlTradeRequest _request = {(ENUM_TRADE_REQUEST_ACTIONS)0};
      MqlTradeResult _result = {0};
      _request.action = TRADE_ACTION_REMOVE;
      _request.order = _ticket;
      return Order::OrderSend(_request, _result);
    }
    return false;
#endif
  }
  bool OrderDelete(ENUM_ORDER_REASON_CLOSE _reason = ORDER_REASON_CLOSED_UNKNOWN) {
    bool _result = Order::OrderDelete(odata.Get<long>(ORDER_PROP_TICKET));
    if (_result) {
      odata.Set(ORDER_PROP_REASON_CLOSE, _reason);
    }
    return _result;
  }

  /**
   * Modification of characteristics of the previously opened or pending orders.
   *
   * @see http://docs.mql4.com/trading/ordermodify
   */
  static bool OrderModify(unsigned long _ticket,        // Ticket of the position.
                          double _price,                // Price.
                          double _stoploss,             // Stop loss.
                          double _takeprofit,           // Take profit.
                          datetime _expiration,         // Expiration.
                          color _arrow_color = clrNONE  // Color of order.
  ) {
#ifdef __MQL4__
    return ::OrderModify((unsigned int)_ticket, _price, _stoploss, _takeprofit, _expiration, _arrow_color);
#else
    if (!::PositionSelectByTicket(_ticket)) {
      return false;
    }
    MqlTradeRequest _request = {(ENUM_TRADE_REQUEST_ACTIONS)0};
    MqlTradeCheckResult _result_check = {0};
    MqlTradeResult _result = {0};
    _request.action = TRADE_ACTION_SLTP;
    //_request.type = PositionTypeToOrderType();
    _request.position = _ticket;  // Position ticket.
    _request.symbol = ::PositionGetString(POSITION_SYMBOL);
    _request.sl = _stoploss;
    _request.tp = _takeprofit;
    _request.expiration = _expiration;
    return Order::OrderSend(_request, _result, _result_check);
#endif
  }
  bool OrderModify(double _sl, double _tp, double _price = 0, datetime _expiration = 0) {
    if (odata.Get<long>(ORDER_PROP_TIME_CLOSED) > 0) {
      // Ignore change for already closed orders.
      return false;
    } else if (_sl == odata.Get<double>(ORDER_SL) && _tp == odata.Get<double>(ORDER_TP) &&
               _expiration == odata.Get<datetime>(ORDER_TIME_EXPIRATION)) {
      // Ignore change for the same values.
      return false;
    }
    bool _result = Order::OrderModify(odata.Get<long>(ORDER_PROP_TICKET), _price, _sl, _tp, _expiration);
    long _last_error = GetLastError();
    if (_result && OrderSelect()) {
      // Updating expected values.
      odata.Set(ORDER_SL, _sl);
      odata.Set(ORDER_TP, _tp);
      // @todo: Add if condition.
      // Refresh(ORDER_PRICE_OPEN); // For pending order only.
      // Refresh(ORDER_TIME_EXPIRATION); // For pending order only.
      ResetLastError();
    } else {
      if (OrderSelect()) {
        if (IsClosed()) {
          Refresh();
        } else {
          GetLogger().Warning(StringFormat("Failed to modify order (#%d/p:%g/sl:%g/tp:%g/code:%d).",
                                           odata.Get<long>(ORDER_PROP_TICKET), _price, _sl, _tp, _last_error),
                              __FUNCTION_LINE__, ToCSV());
          Refresh(ORDER_SL);
          Refresh(ORDER_TP);
          // TODO: Refresh(ORDER_PRI)
          // @todo: Add if condition.
          // Refresh(ORDER_PRICE_OPEN); // For pending order only.
          // Refresh(ORDER_TIME_EXPIRATION); // For pending order only.
        }
        ResetLastError();
        _result = false;
      } else {
        ologger.Error(StringFormat("Error: %d! Failed to modify non-existing order (#%d/p:%g/sl:%g/tp:%g).",
                                   _last_error, odata.Get<long>(ORDER_PROP_TICKET), _price, _sl, _tp),
                      __FUNCTION_LINE__, ToCSV());
      }
    }
    return _result;
  }

  /**
   * Executes trade operations by sending the request to a trade server.
   *
   * The main function used to open market or place a pending order.
   *
   * @see
   * - http://docs.mql4.com/trading/ordersend
   * - https://www.mql5.com/en/docs/trading/ordersend
   *
   * @return
   * Returns number of the ticket assigned to the order by the trade server
   * or -1 if it fails.
   */
  static long OrderSend(string _symbol,               // Symbol.
                        int _cmd,                     // Operation.
                        double _volume,               // Volume.
                        double _price,                // Price.
                        unsigned long _deviation,     // Deviation.
                        double _stoploss,             // Stop loss.
                        double _takeprofit,           // Take profit.
                        string _comment = NULL,       // Comment.
                        unsigned long _magic = 0,     // Magic number.
                        datetime _expiration = 0,     // Pending order expiration.
                        color _arrow_color = clrNONE  // Color.
  ) {
#ifdef __MQL4__
    return ::OrderSend(_symbol, _cmd, _volume, _price, (int)_deviation, _stoploss, _takeprofit, _comment,
                       (unsigned int)_magic, _expiration, _arrow_color);
#else
    // @docs
    // - https://www.mql5.com/en/articles/211
    // - https://www.mql5.com/en/docs/constants/tradingconstants/enum_trade_request_actions
    MqlTradeRequest _request = {(ENUM_TRADE_REQUEST_ACTIONS)0};  // Query structure.
    MqlTradeResult _result = {0};                                // Structure of the result.
    _request.action = TRADE_ACTION_DEAL;
    _request.symbol = _symbol;
    _request.volume = _volume;
    _request.price = _price;
    _request.sl = _stoploss;
    _request.tp = _takeprofit;
    _request.deviation = _deviation;
    _request.comment = _comment;
    _request.magic = _magic;
    _request.expiration = _expiration;
    _request.type = (ENUM_ORDER_TYPE)_cmd;
    _request.type_filling = _request.type_filling ? _request.type_filling : GetOrderFilling(_symbol);
    if (!Order::OrderSend(_request, _result)) {
      return -1;
    }
    return (long)_result.order;
#endif
  }
  static bool OrderSend(const MqlTradeRequest &_request, MqlTradeResult &_result, MqlTradeCheckResult &_result_check,
                        color _color = clrNONE) {
#ifdef __MQL4__
    // Convert Trade Request Structure to function parameters.
    _result.retcode = TRADE_RETCODE_ERROR;
    if (_request.position > 0) {
      if (_request.action == TRADE_ACTION_SLTP) {
        if (Order::OrderModify(_request.position, _request.price, _request.sl, _request.tp, _request.expiration,
                               _color)) {
          // @see: https://www.mql5.com/en/docs/constants/structures/mqltraderesult
          _result.ask = SymbolInfoStatic::GetAsk(_request.symbol);  // The current market Bid price (requote price).
          _result.bid = SymbolInfoStatic::GetBid(_request.symbol);  // The current market Ask price (requote price).
          _result.order = _request.position;                        // Order ticket.
          _result.price = _request.price;                           // Deal price, confirmed by broker.
          _result.volume = _request.volume;                         // Deal volume, confirmed by broker (@fixme?).
          _result.retcode = TRADE_RETCODE_DONE;
          //_result.comment = TODO; // The broker comment to operation (by default it is filled by description of trade
          // server return code).
        }
      } else if (_request.action == TRADE_ACTION_CLOSE_BY) {
        if (Order::OrderCloseBy(_request.position, _request.position_by, _color)) {
          // @see: https://www.mql5.com/en/docs/constants/structures/mqltraderesult
          _result.ask = SymbolInfoStatic::GetAsk(_request.symbol);  // The current market Bid price (requote price).
          _result.bid = SymbolInfoStatic::GetBid(_request.symbol);  // The current market Ask price (requote price).
          _result.retcode = TRADE_RETCODE_DONE;
        }
      } else if (_request.action == TRADE_ACTION_DEAL || _request.action == TRADE_ACTION_REMOVE) {
        // @see: https://docs.mql4.com/trading/orderclose
        if (Order::OrderClose(_request.position, _request.volume, _request.price, (int)_request.deviation, _color)) {
          // @see: https://www.mql5.com/en/docs/constants/structures/mqltraderesult
          _result.ask = SymbolInfoStatic::GetAsk(_request.symbol);  // The current market Bid price (requote price).
          _result.bid = SymbolInfoStatic::GetBid(_request.symbol);  // The current market Ask price (requote price).
          _result.order = _request.position;                        // Order ticket.
          _result.price = _request.price;                           // Deal price, confirmed by broker.
          _result.volume = _request.volume;                         // Deal volume, confirmed by broker (@fixme?).
          _result.retcode = TRADE_RETCODE_DONE;
          //_result.comment = TODO; // The broker comment to operation (by default it is filled by description of trade
          // server return code).
        }
      }
    } else if (_request.action == TRADE_ACTION_DEAL) {
      // @see: https://docs.mql4.com/trading/ordersend
      _result.order = Order::OrderSend(_request.symbol,      // Symbol.
                                       _request.type,        // Operation.
                                       _request.volume,      // Volume.
                                       _request.price,       // Price.
                                       _request.deviation,   // Deviation.
                                       _request.sl,          // Stop loss.
                                       _request.tp,          // Take profit.
                                       _request.comment,     // Comment.
                                       _request.magic,       // Magic number.
                                       _request.expiration,  // Pending order expiration.
                                       _color                // Color.

      );

      _result.retcode = _result.order > 0 ? TRADE_RETCODE_DONE : GetLastError();

      if (_request.order > 0) {
        // @see: https://www.mql5.com/en/docs/constants/structures/mqltraderesult
        _result.ask = SymbolInfoStatic::GetAsk(_request.symbol);  // The current market Bid price (requote price).
        _result.bid = SymbolInfoStatic::GetBid(_request.symbol);  // The current market Ask price (requote price).
        _result.price = _request.price;                           // Deal price, confirmed by broker.
        _result.volume = _request.volume;                         // Deal volume, confirmed by broker (@fixme?).
        //_result.comment = TODO; // The broker comment to operation (by default it is filled by description of trade
        // server return code).
      }
    }

    return _result.retcode == TRADE_RETCODE_DONE;
#else
    // The trade requests go through several stages of checking on a trade server.
    // First of all, it checks if all the required fields of the request parameter are filled out correctly.
    if (!OrderCheck(_request, _result_check)) {
      // If funds are not enough for the operation,
      // or parameters are filled out incorrectly, the function returns false.
      // In order to obtain information about the error, call the GetLastError() function.
      // @docs
      // - https://www.mql5.com/en/docs/trading/ordercheck
      // - https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes
      // - https://www.mql5.com/en/docs/constants/structures/mqltradecheckresult
#ifdef __debug__
      PrintFormat("%s: Error %d: %s", __FUNCTION_LINE__, _result_check.retcode, _result_check.comment);
#endif
      _result.retcode = _result_check.retcode;
      return false;
    }
    // In case of a successful basic check of structures (index checking) returns true.
    // However, this is not a sign of successful execution of a trade operation.
    // If there are no errors, the server accepts the order for further processing.
    // The check results are placed to the fields of the MqlTradeCheckResult structure.
    // For a more detailed description of the function execution result,
    // analyze the fields of the result structure.
    // In order to obtain information about the error, call the GetLastError() function.
    // --
    // @docs
    // - https://www.mql5.com/en/docs/trading/ordersend
    // - https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes
    // --
    // Sends trade requests to a server.
    return ::OrderSend(_request, _result);
    // The function execution result is placed to structure MqlTradeResult,
    // whose retcode field contains the trade server return code.
    // In order to obtain information about the error, call the GetLastError() function.
#endif
  }
  static bool OrderSend(const MqlTradeRequest &_request, MqlTradeResult &_result) {
    MqlTradeCheckResult _result_check = {0};
    return Order::OrderSend(_request, _result, _result_check);
  }
  long OrderSend() {
    long _result = -1;
    odata.ResetError();
#ifdef __MQL4__
    _result = Order::OrderSend(orequest.symbol,      // Symbol.
                               orequest.type,        // Operation.
                               orequest.volume,      // Volume.
                               orequest.price,       // Price.
                               orequest.deviation,   // Deviation (in pts).
                               orequest.sl,          // Stop loss.
                               orequest.tp,          // Take profit.
                               orequest.comment,     // Comment.
                               orequest.magic,       // Magic number.
                               orequest.expiration,  // Pending order expiration.
                               oparams.color_arrow   // Color.
    );
    oresult.retcode = _result == -1 ? TRADE_RETCODE_ERROR : TRADE_RETCODE_DONE;
#else
    orequest.type_filling = orequest.type_filling ? orequest.type_filling : GetOrderFilling(orequest.symbol);
    // The trade requests go through several stages of checking on a trade server.
    // First of all, it checks if all the required fields of the request parameter are filled out correctly.
    if (OrderCheck(orequest, oresult_check)) {
      // If there are no errors, the server accepts the order for further processing.
      // The check results are placed to the fields of the MqlTradeCheckResult structure.
      // For a more detailed description of the function execution result,
      // analyze the fields of the result structure.
      // After trade request is accepted, send it to a server.
      if (::OrderSend(orequest, oresult)) {
        // In case of a successful basic check of structures (index checking) returns true.
        // However, this is not a sign of successful execution of a trade operation.
        // @see: https://www.mql5.com/en/docs/trading/ordersend
        // In order to obtain information about the error, call the GetLastError() function.
        odata.Set<long>(ORDER_PROP_TICKET, oresult.order);
        _result = (long)oresult.order;
      } else {
        // The function execution result is placed to structure MqlTradeResult,
        // whose retcode field contains the trade server return code.
        // @see: https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes
        // In order to obtain information about the error, call the GetLastError() function.
        odata.Set<unsigned int>(ORDER_PROP_LAST_ERROR, oresult.retcode);
        _result = -1;
      }
    } else {
      // If funds are not enough for the operation,
      // or parameters are filled out incorrectly, the function returns false.
      // In order to obtain information about the error, call the GetLastError() function.
      // @see: https://www.mql5.com/en/docs/trading/ordercheck
      odata.Set<unsigned int>(ORDER_PROP_LAST_ERROR, oresult_check.retcode);
      _result = -1;
    }
#endif
    if (_result >= 0) {
#ifdef __MQL4__
      // In MQL4 there is no difference in selecting various types of tickets.
      oresult.deal = _result;
      oresult.order = _result;
#endif
      // Update order data values.
      odata.Set(ORDER_COMMENT, orequest.comment);
      odata.Set(ORDER_MAGIC, orequest.magic);
      odata.Set(ORDER_PRICE_OPEN, orequest.price);
      odata.Set(ORDER_PROP_TICKET, _result);
      odata.Set(ORDER_SL, orequest.sl);
      odata.Set(ORDER_SYMBOL, orequest.symbol);
      odata.Set(ORDER_TIME_EXPIRATION, orequest.expiration);
      odata.Set(ORDER_TP, orequest.tp);
      odata.Set(ORDER_TYPE, orequest.type);
      odata.Set(ORDER_VOLUME_CURRENT, orequest.volume);
      odata.Set(ORDER_VOLUME_INITIAL, orequest.volume);
      Refresh(true);
      ResetLastError();
    } else {
      odata.Set<unsigned int>(ORDER_PROP_LAST_ERROR,
                              fmax(odata.Get<unsigned int>(ORDER_PROP_LAST_ERROR), GetLastError()));
    }
    return _result;
  }

  /**
   * Executes dummy trade operation by sending the fake request.
   *
   * @return
   * Returns number of the fake ticket assigned to the order.
   */
  long OrderSendDummy() {
    static int _dummy_order_id = 0;
    odata.ResetError();
    orequest.type_filling = orequest.type_filling ? orequest.type_filling : GetOrderFilling(orequest.symbol);
    if (!OrderCheckDummy(orequest, oresult_check)) {
      // If funds are not enough for the operation,
      // or parameters are filled out incorrectly, the function returns false.
      odata.Set<unsigned int>(ORDER_PROP_LAST_ERROR, oresult_check.retcode);
      return -1;
    }
    // Process dummy request.
    oresult.ask = SymbolInfoStatic::GetAsk(orequest.symbol);  // The current market Bid price (requote price).
    oresult.bid = SymbolInfoStatic::GetBid(orequest.symbol);  // The current market Ask price (requote price).
    oresult.order = orequest.position;                        // Order ticket.
    oresult.price = orequest.price;                           // Deal price, confirmed by broker.
    oresult.volume = orequest.volume;                         // Deal volume, confirmed by broker (@fixme?).
    oresult.retcode = TRADE_RETCODE_DONE;                     // Mark trade operation as done.
    oresult.comment = orequest.comment;                       // Order comment.
    oresult.order = ++_dummy_order_id;                        // Assign sequential order id. Starts from 1.
    odata.Set<long>(ORDER_PROP_TICKET, oresult.order);
    RefreshDummy();
    odata.Set<unsigned int>(ORDER_PROP_LAST_ERROR, oresult.retcode);

    // @todo Register order in a static dictionary order_id -> order for further select.

    return (long)oresult.order;
  }

  /**
   * Checks if there are enough money to execute a required trade operation.
   *
   * @param
   *   _request MqlTradeRequest
   *     Pointer to the structure of the MqlTradeRequest type, which describes the required trade action.
   *   _result_check MqlTradeCheckResult
   *     Pointer to the structure of the MqlTradeCheckResult type, to which the check result will be placed.
   *
   * @return
   *   If funds are not enough for the operation, or parameters are filled out incorrectly, the function returns false.
   *   In case of a successful basic check of structures (check of pointers), it returns true.
   *
   * @docs https://www.mql5.com/en/docs/trading/ordercheck
   */
  static bool OrderCheck(const MqlTradeRequest &_request, MqlTradeCheckResult &_result_check) {
#ifdef __MQL4__
    return OrderCheckDummy(_request, _result_check);
#else
    return ::OrderCheck(_request, _result_check);
#endif
  }
  static bool OrderCheckDummy(const MqlTradeRequest &_request, MqlTradeCheckResult &_result_check) {
    _result_check.retcode = ERR_NO_ERROR;
    if (_request.volume <= 0) {
      _result_check.retcode = TRADE_RETCODE_INVALID_VOLUME;
    }
    if (_request.price <= 0) {
      _result_check.retcode = TRADE_RETCODE_INVALID_PRICE;
    }
    // @todo
    // - https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes
    // _result_check.balance = Account::Balance() - something; // Balance value that will be after the execution of the
    // trade operation. equity;              // Equity value that will be after the execution of the trade operation.
    // profit;              // Value of the floating profit that will be after the execution of the trade operation.
    // margin;              // Margin required for the trade operation.
    // margin_free;         // Free margin that will be left after the execution of the trade operation.
    // margin_level;        // Margin level that will be set after the execution of the trade operation.
    // comment;             // Comment to the reply code (description of the error).
    if (_result_check.retcode != ERR_NO_ERROR) {
      // SetUserError(???);
    }
    return _result_check.retcode == ERR_NO_ERROR;
  }

  /* Order selection methods */

  /**
   * Select an order to work with.
   *
   * The function selects an order for further processing.
   *
   *  @see http://docs.mql4.com/trading/orderselect
   */
  static bool OrderSelect(unsigned long _index, int select, int pool = MODE_TRADES) {
    ResetLastError();
#ifdef __MQL4__
    return ::OrderSelect((int)_index, select, pool);
#else
    bool _result = false;
    if (select == SELECT_BY_POS) {
      if (pool == MODE_TRADES) {
        if (::PositionGetTicket((int)_index)) {
          selected_ticket_type = ORDER_SELECT_TYPE_POSITION;
        } else if (::OrderGetTicket((int)_index)) {
          selected_ticket_type = ORDER_SELECT_TYPE_ACTIVE;
        } else {
          selected_ticket_type = ORDER_SELECT_TYPE_NONE;
          selected_ticket_id = 0;
        }
      } else if (pool == MODE_HISTORY) {
        // The HistoryOrderGetTicket(_index) return the ticket of the historical order, by its _index from the cache of
        // the historical orders (not from the terminal base!). The obtained ticket can be used in the
        // HistoryOrderSelect(ticket) function, which clears the cache and re-fill it with only one order, in the
        // case of success. Recall that the value, returned from HistoryOrdersTotal() depends on the number of orders
        // in the cache.
        unsigned long _ticket_id = HistoryOrderGetTicket((int)_index);
        if (_ticket_id != 0) {
          selected_ticket_type = ORDER_SELECT_TYPE_HISTORY;
        } else if (::HistoryOrderSelect(_ticket_id)) {
          selected_ticket_type = ORDER_SELECT_TYPE_HISTORY;
        } else {
          selected_ticket_type = ORDER_SELECT_TYPE_NONE;
          selected_ticket_id = 0;
        }

        selected_ticket_id = selected_ticket_type == ORDER_SELECT_TYPE_NONE ? 0 : _ticket_id;
      }
    } else if (select == SELECT_BY_TICKET) {
      ResetLastError();
      if (::OrderSelect(_index) && GetLastError() == ERR_SUCCESS) {
        selected_ticket_type = ORDER_SELECT_TYPE_ACTIVE;
      } else {
        ResetLastError();
        if (::PositionSelectByTicket(_index) && GetLastError() == ERR_SUCCESS) {
          selected_ticket_type = ORDER_SELECT_TYPE_POSITION;
        } else {
          ResetLastError();
          if (::HistoryOrderSelect(_index) && GetLastError() == ERR_SUCCESS) {
            selected_ticket_type = ORDER_SELECT_TYPE_HISTORY;
          } else {
            ResetLastError();
            if (::HistoryDealSelect(_index) && GetLastError() == ERR_SUCCESS) {
              selected_ticket_type = ORDER_SELECT_TYPE_DEAL;
            } else {
              selected_ticket_type = ORDER_SELECT_TYPE_NONE;
              selected_ticket_id = 0;
            }
          }
        }
      }

      selected_ticket_id = selected_ticket_type == ORDER_SELECT_TYPE_NONE ? 0 : _index;
    } else {
#ifdef __debug__
      PrintFormat("%s: Possible values for 'select' parameters are: SELECT_BY_POS or SELECT_BY_HISTORY.",
                  __FUNCTION_LINE__);
#endif
    }
    _result = selected_ticket_type != ORDER_SELECT_TYPE_NONE;

    if (_result) {
      ResetLastError();
    }
    return _result;
#endif
  }

  /**
   * Tries to select an order to work with.
   *
   * The function selects an order for further processing.

   * Same as OrderSelect(), it will just perform ResetLastError().
   *
   * @see http://docs.mql4.com/trading/orderselect
   */
  static bool TryOrderSelect(unsigned long _index, int select, int pool = MODE_TRADES) {
    bool result = OrderSelect(_index, select, pool);
    ResetLastError();
    return result;
  }

  static bool OrderSelectByTicket(unsigned long _ticket) {
    return Order::OrderSelect(_ticket, SELECT_BY_TICKET, MODE_TRADES) ||
           Order::OrderSelect(_ticket, SELECT_BY_TICKET, MODE_HISTORY);
  }

  static bool TryOrderSelectByTicket(unsigned long _ticket) {
    return Order::TryOrderSelect(_ticket, SELECT_BY_TICKET, MODE_TRADES) ||
           Order::TryOrderSelect(_ticket, SELECT_BY_TICKET, MODE_HISTORY);
  }

  bool OrderSelect() { return !IsSelected() ? Order::OrderSelectByTicket(odata.Get<long>(ORDER_PROP_TICKET)) : true; }
  bool TryOrderSelect() {
    return !IsSelected() ? Order::TryOrderSelectByTicket(odata.Get<long>(ORDER_PROP_TICKET)) : true;
  }
  bool OrderSelectHistory() { return OrderSelect(odata.Get<long>(ORDER_PROP_TICKET), MODE_HISTORY); }

  /* Setters */

  /**
   * Refresh values of the current order.
   */
  bool Refresh(bool _refresh = false) {
    bool _result = true;
    if (!_refresh && !ShouldRefresh()) {
      return _result;
    }
    odata.ResetError();
    if (!OrderSelect()) {
      SetUserError(ERR_USER_ITEM_NOT_FOUND);
      return false;
    }
    odata.ResetError();

    // IsOpen() could end up with "Position not found" error.
    ResetLastError();

    // Checks if order is updated for the first time.
    bool _is_init = odata.Get<double>(ORDER_PRICE_OPEN) == 0 || odata.Get<long>(ORDER_TIME_SETUP) == 0;

    // Update integer values.
    if (_is_init) {
      // Some values needs to be updated only once.
      // Update integer values.
      _result &= Refresh(ORDER_MAGIC);
      _result &= Refresh(ORDER_TIME_SETUP);
      _result &= Refresh(ORDER_TIME_SETUP_MSC);
      _result &= Refresh(ORDER_TYPE);
#ifdef ORDER_POSITION_ID
      _result &= Refresh(ORDER_POSITION_ID);
#endif
#ifdef ORDER_POSITION_BY_ID
      _result &= Refresh(ORDER_POSITION_BY_ID);
#endif
      // Update double values.
      _result &= Refresh(ORDER_PRICE_OPEN);
      // Update string values.
      _result &= Refresh(ORDER_SYMBOL);
      _result &= Refresh(ORDER_COMMENT);
    } else {
      // Updates current close price.
      odata.Set<double>(ORDER_PROP_PRICE_CLOSE, Order::OrderClosePrice());
      // Update integer values.
      // _result &= Refresh(ORDER_TIME_EXPIRATION); // @fixme: Error 69539
      // _result &= Refresh(ORDER_STATE); // @fixme: Error 69539
      // _result &= Refresh(ORDER_TYPE_TIME); // @fixme: Error 69539
      // _result &= Refresh(ORDER_TYPE_FILLING); // @fixme: Error 69539
      // Update double values.
      // _result &= Refresh(ORDER_VOLUME_INITIAL); // @fixme: false
      // _result &= Refresh(ORDER_VOLUME_CURRENT); // @fixme: Error 69539
    }

    // Updates whether order is open or closed.
    if (odata.Get<long>(ORDER_PROP_TIME_CLOSED) == 0) {
      // Updates close time.
      odata.Set<long>(ORDER_PROP_TIME_CLOSED, Order::OrderCloseTime());
    }

    if (IsOpen()) {
      // Update values for open orders only.
      _result &= Refresh(ORDER_PRICE_CURRENT);
      _result &= Refresh(ORDER_SL);
      _result &= Refresh(ORDER_TP);
    }
    //} else if (IsPending())
    // _result &= Refresh(ORDER_PRICE_STOPLIMIT); // @fixme: Error 69539

    // Get last error.
    int _last_error = GetLastError();
    // TODO
    // odata.SetTicket(Order::GetTicket());
    // order.filling     = GetOrderFilling();          // Order execution type.
    // order.comment     = new String(OrderComment()); // Order comment.
    // order.position    = OrderGetPositionID();       // Position ticket.
    // order.position_by = OrderGetPositionBy();       // The ticket of an opposite position.

    // Process conditions.
    if (!_is_init) {
      ProcessConditions();
    }

    if (!_result || _last_error > ERR_NO_ERROR) {
      if (_last_error > ERR_NO_ERROR && _last_error != 4014) {  // @fixme: In MT4 (why 4014?).
        GetLogger().Warning(StringFormat("Update failed! Error: %d", _last_error), __FUNCTION_LINE__);
      }
      odata.ProcessLastError();
      ResetLastError();
    }
    odata.Set<long>(ORDER_PROP_TIME_LAST_REFRESH, TimeCurrent());
    return _result && _last_error == ERR_NO_ERROR;
  }

  /**
   * Update values of the current dummy order.
   */
  bool RefreshDummy() {
    bool _result = true;
    if (!ShouldRefresh()) {
      return _result;
    }
    odata.ResetError();
    if (!OrderSelect()) {
      return false;
    }
    // Process conditions.
    ProcessConditions();

    RefreshDummy(ORDER_SYMBOL);
    RefreshDummy(ORDER_PRICE_OPEN);
    RefreshDummy(ORDER_VOLUME_CURRENT);

    if (IsOpen() || true) {  // @fixit
      // Update values for open orders only.
      RefreshDummy(ORDER_SL);
      RefreshDummy(ORDER_TP);
      RefreshDummy(ORDER_PRICE_CURRENT);
    }

    odata.Set(ORDER_PROP_PROFIT, oresult.bid - oresult.ask);

    // @todo: More RefreshDummy(XXX);

    odata.ResetError();
    odata.Set<long>(ORDER_PROP_TIME_LAST_REFRESH, TimeCurrent());
    odata.ProcessLastError();
    return _result && GetLastError() == ERR_NO_ERROR;
  }

  /**
   * Update specific double value of the current order.
   */
  bool RefreshDummy(ENUM_ORDER_PROPERTY_DOUBLE _prop_id) {
    bool _result = false;
    double _value = WRONG_VALUE;
    ResetLastError();
    switch (_prop_id) {
      case ORDER_PRICE_CURRENT:
        odata.Set(_prop_id, SymbolInfoStatic::GetAsk(orequest.symbol));
        switch (odata.Get<ENUM_ORDER_TYPE>(ORDER_TYPE)) {
          case ORDER_TYPE_BUY:
          case ORDER_TYPE_BUY_LIMIT:
          case ORDER_TYPE_BUY_STOP:
#ifndef __MQL4__
          case ORDER_TYPE_BUY_STOP_LIMIT:
#endif
            if (odata.Get<double>(ORDER_TP) != 0.0 &&
                odata.Get<double>(ORDER_PRICE_CURRENT) > odata.Get<double>(ORDER_TP)) {
              // Take-Profit buy orders sent when the market price drops below their trigger price.
              OrderCloseDummy();
            } else if (odata.Get<double>(ORDER_SL) != 0.0 &&
                       odata.Get<double>(ORDER_PRICE_CURRENT) < odata.Get<double>(ORDER_SL)) {
              // Stop-loss buy orders are sent when the market price exceeds their trigger price.
              OrderCloseDummy();
            }
            break;
          case ORDER_TYPE_SELL:
          case ORDER_TYPE_SELL_LIMIT:
          case ORDER_TYPE_SELL_STOP:
#ifndef __MQL4__
          case ORDER_TYPE_SELL_STOP_LIMIT:
#endif
            if (odata.Get<double>(ORDER_TP) != 0.0 &&
                odata.Get<double>(ORDER_PRICE_CURRENT) > odata.Get<double>(ORDER_TP)) {
              // Take-profit sell orders are sent when the market price exceeds their trigger price.
              OrderCloseDummy();
            } else if (odata.Get<double>(ORDER_SL) != 0.0 &&
                       odata.Get<double>(ORDER_PRICE_CURRENT) < odata.Get<double>(ORDER_SL)) {
              // Stop-loss sell orders are sent when the market price drops below their trigger price.
              OrderCloseDummy();
            }
            break;
        }
        break;
      case ORDER_PRICE_OPEN:
        odata.Set(_prop_id, SymbolInfoStatic::GetBid(orequest.symbol));
        break;
      case ORDER_VOLUME_CURRENT:
        odata.Set(_prop_id, orequest.volume);
        break;
      case ORDER_SL:
        odata.Set(_prop_id, orequest.sl);
        break;
      case ORDER_TP:
        odata.Set(_prop_id, orequest.tp);
        break;
    }

    return true;
  }

  /**
   * Update specific integer value of the current order.
   */
  bool RefreshDummy(ENUM_ORDER_PROPERTY_INTEGER _prop_id) {
    bool _result = false;
    long _value = WRONG_VALUE;
    ResetLastError();
    switch (_prop_id) {
      case ORDER_MAGIC:
        odata.Set(_prop_id, orequest.magic);
        break;
    }

    return _result && GetLastError() == ERR_NO_ERROR;
  }

  /**
   * Update specific string value of the current order.
   */
  bool RefreshDummy(ENUM_ORDER_PROPERTY_STRING _prop_id) {
    switch (_prop_id) {
      case ORDER_COMMENT:
        odata.Set(_prop_id, orequest.comment);
        break;
      case ORDER_SYMBOL:
        odata.Set(_prop_id, orequest.symbol);
        break;
    }

    return true;
  }

  /**
   * Refresh specific double value of the current order.
   */
  bool Refresh(ENUM_ORDER_PROPERTY_DOUBLE _prop_id) {
    bool _result = false;
    double _value = WRONG_VALUE;
    ResetLastError();
    switch (_prop_id) {
      case ORDER_PRICE_CURRENT:
        _result = Order::OrderGetDouble(ORDER_PRICE_CURRENT, _value);
        break;
      case ORDER_PRICE_OPEN:
        _result = Order::OrderGetDouble(ORDER_PRICE_OPEN, _value);
        break;
      case ORDER_PRICE_STOPLIMIT:
        _result = Order::OrderGetDouble(ORDER_PRICE_STOPLIMIT, _value);
        break;
      case ORDER_SL:
        _result = Order::OrderGetDouble(ORDER_SL, _value);
        if (_result && _value == 0) {
          // @fixme
          _result = Order::OrderGetDouble(ORDER_SL, _value);
        }
        break;
      case ORDER_TP:
        _result = Order::OrderGetDouble(ORDER_TP, _value);
        break;
      case ORDER_VOLUME_CURRENT:
        _result = Order::OrderGetDouble(ORDER_VOLUME_CURRENT, _value);
        break;
      default:
        return false;
    }
    if (_result) {
      odata.Set(_prop_id, _value);
    } else {
      int _last_error = GetLastError();
      ologger.Error("Error refreshing order property!", __FUNCTION_LINE__,
                    StringFormat("Code: %d, Msg: %s", _last_error, Terminal::GetErrorText(_last_error)));
    }
    return _result && GetLastError() == ERR_NO_ERROR;
  }

  /**
   * Refresh specific integer value of the current order.
   */
  bool Refresh(ENUM_ORDER_PROPERTY_INTEGER _prop_id) {
    bool _result = false;
    long _value = WRONG_VALUE;
    ResetLastError();
    switch (_prop_id) {
      case ORDER_MAGIC:
        _result = Order::OrderGetInteger(ORDER_MAGIC, _value);
        break;
#ifdef ORDER_POSITION_ID
      case ORDER_POSITION_ID:
        _result = Order::OrderGetInteger(ORDER_POSITION_ID, _value);
        break;
#endif
#ifdef ORDER_POSITION_BY_ID
      case ORDER_POSITION_BY_ID:
        _result = Order::OrderGetInteger(ORDER_POSITION_BY_ID, _value);
        break;
#endif
      case (ENUM_ORDER_PROPERTY_INTEGER)ORDER_REASON:
        _result = Order::OrderGetInteger((ENUM_ORDER_PROPERTY_INTEGER)ORDER_REASON, _value);
        break;
      case ORDER_STATE:
        _result = Order::OrderGetInteger(ORDER_STATE, _value);
        break;
      case ORDER_TIME_EXPIRATION:
        _result = Order::OrderGetInteger(ORDER_TIME_EXPIRATION, _value);
        break;
      // @wtf: Same value as ORDER_TICKET?!
      case ORDER_TIME_DONE:
        _result = Order::OrderGetInteger(ORDER_TIME_DONE, _value);
        break;
      case ORDER_TIME_SETUP:  // Note: In MT5 it conflicts with ORDER_TICKET.
        // Order setup time.
        _result = Order::OrderGetInteger(ORDER_TIME_SETUP, _value);
        break;
      case ORDER_TIME_SETUP_MSC:
        // The time of placing an order for execution in milliseconds since 01.01.1970.
        _result = Order::OrderGetInteger(ORDER_TIME_SETUP_MSC, _value);
        break;
      case ORDER_TYPE:
        _result = Order::OrderGetInteger(ORDER_TYPE, _value);
        break;
      case ORDER_TYPE_FILLING:
        _result = Order::OrderGetInteger(ORDER_TYPE_FILLING, _value);
        break;
      case ORDER_TYPE_TIME:
        _result = Order::OrderGetInteger(ORDER_TYPE_TIME, _value);
        break;
      default:
        return false;
    }
    if (_result) {
      odata.Set(_prop_id, _value);
    } else {
      int _last_error = GetLastError();
      ologger.Error("Error updating order property!", __FUNCTION_LINE__,
                    StringFormat("Code: %d, Msg: %s", _last_error, Terminal::GetErrorText(_last_error)));
    }
    return _result && GetLastError() == ERR_NO_ERROR;
  }

  /**
   * Refresh specific string value of the current order.
   */
  bool Refresh(ENUM_ORDER_PROPERTY_STRING _prop_id) {
    bool _result = true;
    string _value = "";
    switch (_prop_id) {
      case ORDER_COMMENT:
        _value = Order::OrderGetString(ORDER_COMMENT);
        break;
#ifdef ORDER_EXTERNAL_ID
      case (ENUM_ORDER_PROPERTY_STRING)ORDER_EXTERNAL_ID:
        _value = Order::OrderGetString(ORDER_EXTERNAL_ID);
        break;
#endif
      case ORDER_SYMBOL:
        _value = Order::OrderGetString(ORDER_SYMBOL);
        break;
      default:
        _result = false;
        break;
    }
    if (_result && _value != "") {
      odata.Set(_prop_id, _value);
    } else {
      int _last_error = GetLastError();
      ologger.Error("Error updating order property!", __FUNCTION_LINE__,
                    StringFormat("Code: %d, Msg: %s", _last_error, Terminal::GetErrorText(_last_error)));
    }
    return true;
  }

  /* Conversion methods */

  /**
   * Returns OrderType as a text.
   *
   * @param
   *   op_type int Order operation type of the order.
   *   lc bool If true, return order operation in lower case.
   *
   * @return
   *   Return text representation of the order.
   */
  static string OrderTypeToString(ENUM_ORDER_TYPE _cmd, bool _lc = false) {
    _cmd = _cmd != NULL ? _cmd : OrderType();
    string _res = StringSubstr(EnumToString(_cmd), 11);
    StringReplace(_res, "_", " ");
    if (_lc) {
      StringToLower(_res);
    }
    return _res;
  }
  string OrderTypeToString(bool _lc = false) { return OrderTypeToString(orequest.type, _lc); }

  /* Custom order methods */

  /**
   * Returns profit of the currently selected order in pips.
   *
   * @return
   * Returns the profit value for the selected order in pips.
   */
  static double GetOrderProfitInPips() {
    return (OrderOpenPrice() - SymbolInfoStatic::GetCloseOffer(OrderSymbol(), OrderType())) /
           SymbolInfoStatic::GetPointSize(OrderSymbol());
  }

  /**
   * Return opposite trade of command operation.
   *
   * @param
   *   cmd int Trade command operation.
   */
  static ENUM_ORDER_TYPE NegateOrderType(ENUM_ORDER_TYPE _cmd) {
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        return ORDER_TYPE_SELL;
      case ORDER_TYPE_SELL:
        return ORDER_TYPE_BUY;
    }
    return WRONG_VALUE;
  }

  /**
   * Return opposite order type based on position type.
   *
   * @param
   *   _pos ENUM_POSITION_TYPE Direction of an open position.
   *
   * @return
   *   Returns opposite order type.
   */
  static ENUM_ORDER_TYPE NegateOrderType(ENUM_POSITION_TYPE _ptype) {
    switch (_ptype) {
      case POSITION_TYPE_BUY:
        return ORDER_TYPE_SELL;
      case POSITION_TYPE_SELL:
        return ORDER_TYPE_BUY;
    }
    return WRONG_VALUE;
  }

  /*
   * Returns order type direction value.
   *
   * @param
   *   _type ENUM_ORDER_TYPE Order operation type of the order.
   *   _mode ENUM_ORDER_TYPE_VALUE Order type value (SL or TP).
   *
   * @return
   *   Returns 1 for buy, -1 for sell orders, otherwise 0.
   */
  static short OrderDirection(ENUM_ORDER_TYPE _cmd, ENUM_ORDER_TYPE_VALUE _mode) {
    return OrderData::GetTypeValue(_cmd) * (_mode == ORDER_TYPE_SL ? -1 : 1);
  }

  /**
   * Get color of the order based on its type.
   */
  static color GetOrderColor(ENUM_ORDER_TYPE _cmd = (ENUM_ORDER_TYPE)-1, color cbuy = Blue, color csell = Red) {
    if (_cmd == NULL) _cmd = (ENUM_ORDER_TYPE)OrderType();
    return OrderData::GetTypeValue(_cmd) > 0 ? cbuy : csell;
  }

  /* Order property getters */

  /**
   * Returns the requested property of an order.
   *
   * @param ENUM_ORDER_PROPERTY_INTEGER property_id
   *   Identifier of a property.
   *
   * @return string
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   *
   * @docs
   * - https://www.mql5.com/en/docs/trading/ordergetinteger
   *
   */
  static long OrderGetInteger(ENUM_ORDER_PROPERTY_INTEGER property_id) {
    ResetLastError();
    long _result = 0;
#ifdef __MQL4__
#ifdef __debug__
    Print("OrderGetInteger(", EnumToString(property_id), ")...");
#endif
    switch (property_id) {
#ifndef __MQL__
      // Note: In MT, the value conflicts with ORDER_TIME_SETUP.
      case ORDER_TICKET:
        // Order ticket. Unique number assigned to each order.
        _result = OrderStatic::Ticket();
        break;
#endif
      case ORDER_TIME_SETUP:
        // Order setup time.
        // http://docs.mql4.com/trading/orderopentime
        _result = OrderStatic::OpenTime();
        break;
      case ORDER_TIME_SETUP_MSC:
        // The time of placing an order for execution (timestamp).
        _result = OrderGetInteger(ORDER_TIME_SETUP) * 1000;  // @fixit We need more precision.
        break;
      case ORDER_TIME_EXPIRATION:
        // Order expiration time.
        _result = OrderStatic::Expiration();
        break;
      case ORDER_TIME_DONE:
        // Order execution or cancellation time.
        _result = OrderStatic::OpenTime();
        break;
      case ORDER_TIME_DONE_MSC:
        // Order execution/cancellation time (timestamp).
        _result = OrderGetInteger(ORDER_TIME_DONE) * 1000;  // @fixit We need more precision.
        break;
      case ORDER_TYPE:
        // Order type.
        _result = OrderStatic::Type();
        break;
      case ORDER_TYPE_TIME:
        // Order lifetime.
        // MT4 orders are usually on an FOK basis in that you get a complete fill or nothing.
        _result = ORDER_TIME_GTC;
        break;
      case ORDER_STATE:
      case ORDER_TYPE_FILLING:
      case ORDER_REASON:
        // The reason or source for placing an order.
        // Not supported.
        SetUserError(ERR_INVALID_PARAMETER);
        break;
      case ORDER_MAGIC:
        // Unique order number.
        _result = OrderStatic::MagicNumber();
        break;
#ifdef ORDER_POSITION_ID
      case ORDER_POSITION_ID:
        // Position identifier.
        _result = OrderGetPositionID();
        break;
#endif
#ifdef ORDER_POSITION_BY_ID
      case ORDER_POSITION_BY_ID:
        // Identifier of an opposite position used for closing.
        // Not supported.
        SetUserError(ERR_INVALID_PARAMETER);
        break;
#endif
      default:
        // Unknown property.
        SetUserError(ERR_INVALID_PARAMETER);
    }

    int _last_error = GetLastError();

#ifdef __debug__
    if (_last_error > 0) {
      Print("OrderGetInteger(", EnumToString(property_id), ") = ", _result, ", error = ", _last_error);
    }
#endif

    if (_last_error != ERR_SUCCESS) {
      SetUserError((unsigned short)_last_error);
    }

    return _result;
#else
    return OrderGetParam(property_id, selected_ticket_type, ORDER_SELECT_DATA_TYPE_INTEGER, _result);
#endif
  }
  static bool OrderGetInteger(ENUM_ORDER_PROPERTY_INTEGER property_id, long &_out) {
#ifdef __MQL4__
    _out = (long)OrderGetInteger(property_id);
    return true;
#else
    return OrderGetParam(property_id, selected_ticket_type, ORDER_SELECT_DATA_TYPE_INTEGER, _out) >= 0;
#endif
  }

  /**
   * Returns the requested property of an order.
   *
   * @param ENUM_ORDER_PROPERTY_DOUBLE property_id
   *   Identifier of a property.
   *
   * @return double
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   *
   * @docs
   * - https://www.mql5.com/en/docs/trading/ordergetdouble
   *
   */
  static double OrderGetDouble(ENUM_ORDER_PROPERTY_DOUBLE property_id) {
    ResetLastError();
    double _result = WRONG_VALUE;
#ifdef __MQL4__
#ifdef __debug__
    Print("OrderGetDouble(", EnumToString(property_id), ")...");
#endif
    switch (property_id) {
      case ORDER_VOLUME_INITIAL:
        _result = ::OrderLots();  // @fixit Are we sure?
        break;
      case ORDER_VOLUME_CURRENT:
        _result = ::OrderLots();  // @fixit Are we sure?
        break;
      case ORDER_PRICE_OPEN:
        _result = ::OrderOpenPrice();
        break;
      case ORDER_SL:
        _result = ::OrderStopLoss();
        break;
      case ORDER_TP:
        _result = ::OrderTakeProfit();
        break;
      case ORDER_PRICE_CURRENT:
        _result = SymbolInfoStatic::GetBid(Order::OrderSymbol());
        break;
      case ORDER_PRICE_STOPLIMIT:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
    }

    int _last_error = GetLastError();

#ifdef __debug__
    if (_last_error > 0) {
      Print("OrderGetDouble(", EnumToString(property_id), ") = ", _result, ", error = ", _last_error);
    }
#endif

    if (_last_error != ERR_SUCCESS) {
      SetUserError((unsigned short)_last_error);
    }

    return _result;
#else
    return OrderGetParam(property_id, selected_ticket_type, ORDER_SELECT_DATA_TYPE_DOUBLE, _result);
#endif
  }
  static bool OrderGetDouble(ENUM_ORDER_PROPERTY_DOUBLE property_id, double &_out) {
#ifdef __MQL4__
    _out = OrderGetDouble(property_id);
    return true;
#else
    return OrderGetParam(property_id, selected_ticket_type, ORDER_SELECT_DATA_TYPE_DOUBLE, _out) >= 0;
#endif
  }

  /**
   * Returns the requested property of an order.
   *
   * @param ENUM_ORDER_PROPERTY_STRING property_id
   *   Identifier of a property.
   *
   * @return string
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   *
   * @docs
   * - https://www.mql5.com/en/docs/trading/ordergetstring
   *
   */
  static string OrderGetString(ENUM_ORDER_PROPERTY_STRING property_id) {
    ResetLastError();
    string _result;
#ifdef __MQL4__
#ifdef __debug__
    Print("OrderGetString(", EnumToString(property_id), ")...");
#endif
    switch (property_id) {
      case ORDER_SYMBOL:
        _result = OrderStatic::Symbol();
        break;
      case ORDER_COMMENT:
        _result = OrderStatic::Comment();
        break;
      case ORDER_EXTERNAL_ID:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
    }
    int _last_error = GetLastError();
#ifdef __debug__
    if (_last_error > 0) {
      Print("OrderGetString(", EnumToString(property_id), ") = ", _result, ", error = ", _last_error);
    }
#endif
    if (_last_error != ERR_SUCCESS) {
      SetUserError((unsigned short)_last_error);
    }
    return _result;
#else
    return OrderGetParam(property_id, selected_ticket_type, ORDER_SELECT_DATA_TYPE_STRING, _result);
#endif
  }
  static bool OrderGetString(ENUM_ORDER_PROPERTY_STRING property_id, string &_out) {
#ifdef __MQL4__
    _out = OrderGetString(property_id);
    return true;
#else
    return OrderGetParam(property_id, selected_ticket_type, ORDER_SELECT_DATA_TYPE_STRING, _out) != (string)NULL_VALUE;
#endif
  }

#ifndef __MQL4__
  /**
   * Returns the requested property for an order.
   *
   * @param int property_id
   *   Identifier of a property.
   *
   * @param ENUM_ORDER_SELECT_TYPE type
   *   Identifier of a property.
   *
   * @param long& _out
   *   Reference to output value (the same as returned from the function).
   *
   * @return long
   *   Returns the value of the property (same as for `_out` variable).
   *   In case of error, information can be obtained using GetLastError() function.
   *
   */
  static long OrderGetValue(int property_id, ENUM_ORDER_SELECT_TYPE type, long &_out) {
    switch (type) {
      case ORDER_SELECT_TYPE_NONE:
        return NULL;
      case ORDER_SELECT_TYPE_ACTIVE:
        _out = ::OrderGetInteger((ENUM_ORDER_PROPERTY_INTEGER)property_id);
        break;
      case ORDER_SELECT_TYPE_HISTORY:
        _out = ::HistoryOrderGetInteger(selected_ticket_id, (ENUM_ORDER_PROPERTY_INTEGER)property_id);
        break;
      case ORDER_SELECT_TYPE_DEAL:
        _out = ::HistoryDealGetInteger(selected_ticket_id, (ENUM_DEAL_PROPERTY_INTEGER)property_id);
        break;
      case ORDER_SELECT_TYPE_POSITION:
        _out = ::PositionGetInteger((ENUM_POSITION_PROPERTY_INTEGER)property_id);
        break;
    }

    return _out;
  }

  /**
   * Returns the requested property for an order.
   *
   * @param int property_id
   *   Identifier of a property.
   *
   * @param ENUM_ORDER_SELECT_TYPE type
   *   Identifier of a property.
   *
   * @param double& _out
   *   Reference to output value (the same as returned from the function).
   *
   * @return double
   *   Returns the value of the property (same as for `_out` variable).
   *   In case of error, information can be obtained using GetLastError() function.
   *
   */
  static double OrderGetValue(int property_id, ENUM_ORDER_SELECT_TYPE type, double &_out) {
    switch (type) {
      case ORDER_SELECT_TYPE_NONE:
        return NULL;
      case ORDER_SELECT_TYPE_ACTIVE:
        _out = ::OrderGetDouble((ENUM_ORDER_PROPERTY_DOUBLE)property_id);
        break;
      case ORDER_SELECT_TYPE_HISTORY:
        _out = ::HistoryOrderGetDouble(selected_ticket_id, (ENUM_ORDER_PROPERTY_DOUBLE)property_id);
        break;
      case ORDER_SELECT_TYPE_DEAL:
        _out = ::HistoryDealGetDouble(selected_ticket_id, (ENUM_DEAL_PROPERTY_DOUBLE)property_id);
        break;
      case ORDER_SELECT_TYPE_POSITION:
        _out = ::PositionGetDouble((ENUM_POSITION_PROPERTY_DOUBLE)property_id);
        break;
    }

    return _out;
  }

  /**
   * Returns the requested property for an order.
   *
   * @param int property_id
   *   Identifier of a property.
   *
   * @param ENUM_ORDER_SELECT_TYPE type
   *   Identifier of a property.
   *
   * @param string& _out
   *   Reference to output value (the same as returned from the function).
   *
   * @return string
   *   Returns the value of the property (same as for `_out` variable).
   *   In case of error, information can be obtained using GetLastError() function.
   *
   */
  static string OrderGetValue(int _prop_id, ENUM_ORDER_SELECT_TYPE _type, string &_out) {
    switch (_type) {
      case ORDER_SELECT_TYPE_NONE:
        _out = "";
        break;
      case ORDER_SELECT_TYPE_ACTIVE:
        _out = ::OrderGetString((ENUM_ORDER_PROPERTY_STRING)_prop_id);
        break;
      case ORDER_SELECT_TYPE_HISTORY:
        _out = ::HistoryOrderGetString(selected_ticket_id, (ENUM_ORDER_PROPERTY_STRING)_prop_id);
        break;
      case ORDER_SELECT_TYPE_DEAL:
        _out = ::HistoryDealGetString(selected_ticket_id, (ENUM_DEAL_PROPERTY_STRING)_prop_id);
        break;
      case ORDER_SELECT_TYPE_POSITION:
        _out = ::PositionGetString((ENUM_POSITION_PROPERTY_STRING)_prop_id);
        break;
    }

    return _out;
  }

  /**
   * Returns the requested property of an order.
   *
   * @param int _prop_id
   *   Mixed identifier of a property.
   *
   * @param ENUM_ORDER_SELECT_TYPE type
   *   Type of a property (active, history, deal, position).
   *
   * @param ENUM_ORDER_SELECT_DATA_TYPE data_type
   *   Type of the value requested (integer, double, string).
   *
   * @param ENUM_ORDER_SELECT_DATA_TYPE data_type
   *   Type of the value requested (integer, double, string).
   *
   * @return X& _out
   *   Returns the value of the property.
   *   In case of error, information can be obtained using GetLastError() function.
   */
  template <typename X>
  static X OrderGetParam(int _prop_id, ENUM_ORDER_SELECT_TYPE _type, ENUM_ORDER_SELECT_DATA_TYPE _data_type, X &_out) {
#ifndef __MQL4__
    switch (selected_ticket_type) {
      case ORDER_SELECT_TYPE_NONE:
        return NULL;

      case ORDER_SELECT_TYPE_ACTIVE:
      case ORDER_SELECT_TYPE_HISTORY:
        return OrderGetValue(_prop_id, selected_ticket_type, _out);

      case ORDER_SELECT_TYPE_DEAL:
        switch (_data_type) {
          case ORDER_SELECT_DATA_TYPE_INTEGER:
            switch (_prop_id) {
              case ORDER_TIME_SETUP:
                return OrderGetValue(DEAL_TIME, _type, _out);
              case ORDER_TYPE:
                switch ((int)OrderGetValue(DEAL_TYPE, _type, _out)) {
                  case DEAL_TYPE_BUY:
                    return (X)ORDER_TYPE_BUY;
                  case DEAL_TYPE_SELL:
                    return (X)ORDER_TYPE_SELL;
                  default:
                    return NULL;
                }
                break;
              case ORDER_STATE:
                // @fixme
                SetUserError(ERR_INVALID_PARAMETER);
              case ORDER_TIME_EXPIRATION:
              case ORDER_TIME_DONE:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_TIME_SETUP_MSC:
                return OrderGetValue(DEAL_TIME_MSC, _type, _out);
              case ORDER_TIME_DONE_MSC:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_TYPE_FILLING:
              case ORDER_TYPE_TIME:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_MAGIC:
                return OrderGetValue(DEAL_MAGIC, _type, _out);
              case ORDER_REASON:
                switch ((int)OrderGetValue(DEAL_REASON, _type, _out)) {
                  case DEAL_REASON_CLIENT:
                    return (X)ORDER_REASON_CLIENT;
                  case DEAL_REASON_MOBILE:
                    return (X)ORDER_REASON_MOBILE;
                  case DEAL_REASON_WEB:
                    return (X)ORDER_REASON_WEB;
                  case DEAL_REASON_EXPERT:
                    return (X)ORDER_REASON_EXPERT;
                  case DEAL_REASON_SL:
                    return (X)ORDER_REASON_SL;
                  case DEAL_REASON_TP:
                    return (X)ORDER_REASON_TP;
                  case DEAL_REASON_SO:
                    return (X)ORDER_REASON_SO;
                  default:
                    return NULL;
                }
                break;
              case ORDER_POSITION_ID:
                return OrderGetValue(DEAL_POSITION_ID, _type, _out);
              case ORDER_POSITION_BY_ID:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
            }
            break;
          case ORDER_SELECT_DATA_TYPE_DOUBLE:
            switch (_prop_id) {
              case ORDER_VOLUME_INITIAL:
                return OrderGetValue(DEAL_VOLUME, _type, _out);
              case ORDER_VOLUME_CURRENT:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_PRICE_OPEN:
                return OrderGetValue(DEAL_PRICE, _type, _out);
              case ORDER_SL:
              case ORDER_TP:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_PRICE_CURRENT:
                return OrderGetValue(DEAL_PRICE, _type, _out);
              case ORDER_PRICE_STOPLIMIT:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
            }
            break;
          case ORDER_SELECT_DATA_TYPE_STRING:
            switch (_prop_id) {
              case ORDER_SYMBOL:
              case ORDER_COMMENT:
              case ORDER_EXTERNAL_ID:
                return NULL;
            }
            break;
        }
        break;

      case ORDER_SELECT_TYPE_POSITION:
        switch (_data_type) {
          case ORDER_SELECT_DATA_TYPE_INTEGER:
            switch (_prop_id) {
              case ORDER_TIME_SETUP:
                return OrderGetValue(POSITION_TIME, _type, _out);
              case ORDER_TYPE:
                switch ((int)OrderGetValue(POSITION_TYPE, _type, _out)) {
                  case POSITION_TYPE_BUY:
                    return (X)ORDER_TYPE_BUY;
                  case POSITION_TYPE_SELL:
                    return (X)ORDER_TYPE_SELL;
                  default:
                    return NULL;
                }
                break;
              case ORDER_STATE:
                // @fixme
                SetUserError(ERR_INVALID_PARAMETER);
              case ORDER_TIME_EXPIRATION:
              case ORDER_TIME_DONE:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_TIME_SETUP_MSC:
                return OrderGetValue(POSITION_TIME_MSC, _type, _out);
              case ORDER_TIME_DONE_MSC:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_TYPE_FILLING:
              case ORDER_TYPE_TIME:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_MAGIC:
                return OrderGetValue(POSITION_MAGIC, _type, _out);
              case ORDER_REASON:
                switch ((int)OrderGetValue(POSITION_REASON, _type, _out)) {
                  case POSITION_REASON_CLIENT:
                    return (X)ORDER_REASON_CLIENT;
                  case POSITION_REASON_MOBILE:
                    return (X)ORDER_REASON_MOBILE;
                  case POSITION_REASON_WEB:
                    return (X)ORDER_REASON_WEB;
                  case POSITION_REASON_EXPERT:
                    return (X)ORDER_REASON_EXPERT;
                  default:
                    return NULL;
                }
                break;
              case ORDER_POSITION_ID:
                return OrderGetValue(POSITION_IDENTIFIER, _type, _out);
              case ORDER_POSITION_BY_ID:
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
            }
            break;
          case ORDER_SELECT_DATA_TYPE_DOUBLE:
            switch (_prop_id) {
              case ORDER_VOLUME_INITIAL:
                return OrderGetValue(POSITION_VOLUME, _type, _out);
              case ORDER_VOLUME_CURRENT:
                // @fixme
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
              case ORDER_PRICE_OPEN:
                return OrderGetValue(POSITION_PRICE_OPEN, _type, _out);
              case ORDER_SL:
                return OrderGetValue(POSITION_SL, _type, _out);
              case ORDER_TP:
                return OrderGetValue(POSITION_TP, _type, _out);
              case ORDER_PRICE_CURRENT:
                return OrderGetValue(POSITION_PRICE_CURRENT, _type, _out);
              case ORDER_PRICE_STOPLIMIT:
                // @fixme
                SetUserError(ERR_INVALID_PARAMETER);
                return NULL;
            }
            break;
          case ORDER_SELECT_DATA_TYPE_STRING:
            switch (_prop_id) {
              case ORDER_SYMBOL:
                return OrderGetValue(POSITION_SYMBOL, _type, _out);
              case ORDER_COMMENT:
                return OrderGetValue(POSITION_COMMENT, _type, _out);
              case ORDER_EXTERNAL_ID:
                return OrderGetValue(POSITION_EXTERNAL_ID, _type, _out);
            }
            break;
        }
        break;
    }

    return NULL;
#else
    return OrderGetValue(_prop_id, _type, _out);
#endif;
  }

#endif

  /* Conditions and actions */

  /**
   * Process order conditions.
   */
  bool ProcessConditions(bool _refresh = false) {
    bool _result = true;
    if (IsOpen(_refresh) && ShouldCloseOrder()) {
      string _reason = "Close condition";
#ifdef __MQL__
      // _reason += StringFormat(": %s", EnumToString(oparams.cond_close));
#endif
      ARRAY(DataParamEntry, _args);
      DataParamEntry _cond = _reason;
      ArrayPushObject(_args, _cond);
      _result &= Order::ExecuteAction(ORDER_ACTION_CLOSE, _args);
    }
    return _result;
  }

  /**
   * Checks for order condition.
   *
   * @param ENUM_ORDER_CONDITION _cond
   *   Order condition.
   * @param MqlParam _args
   *   Trade action arguments.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_ORDER_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    float _profit = (float)Get<long>(ORDER_PROP_PROFIT_PIPS);
    switch (_cond) {
      case ORDER_COND_IN_LOSS:
        return Get<long>(ORDER_PROP_PROFIT_PIPS) < (ArraySize(_args) > 0 ? -DataParamEntry::ToDouble(_args[0]) : 0);
      case ORDER_COND_IN_PROFIT:
        return Get<long>(ORDER_PROP_PROFIT_PIPS) > (ArraySize(_args) > 0 ? DataParamEntry::ToDouble(_args[0]) : 0);
      case ORDER_COND_IS_CLOSED:
        return IsClosed();
      case ORDER_COND_IS_OPEN:
        return IsOpen();
      case ORDER_COND_LIFETIME_GT_ARG:
      case ORDER_COND_LIFETIME_LT_ARG:
        if (ArraySize(_args) > 0) {
          long _arg_value = DataParamEntry::ToInteger(_args[0]);
          switch (_cond) {
            case ORDER_COND_LIFETIME_GT_ARG:
              return TimeCurrent() - odata.Get<datetime>(ORDER_TIME_SETUP) > _arg_value;
            case ORDER_COND_LIFETIME_LT_ARG:
              return TimeCurrent() - odata.Get<datetime>(ORDER_TIME_SETUP) < _arg_value;
          }
        }
      case ORDER_COND_PROP_EQ_ARG:
      case ORDER_COND_PROP_GT_ARG:
      case ORDER_COND_PROP_LT_ARG: {
        if (ArraySize(_args) >= 2) {
          // First argument is enum value (order property).
          long _prop_id = _args[0].integer_value;
          // Second argument is the actual value with compare with.
          switch (_args[1].type) {
            case TYPE_DOUBLE:
            case TYPE_FLOAT:
              Refresh((ENUM_ORDER_PROPERTY_DOUBLE)_prop_id);
              switch (_cond) {
                case ORDER_COND_PROP_EQ_ARG:
                  return odata.Get<double>((ENUM_ORDER_PROPERTY_DOUBLE)_prop_id) == _args[1].double_value;
                case ORDER_COND_PROP_GT_ARG:
                  return odata.Get<double>((ENUM_ORDER_PROPERTY_DOUBLE)_prop_id) > _args[1].double_value;
                case ORDER_COND_PROP_LT_ARG:
                  return odata.Get<double>((ENUM_ORDER_PROPERTY_DOUBLE)_prop_id) < _args[1].double_value;
              }
            case TYPE_INT:
            case TYPE_LONG:
            case TYPE_UINT:
            case TYPE_ULONG:
              Refresh((ENUM_ORDER_PROPERTY_INTEGER)_prop_id);
              switch (_cond) {
                case ORDER_COND_PROP_EQ_ARG:
                  return odata.Get<int>((ENUM_ORDER_PROPERTY_INTEGER)_prop_id) == _args[1].integer_value;
                case ORDER_COND_PROP_GT_ARG:
                  return odata.Get<int>((ENUM_ORDER_PROPERTY_INTEGER)_prop_id) > _args[1].integer_value;
                case ORDER_COND_PROP_LT_ARG:
                  return odata.Get<int>((ENUM_ORDER_PROPERTY_INTEGER)_prop_id) < _args[1].integer_value;
              }
            case TYPE_STRING:
              Refresh((ENUM_ORDER_PROPERTY_STRING)_prop_id);
              return odata.Get((ENUM_ORDER_PROPERTY_STRING)_prop_id) == _args[1].string_value;
              switch (_cond) {
                case ORDER_COND_PROP_EQ_ARG:
                  return odata.Get((ENUM_ORDER_PROPERTY_STRING)_prop_id) == _args[1].string_value;
                case ORDER_COND_PROP_GT_ARG:
                  return odata.Get((ENUM_ORDER_PROPERTY_STRING)_prop_id) > _args[1].string_value;
                case ORDER_COND_PROP_LT_ARG:
                  return odata.Get((ENUM_ORDER_PROPERTY_STRING)_prop_id) < _args[1].string_value;
              }
          }
        }
      }
      default:
        ologger.Error(StringFormat("Invalid order condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return false;
  }
  bool CheckCondition(ENUM_ORDER_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Order::CheckCondition(_cond, _args);
  }

  /**
   * Execute order action.
   *
   * @param ENUM_ORDER_ACTION _action
   *   Order action to execute.
   * @param MqlParam _args
   *   Trade action arguments.
   * @return
   *   Returns true when the condition is met.
   */
  bool ExecuteAction(ENUM_ORDER_ACTION _action, ARRAY_REF(DataParamEntry, _args)) {
    switch (_action) {
      case ORDER_ACTION_CLOSE:
        switch (oparams.dummy) {
          case false:
            return OrderClose(ORDER_REASON_CLOSED_BY_ACTION);
          case true:
            return OrderCloseDummy(ORDER_REASON_CLOSED_BY_ACTION);
        }
      case ORDER_ACTION_OPEN:
        return !oparams.dummy ? OrderSend() >= 0 : OrderSendDummy() >= 0;
      case ORDER_ACTION_COND_CLOSE_ADD:
        // Args:
        // 1st (i:0) - Order's enum condition.
        // 2rd... (i:1...) - Order's arguments to pass.
        if (ArraySize(_args) > 1) {
          ARRAY(DataParamEntry, _sargs);
          ArrayResize(_sargs, ArraySize(_args) - 1);
          for (int i = 0; i < ArraySize(_sargs); i++) {
            _sargs[i] = _args[i + 1];
          }
          oparams.AddConditionClose((ENUM_ORDER_CONDITION)_args[0].integer_value, _sargs);
        }
      default:
        ologger.Error(StringFormat("Invalid order action: %s!", EnumToString(_action), __FUNCTION_LINE__));
        return false;
    }
  }
  bool ExecuteAction(ENUM_ORDER_ACTION _action) {
    ARRAY(DataParamEntry, _args);
    return Order::ExecuteAction(_action, _args);
  }

  /* Printer methods */

  /**
   * Returns order details in text.
   */
  string const ToString() {
    SerializerConverter stub(Serializer::MakeStubObject<Order>(SERIALIZER_FLAG_SKIP_HIDDEN));
    return SerializerConverter::FromObject(THIS_REF, SERIALIZER_FLAG_SKIP_HIDDEN)
        .ToString<SerializerJson>(SERIALIZER_FLAG_SKIP_HIDDEN, &stub);
  }

  /**
   * Returns order details in text.
   */
  string ToString(ARRAY_REF(long, _props), ENUM_DATATYPE _type = TYPE_DOUBLE, string _dlm = ";") {
    int i = 0;
    string _output = "";
    switch (_type) {
      case TYPE_DOUBLE:
        for (i = 0; i < Array::ArraySize(_props); i++) {
          _output += StringFormat("%g%s", odata.Get<double>((ENUM_ORDER_PROPERTY_DOUBLE)_props[i]), _dlm);
        }
        break;
      case TYPE_LONG:
        for (i = 0; i < Array::ArraySize(_props); i++) {
          _output += StringFormat("%d%s", odata.Get<long>((ENUM_ORDER_PROPERTY_INTEGER)_props[i]), _dlm);
        }
        break;
      case TYPE_STRING:
        for (i = 0; i < Array::ArraySize(_props); i++) {
          _output += StringFormat("%d%s", odata.Get((ENUM_ORDER_PROPERTY_STRING)_props[i]), _dlm);
        }
        break;
      default:
        ologger.Error(StringFormat("%s: Unsupported type: %s!", __FUNCTION_LINE__, EnumToString(_type)));
    }
    return "";
  }

  /**
   * Prints information about the selected order in the log.
   *
   * @see http://docs.mql4.com/trading/orderprint
   */
  static void OrderPrint() {
#ifdef __MQL4__
    ::OrderPrint();
#else
    Order _order(Order::selected_ticket_id);
    Print(_order.ToString());
#endif
  }

  /* Serializers */

  SERIALIZER_EMPTY_STUB;

  /**
   * Returns serialized representation of the object instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.PassStruct(THIS_REF, "data", odata);
    _s.PassStruct(THIS_REF, "params", oparams);
    return SerializerNodeObject;
  }
};

#ifdef __MQL5__
// Assigns values to static variables.
ENUM_ORDER_SELECT_TYPE Order::selected_ticket_type = ORDER_SELECT_TYPE_NONE;
unsigned long Order::selected_ticket_id = 0;
#endif

#endif ORDER_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Order.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SymbolInfo.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Condition.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Includes Condition's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Prevents processing this includes file for the second time.
#ifndef CONDITION_ENUM_H
#define CONDITION_ENUM_H

/* Defines class' enums */

#ifndef MARKET_EVENT_ENUM
#define MARKET_EVENT_ENUM
/* Define market event conditions. */
enum ENUM_MARKET_EVENT {
  C_EVENT_NONE = 0,            // None
  C_AC_BUY_SELL = 1,           // AC on buy/sell
  C_AD_BUY_SELL = 2,           // AD on buy/sell
  C_ADX_BUY_SELL = 3,          // ADX on buy/sell
  C_ALLIGATOR_BUY_SELL = 4,    // Alligator on buy/sell
  C_ATR_BUY_SELL = 5,          // ATR on buy/sell
  C_AWESOME_BUY_SELL = 6,      // Awesome on buy/sell
  C_BANDS_BUY_SELL = 7,        // Bands on buy/sell
  C_BEARSPOWER_BUY_SELL = 8,   // BearsPower on buy/sell
  C_BULLSPOWER_BUY_SELL = 40,  // BullsPower on buy/sell
  C_BWMFI_BUY_SELL = 10,       // BWMFI on buy/sell
  C_CCI_BUY_SELL = 11,         // CCI on buy/sell
  C_DEMARKER_BUY_SELL = 12,    // DeMarker on buy/sell
  C_ENVELOPES_BUY_SELL = 13,   // Envelopes on buy/sell
  C_FORCE_BUY_SELL = 14,       // Force on buy/sell
  C_FRACTALS_BUY_SELL = 15,    // Fractals on buy/sell
  C_GATOR_BUY_SELL = 16,       // Gator on buy/sell
  C_ICHIMOKU_BUY_SELL = 17,    // Ichimoku on buy/sell
  C_MA_BUY_SELL = 18,          // MA on buy/sell
  C_MACD_BUY_SELL = 19,        // MACD on buy/sell
  C_MFI_BUY_SELL = 20,         // MFI on buy/sell
  C_MOMENTUM_BUY_SELL = 21,    // Momentum on buy/sell
  C_OBV_BUY_SELL = 22,         // OBV on buy/sell
  C_OSMA_BUY_SELL = 23,        // OSMA on buy/sell
  C_RSI_BUY_SELL = 24,         // RSI on buy/sell
  C_RVI_BUY_SELL = 25,         // RVI on buy/sell
  C_SAR_BUY_SELL = 26,         // SAR on buy/sell
  C_STDDEV_BUY_SELL = 27,      // StdDev on buy/sell
  C_STOCHASTIC_BUY_SELL = 28,  // Stochastic on buy/sell
  C_WPR_BUY_SELL = 29,         // WPR on buy/sell
  C_ZIGZAG_BUY_SELL = 30,      // ZigZag on buy/sell
  C_MA_FAST_SLOW_OPP = 31,     // MA Fast&Slow opposite
  C_MA_FAST_MED_OPP = 32,      // MA Fast&Med opposite
  C_MA_MED_SLOW_OPP = 33,      // MA Med&Slow opposite
#ifdef __advanced__
  C_CUSTOM1_BUY_SELL = 34,     // Custom 1 on buy/sell
  C_CUSTOM2_BUY_SELL = 35,     // Custom 2 on buy/sell
  C_CUSTOM3_BUY_SELL = 36,     // Custom 3 on buy/sell
  C_CUSTOM4_MARKET_COND = 37,  // Custom 4 market condition
  C_CUSTOM5_MARKET_COND = 38,  // Custom 5 market condition
  C_CUSTOM6_MARKET_COND = 39,  // Custom 6 market condition
#endif
};
#endif

/* Defines condition entry flags. */
enum ENUM_CONDITION_ENTRY_FLAGS {
  COND_ENTRY_FLAG_NONE = 0,
  COND_ENTRY_FLAG_IS_ACTIVE = 1,
  COND_ENTRY_FLAG_IS_EXPIRED = 2,
  COND_ENTRY_FLAG_IS_INVALID = 4,
  COND_ENTRY_FLAG_IS_READY = 8
};

/* Defines condition statements (operators). */
enum ENUM_CONDITION_STATEMENT {
  COND_AND = 1,  // Use AND statement.
  COND_OR,       // Use OR statement.
  COND_SEQ,      // Use sequential checks.
  FINAL_ENUM_COND_STATEMENT
};

/* Defines condition types. */
enum ENUM_CONDITION_TYPE {
  COND_TYPE_ACCOUNT = 1,  // Account condition.
  COND_TYPE_ACTION,       // Action condition.
  COND_TYPE_CHART,        // Chart condition.
  COND_TYPE_DATETIME,     // Datetime condition.
  COND_TYPE_EA,           // EA condition.
  COND_TYPE_INDICATOR,    // Indicator condition.
  COND_TYPE_MARKET,       // Market condition.
  COND_TYPE_MATH,         // Math condition.
  COND_TYPE_ORDER,        // Order condition.
  COND_TYPE_STRATEGY,     // Strategy condition.
  COND_TYPE_TASK,         // Task condition.
  COND_TYPE_TERMINAL,     // Terminal condition.
  COND_TYPE_TRADE,        // Trade condition.
  FINAL_CONDITION_TYPE_ENTRY
};

/* Defines class' condition enums */

/* Account conditions. */
enum ENUM_ACCOUNT_CONDITION {
  ACCOUNT_COND_NONE = 0,  // Empty condition.
  /* @todo
  ACCOUNT_COND_BALM_GT_YEARLY, // Current month's balance highest of the year
  ACCOUNT_COND_BALM_LT_YEARLY, // Current month's balance lowest of the year
  ACCOUNT_COND_BALT_GT_WEEKLY, // Today's balance highest of the week
  ACCOUNT_COND_BALT_IN_LOSS, // Today's balance in loss
  ACCOUNT_COND_BALT_IN_PROFIT, // Today's balance in profit
  ACCOUNT_COND_BALT_LT_WEEKLY, // Today's balance lowest of the week
  ACCOUNT_COND_BALW_GT_MONTHLY, // Current week's balance highest of the month
  ACCOUNT_COND_BALW_LT_MONTHLY, // Current week's balance lowest of the month
  ACCOUNT_COND_BALY_IN_LOSS, // Previous day in loss
  ACCOUNT_COND_BALY_IN_PROFIT, // Previous day in profit
  */
  ACCOUNT_COND_BAL_IN_LOSS,       // Total balance in loss
  ACCOUNT_COND_BAL_IN_PROFIT,     // Total balance in profit
  ACCOUNT_COND_EQUITY_01PC_HIGH,  // Equity 1% high
  ACCOUNT_COND_EQUITY_01PC_LOW,   // Equity 1% low
  ACCOUNT_COND_EQUITY_02PC_HIGH,  // Equity 2% high
  ACCOUNT_COND_EQUITY_02PC_LOW,   // Equity 2% low
  ACCOUNT_COND_EQUITY_05PC_HIGH,  // Equity 5% high
  ACCOUNT_COND_EQUITY_05PC_LOW,   // Equity 5% low
  ACCOUNT_COND_EQUITY_10PC_HIGH,  // Equity 10% high
  ACCOUNT_COND_EQUITY_10PC_LOW,   // Equity 10% low
  ACCOUNT_COND_EQUITY_20PC_HIGH,  // Equity 20% high
  ACCOUNT_COND_EQUITY_20PC_LOW,   // Equity 20% low
  ACCOUNT_COND_EQUITY_IN_LOSS,    // Equity in loss
  ACCOUNT_COND_EQUITY_IN_PROFIT,  // Equity in profit
  /* @todo
  ACCOUNT_COND_MARGIN_CALL_10PC, // Margin call (10% margin left)
  ACCOUNT_COND_MARGIN_CALL_20PC, // Margin call (20% margin left)
  */
  ACCOUNT_COND_MARGIN_FREE_IN_PC,  // Margin used in % (args)
  ACCOUNT_COND_MARGIN_USED_10PC,   // Margin used in 10%
  ACCOUNT_COND_MARGIN_USED_20PC,   // Margin used in 20%
  ACCOUNT_COND_MARGIN_USED_50PC,   // Margin used in 50%
  ACCOUNT_COND_MARGIN_USED_80PC,   // Margin used in 80%
  ACCOUNT_COND_MARGIN_USED_99PC,   // Margin used in 99%
  ACCOUNT_COND_MARGIN_USED_IN_PC,  // Margin used in % (args)
  FINAL_ACCOUNT_CONDITION_ENTRY
};

/* Action conditions. */
enum ENUM_ACTION_CONDITION {
  ACTION_COND_NONE = 0,     // Empty condition.
  ACTION_COND_IS_ACTIVE,    // Is active.
  ACTION_COND_IS_DONE,      // Is done.
  ACTION_COND_IS_FAILED,    // Is failed.
  ACTION_COND_IS_FINISHED,  // Is finished.
  ACTION_COND_IS_INVALID,   // Is invalid.
  FINAL_ACTION_CONDITION_ENTRY
};

/* Chart conditions. */
enum ENUM_CHART_CONDITION {
  CHART_COND_ASK_BAR_PEAK = 1,          // Ask price on current bar's peak
  CHART_COND_ASK_GT_BAR_HIGH = 2,       // Ask price > bar's high price
  CHART_COND_ASK_GT_BAR_LOW = 3,        // Ask price > bar's low price
  CHART_COND_ASK_LT_BAR_HIGH = 4,       // Ask price < bar's high price
  CHART_COND_ASK_LT_BAR_LOW = 5,        // Ask price < bar's low price
  CHART_COND_BAR_CLOSE_GT_PP_PP = 6,    // Current bar's close price > Pivot point (main line)
  CHART_COND_BAR_CLOSE_GT_PP_R1 = 7,    // Current bar's close price > Pivot point (R1)
  CHART_COND_BAR_CLOSE_GT_PP_R2 = 8,    // Current bar's close price > Pivot point (R2)
  CHART_COND_BAR_CLOSE_GT_PP_R3 = 9,    // Current bar's close price > Pivot point (R3)
  CHART_COND_BAR_CLOSE_GT_PP_R4 = 10,   // Current bar's close price > Pivot point (R4)
  CHART_COND_BAR_CLOSE_GT_PP_S1 = 11,   // Current bar's close price > Pivot point (S1)
  CHART_COND_BAR_CLOSE_GT_PP_S2 = 12,   // Current bar's close price > Pivot point (S2)
  CHART_COND_BAR_CLOSE_GT_PP_S3 = 13,   // Current bar's close price > Pivot point (S3)
  CHART_COND_BAR_CLOSE_GT_PP_S4 = 14,   // Current bar's close price > Pivot point (S4)
  CHART_COND_BAR_CLOSE_LT_PP_PP = 15,   // Current bar's close price < Pivot point (main line)
  CHART_COND_BAR_CLOSE_LT_PP_R1 = 16,   // Current bar's close price < Pivot point (R1)
  CHART_COND_BAR_CLOSE_LT_PP_R2 = 17,   // Current bar's close price < Pivot point (R2)
  CHART_COND_BAR_CLOSE_LT_PP_R3 = 18,   // Current bar's close price < Pivot point (R3)
  CHART_COND_BAR_CLOSE_LT_PP_R4 = 19,   // Current bar's close price < Pivot point (R4)
  CHART_COND_BAR_CLOSE_LT_PP_S1 = 20,   // Current bar's close price < Pivot point (S1)
  CHART_COND_BAR_CLOSE_LT_PP_S2 = 21,   // Current bar's close price < Pivot point (S2)
  CHART_COND_BAR_CLOSE_LT_PP_S3 = 22,   // Current bar's close price < Pivot point (S3)
  CHART_COND_BAR_CLOSE_LT_PP_S4 = 23,   // Current bar's close price < Pivot point (S4)
  CHART_COND_BAR_HIGHEST_CURR_20 = 24,  // Is current bar has highest price out of 20 bars
  CHART_COND_BAR_HIGHEST_CURR_50 = 25,  // Is current bar has highest price out of 50 bars
  CHART_COND_BAR_HIGHEST_PREV_20 = 26,  // Is previous bar has highest price out of 20 bars
  CHART_COND_BAR_HIGHEST_PREV_50 = 27,  // Is previous bar has highest price out of 50 bars
  CHART_COND_BAR_HIGH_GT_OPEN = 28,     // Current bar's high price > current open
  CHART_COND_BAR_HIGH_LT_OPEN = 29,     // Current bar's high price < current open
  CHART_COND_BAR_INDEX_EQ_ARG,          // Current bar's index equals argument value
  CHART_COND_BAR_INDEX_GT_ARG,          // Current bar's index greater than argument value
  CHART_COND_BAR_INDEX_LT_ARG,          // Current bar's index lower than argument value
  CHART_COND_BAR_LOWEST_CURR_20,        // Is current bar has lowest price out of 20 bars
  CHART_COND_BAR_LOWEST_CURR_50,        // Is current bar has lowest price out of 50 bars
  CHART_COND_BAR_LOWEST_PREV_20,        // Is previous bar has lowest price out of 20 bars
  CHART_COND_BAR_LOWEST_PREV_50,        // Is previous bar has lowest price out of 50 bars
  CHART_COND_BAR_LOW_GT_OPEN,           // Current bar's low price > current open
  CHART_COND_BAR_LOW_LT_OPEN,           // Current bar's low price < current open
  CHART_COND_BAR_NEW,                   // On new bar
  /* @fixme
  CHART_COND_BAR_NEW_DAY           = 37, // On new daily bar
  CHART_COND_BAR_NEW_HOUR          = 38, // On new hourly bar
  CHART_COND_BAR_NEW_MONTH         = 49, // On new monthly bar
  CHART_COND_BAR_NEW_WEEK          = 50, // On new weekly bar
  CHART_COND_BAR_NEW_YEAR          = 51, // On new yearly bar
  */
  FINAL_ENUM_CHART_CONDITION_ENTRY
};

/* EA conditions. */
enum ENUM_EA_CONDITION {
  EA_COND_IS_ACTIVE = 1,     // When EA is active (can trade).
  EA_COND_IS_ENABLED,        // When EA is enabled.
  EA_COND_IS_NOT_CONNECTED,  // When terminal is not connected.
  EA_COND_ON_INIT,           // On EA init.
  EA_COND_ON_NEW_MINUTE,     // On new minute.
  EA_COND_ON_NEW_HOUR,       // On new hour.
  EA_COND_ON_NEW_DAY,        // On new day.
  EA_COND_ON_NEW_WEEK,       // On new week.
  EA_COND_ON_NEW_MONTH,      // On new month.
  EA_COND_ON_NEW_YEAR,       // On new year.
  EA_COND_ON_QUIT,           // On EA quit.
  FINAL_EA_CONDITION_ENTRY
};

/* Indicator conditions. */
enum ENUM_INDICATOR_CONDITION {
  INDI_COND_ENTRY_IS_MAX = 1,  // Indicator entry value is maximum.
  INDI_COND_ENTRY_IS_MIN = 2,  // Indicator entry value is minimum.
  INDI_COND_ENTRY_GT_AVG = 3,  // Indicator entry value is greater than average.
  INDI_COND_ENTRY_GT_MED = 4,  // Indicator entry value is greater than median.
  INDI_COND_ENTRY_LT_AVG = 5,  // Indicator entry value is lesser than average.
  INDI_COND_ENTRY_LT_MED = 6,  // Indicator entry value is lesser than median.
  FINAL_INDICATOR_CONDITION_ENTRY = 7
};

/* Market conditions. */
enum ENUM_MARKET_CONDITION {
  MARKET_COND_IN_PEAK_HOURS = 1,  // Market in peak hours (8-16)
  MARKET_COND_SPREAD_LE_10 = 2,   // Spread <= 10pts
  MARKET_COND_SPREAD_GT_10 = 3,   // Spread > 10pts
  MARKET_COND_SPREAD_GT_20 = 4,   // Spread > 20pts
  FINAL_ENUM_MARKET_CONDITION_ENTRY = 5
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Condition.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef MARKET_MQH
#define MARKET_MQH

// Forward declaration.
class Market;
class SymbolInfo;

// Includes.







// Structs.
// Market info.
struct MarketData {
  int empty;
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer &_s) { return SerializerNodeObject; }
};

/**
 * Class to provide market information.
 */
class Market : public SymbolInfo {
 protected:
  // Struct variables.
  MarketData minfo;

 public:
  /**
   * Implements class constructor with a parameter.
   */
  Market(string _symbol = NULL, Log *_log = NULL) : SymbolInfo(_symbol) {}

  /**
   * Class deconstructor.
   */
  ~Market() {}

  /* Getters */

  /* Functional methods */

  /**
   * Refresh data in pre-defined variables and series arrays.
   *
   * @see http://docs.mql4.com/series/refreshrates
   */
  static bool RefreshRates() {
// In MQL5 returns true for backward compatibility.
#ifdef __MQL4__
    return ::RefreshRates();
#else
    return true;
#endif
  }

  /**
   * Returns market data about securities.
   *
   * @docs
   * - https://docs.mql4.com/constants/environment_state/marketinfoconstants
   */
  static double MarketInfo(string _symbol, int _type) {
#ifdef __MQL4__
    return ::MarketInfo(_symbol, _type);
#else
    switch (_type) {
      case MODE_LOW:
        // Low day price.
        return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_LASTLOW);
      case MODE_HIGH:
        // High day price.
        return SymbolInfoStatic::SymbolInfoDouble(_symbol, SYMBOL_LASTHIGH);
      case MODE_TIME:
        // Time of the last quote.
        return (double)SymbolInfoStatic::GetQuoteTime(_symbol);
      case MODE_BID:
        // Last incoming bid price.
        return SymbolInfoStatic::GetBid(_symbol);
      case MODE_ASK:
        // Last incoming ask price.
        return SymbolInfoStatic::GetAsk(_symbol);
      case MODE_POINT:
        // Point size in the quote currency.
        return SymbolInfoStatic::GetPointSize(_symbol);
      case MODE_DIGITS:
        // Symbol digits after decimal point.
        return SymbolInfoStatic::GetDigits(_symbol);
      case MODE_SPREAD:
        // Spread value in points.
        return SymbolInfoStatic::GetSpreadInPts(_symbol);
      case MODE_STOPLEVEL:
        // Stop level in points.
        return (double)SymbolInfoStatic::GetTradeStopsLevel(_symbol);
      case MODE_LOTSIZE:
        // Lot size in the base currency.
        return SymbolInfoStatic::GetTradeContractSize(_symbol);
      case MODE_TICKVALUE:
        // Tick value in the deposit currency.
        return SymbolInfoStatic::GetTickValue(_symbol);
      case MODE_TICKSIZE:
        // Tick size in points.
        return SymbolInfoStatic::GetTickSize(_symbol);
      case MODE_SWAPLONG:
        // Swap of the buy order.
        return SymbolInfoStatic::GetSwapLong(_symbol);
      case MODE_SWAPSHORT:
        // Swap of the sell order.
        return SymbolInfoStatic::GetSwapShort(_symbol);
      case MODE_LOTSTEP:
        // Step for changing lots.
        return SymbolInfoStatic::GetVolumeStep(_symbol);
      case MODE_MINLOT:
        // Minimum permitted amount of a lot.
        return SymbolInfoStatic::GetVolumeMin(_symbol);
      case MODE_MAXLOT:
        // Maximum permitted amount of a lot.
        return SymbolInfoStatic::GetVolumeMax(_symbol);
      case MODE_SWAPTYPE:
        // Swap calculation method.
        return (double)SymbolInfoStatic::GetSwapMode(_symbol);
      case MODE_PROFITCALCMODE:
        // Profit calculation mode.
        return (double)SymbolInfoStatic::SymbolInfoInteger(_symbol, SYMBOL_TRADE_CALC_MODE);
      case MODE_STARTING:
        // @todo: Market starting date.
        return (0);
      case MODE_EXPIRATION:
        // @todo: Market expiration date.
        return (0);
      case MODE_TRADEALLOWED:
        // Trade is allowed for the symbol.
        return Terminal::IsTradeAllowed();
      case MODE_MARGINCALCMODE:
        // @todo: Margin calculation mode.
        return (0);
      case MODE_MARGININIT:
        // Initial margin requirements for 1 lot.
        return SymbolInfoStatic::GetMarginInit(_symbol);
      case MODE_MARGINMAINTENANCE:
        // Margin to maintain open orders calculated for 1 lot.
        return SymbolInfoStatic::GetMarginMaintenance(_symbol);
      case MODE_MARGINHEDGED:
        // @todo: Hedged margin calculated for 1 lot.
        return (0);
      case MODE_MARGINREQUIRED:
        // @todo: Free margin required to open 1 lot for buying.
        return (0);
      case MODE_FREEZELEVEL:
        // Order freeze level in points.
        return SymbolInfoStatic::GetFreezeLevel(_symbol);
    }
#endif
    return (-1);
  }
  double MarketInfo(int _type) { return MarketInfo(symbol, _type); }

  /**
   * Get delta value per lot in account currency of a point of symbol.
   *
   * @see
   * - https://www.mql5.com/en/forum/127584
   * - https://www.mql5.com/en/forum/133792/page3#512466
   * - https://www.mql5.com/en/forum/135345#515262
   */
  static double GetDeltaValue(string _symbol) {
    // Return tick value in the deposit currency divided by tick size in points.
    return SymbolInfoStatic::GetTickValue(_symbol) / SymbolInfoStatic::GetTickSize(_symbol);
  }
  double GetDeltaValue() { return GetDeltaValue(symbol); }

  /**
   * Returns the last price change in pips.
   */
  double GetLastPriceChangeInPips() {
    return fmax(fabs(GetLastAsk() - GetAsk()), fabs(GetLastBid() - GetBid())) * pow(10, GetPipDigits());
  }

  /* END: Getters */

  /* Normalization methods */

  /**
   * Normalize price value.
   *
   * Make sure that the price is a multiple of ticksize.
   */
  static double NormalizePrice(string _symbol, double p) {
    // See:
    // - https://www.mql5.com/en/forum/135345 (for non-currency DE30)
    // - https://www.mql5.com/en/forum/139338
    // - MarketInfo(chart.symbol,MODE_TICKSIZE) returns 0.5
    // - MarketInfo(chart.symbol,MODE_DIGITS) return 1
    // - Point = 0.1
    // Rare fix when a change in tick size leads to a change in tick value.
    double _result = round(p / SymbolInfoStatic::GetPointSize(_symbol)) * SymbolInfoStatic::GetTickSize(_symbol);
    _result = NormalizeDouble(_result, SymbolInfoStatic::GetDigits(_symbol));
    return _result;
  }
  double NormalizePrice(double p) { return NormalizePrice(symbol, p); }

  /* Market state checking */

  /**
   * Check whether given symbol exists.
   */
  static bool SymbolExists(string _symbol = NULL) {
    ResetLastError();
    SymbolInfoStatic::GetAsk(_symbol);
    return GetLastError() != ERR_MARKET_UNKNOWN_SYMBOL;
  }

  /* Printer methods */

  /**
   * Returns Market data in textual representation.
   */
  string const ToString() {
    return StringFormat(string("Pip digits/value: %d/%g, Spread: %d pts (%g pips; %.4f%%), Pts/pip: %d, ") +
                            "Volume digits: %d, " + "Delta: %g, Last change: %g pips",
                        GetPipDigits(), GetPipValue(), GetSpreadInPts(), GetSpreadInPips(), GetSpreadInPct(),
                        GetPointsPerPip(), GetVolumeDigits(), GetDeltaValue(), GetLastPriceChangeInPips());
  }

  /**
   * Returns Market data in CSV format.
   */
  string ToCSV(bool _header = false) {
    return !_header ? StringFormat(string("%d,%g,%d,%g,%.4f,%d,") + "%g,%d,%.1f,%d," + "%g,%g", GetPipDigits(),
                                   GetPipValue(), GetSpreadInPts(), GetSpreadInPips(), GetSpreadInPct(),
                                   GetPointsPerPip(), GetVolumeDigits(), GetDeltaValue(), GetLastPriceChangeInPips())
                    : string("Pip Digits,Pip Value,Spread,Pts/pip,") + "Volume digits," + "Delta,Last change (pips)";
  }

  /* Conditions */

  /**
   * Checks for market condition.
   *
   * @param ENUM_MARKET_CONDITION _cond
   *   Market condition.
   * @param MqlParam[] _args
   *   Condition arguments.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_MARKET_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    switch (_cond) {
      case MARKET_COND_IN_PEAK_HOURS:
        return DateTimeStatic::Hour() >= 8 && DateTimeStatic::Hour() <= 16;
      case MARKET_COND_SPREAD_LE_10:
        return GetSpreadInPts() <= 10;
      case MARKET_COND_SPREAD_GT_10:
        return GetSpreadInPts() > 10;
      case MARKET_COND_SPREAD_GT_20:
        return GetSpreadInPts() > 20;
      default:
        GetLogger().Error(StringFormat("Invalid market condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
        return false;
    }
  }
  bool CheckCondition(ENUM_MARKET_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Market::CheckCondition(_cond, _args);
  }

  /* Serializers */

  /**
   * Returns serialized representation of the object instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.PassStruct(THIS_REF, "market-data", minfo);
    // _s.PassStruct(THIS_REF, "symbol-info", (SymbolInfo *)this);
    return SerializerNodeObject;
  }
};

#ifndef __MQL4__
// Defines macros (for MQL4 backward compatibility).
double MarketInfo(string _symbol, int _type) { return Market::MarketInfo(_symbol, _type); }
#endif

#endif  // MARKET_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Market.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Condition.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Class to provide chart, timeframe and timeseries operations.
 *
 * @docs
 * - https://www.mql5.com/en/docs/chart_operations
 * - https://www.mql5.com/en/docs/series
 */

// Class dependencies.
class Chart;
class Market;

// Prevents processing this includes file for the second time.
#ifndef CHART_MQH
#define CHART_MQH

// Includes.









#ifndef __MQL4__
// Defines structs (for MQL4 backward compatibility).
// Struct arrays that contains given values of each bar of the current chart.
// For MQL4 backward compatibility.
// @docs: https://docs.mql4.com/predefined
ChartBarTime Time;
ChartPriceClose Close;
ChartPriceHigh High;
ChartPriceLow Low;
ChartPriceOpen Open;
#endif

#ifndef __MQL4__
// Defines global functions (for MQL4 backward compatibility).
int iBarShift(string _symbol, int _tf, datetime _time, bool _exact = false) {
  return ChartStatic::iBarShift(_symbol, (ENUM_TIMEFRAMES)_tf, _time, _exact);
}
double iClose(string _symbol, int _tf, int _shift) {
  return ChartStatic::iClose(_symbol, (ENUM_TIMEFRAMES)_tf, _shift);
}
#endif

#ifndef __MQL__
struct MqlRates {
  datetime time;     // Period start time
  double open;       // Open price
  double high;       // The highest price of the period
  double low;        // The lowest price of the period
  double close;      // Close price
  long tick_volume;  // Tick volume
  int spread;        // Spread
  long real_volume;  // Trade volume
};
#endif

/**
 * Class to provide chart, timeframe and timeseries operations.
 */
class Chart : public Market {
 protected:
  // Structs.
  ARRAY(ChartEntry, chart_saves);
  ChartParams cparams;

  // Stores information about the prices, volumes and spread.
  ARRAY(MqlRates, rates);
  ChartEntry c_entry;

  // Stores indicator instances.
  // @todo
  // Dict<long, Indicator> indis;

  // Variables.
  datetime last_bar_time;

  // Current tick index (incremented every OnTick()).
  int tick_index;

  // Current bar index (incremented every OnTick() if IsNewBar() is true).
  int bar_index;

 public:
  /**
   * Class constructor.
   */
  Chart(ChartParams &_cparams)
      : cparams(_cparams), Market(_cparams.symbol), last_bar_time(GetBarTime()), tick_index(-1), bar_index(-1) {
    // Save the first BarOHLC values.
    SaveChartEntry();
    cparams.Set(CHART_PARAM_ID, ChartStatic::ID());
  }
  Chart(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, string _symbol = NULL)
      : cparams(_tf, _symbol, ChartStatic::ID()),
        Market(_symbol),
        last_bar_time(GetBarTime()),
        tick_index(-1),
        bar_index(-1) {
    // Save the first BarOHLC values.
    SaveChartEntry();
  }
  Chart(ENUM_TIMEFRAMES_INDEX _tfi, string _symbol = NULL)
      : cparams(_tfi, _symbol, ChartStatic::ID()),
        Market(_symbol),
        last_bar_time(GetBarTime()),
        tick_index(-1),
        bar_index(-1) {
    // Save the first BarOHLC values.
    SaveChartEntry();
  }

  /**
   * Class constructor.
   */
  ~Chart() {}

  /* Getters */

  /**
   * Gets a chart parameter value.
   */
  template <typename T>
  T Get(ENUM_CHART_PARAM _param) {
    return cparams.Get<T>(_param);
  }

  /**
   * Gets OHLC price values.
   *
   * @param _shift Shift.
   *
   * @return
   *   Returns BarOHLC struct.
   */
  BarOHLC GetOHLC(unsigned int _shift = 0) {
    datetime _time = GetBarTime(_shift);
    float _open = 0, _high = 0, _low = 0, _close = 0;
    if (_time > 0) {
      _open = (float)GetOpen(_shift);
      _high = (float)GetHigh(_shift);
      _low = (float)GetLow(_shift);
      _close = (float)GetClose(_shift);
    }
    BarOHLC _ohlc(_open, _high, _low, _close, _time);
    return _ohlc;
  }

  /**
   * Gets OHLC price values.
   *
   * @param _shift Shift.
   *
   * @return
   *   Returns BarOHLC struct.
   */
  static BarOHLC GetOHLC(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, unsigned int _shift = 0, string _symbol = NULL) {
    datetime _time = ChartStatic::iTime(_symbol, _tf, _shift);
    float _open = 0, _high = 0, _low = 0, _close = 0;
    if (_time > 0) {
      _open = (float)ChartStatic::iOpen(_symbol, _tf, _shift);
      _high = (float)ChartStatic::iHigh(_symbol, _tf, _shift);
      _low = (float)ChartStatic::iLow(_symbol, _tf, _shift);
      _close = (float)ChartStatic::iClose(_symbol, _tf, _shift);
    }
    BarOHLC _ohlc(_open, _high, _low, _close, _time);
    return _ohlc;
  }

  /**
   * Gets chart entry.
   *
   * @param
   *   _tf ENUM_TIMEFRAMES Timeframe to use.
   *   _shift uint _shift Shift to use.
   *   _symbol string Symbol to use.
   *
   * @return
   *   Returns ChartEntry struct.
   */
  static ChartEntry GetEntry(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, unsigned int _shift = 0, string _symbol = NULL) {
    ChartEntry _chart_entry;
    BarOHLC _ohlc = Chart::GetOHLC(_tf, _shift, _symbol);
    if (_ohlc.open > 0) {
      BarEntry _bar_entry(_ohlc);
      _chart_entry.SetBar(_bar_entry);
    }
    return _chart_entry;
  }

  /**
   * Gets chart entry.
   *
   * @param
   *   _shift uint _shift Shift to use.
   *
   * @return
   *   Returns ChartEntry struct.
   */
  ChartEntry GetEntry(unsigned int _shift = 0) {
    ChartEntry _chart_entry;
    BarOHLC _ohlc = GetOHLC(_shift);
    if (_ohlc.open > 0) {
      // @todo: Adds caching.
      BarEntry _bar_entry(_ohlc);
      _chart_entry.SetBar(_bar_entry);
    }
    return _chart_entry;
  }

  /**
   * Gets copy of params.
   *
   * @return
   *   Returns structure for Trade's params.
   */
  ChartParams GetParams() const { return cparams; }

  /* State checking */

  /**
   * Validate whether given timeframe index is valid.
   */
  static bool IsValidTfIndex(ENUM_TIMEFRAMES_INDEX _tfi, string _symbol = NULL) {
    return IsValidTf(ChartTf::IndexToTf(_tfi), _symbol);
  }

  /**
   * Validates whether given timeframe is valid.
   */
  static bool IsValidShift(int _shift, ENUM_TIMEFRAMES _tf, string _symbol = NULL) {
    return ChartStatic::iTime(_symbol, _tf, _shift) > 0;
  }

  /**
   * Validates whether given timeframe is valid.
   */
  static bool IsValidTf(ENUM_TIMEFRAMES _tf, string _symbol = NULL) { return ChartStatic::iOpen(_symbol, _tf) > 0; }

  /* State checking */

  /**
   * Validates whether given timeframe is valid.
   */
  bool IsValidShift(int _shift) { return GetBarTime(_shift) > 0; }

  /**
   * Validates whether given timeframe is valid.
   */
  bool IsValidTf() {
    static bool is_valid = false;
    return is_valid ? is_valid : GetOpen() > 0;
  }

  /**
   * Validate whether given timeframe index is valid.
   */
  bool IsValidTfIndex() { return Chart::IsValidTfIndex(Get<ENUM_TIMEFRAMES_INDEX>(CHART_PARAM_TFI), symbol); }

  /* Timeseries */
  /* @see: https://docs.mql4.com/series */

  datetime GetBarTime(ENUM_TIMEFRAMES _tf, uint _shift = 0) { return ChartStatic::iTime(symbol, _tf, _shift); }
  datetime GetBarTime(unsigned int _shift = 0) {
    return ChartStatic::iTime(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift);
  }
  datetime GetLastBarTime() { return last_bar_time; }

  /**
   * Returns open price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  double GetOpen(ENUM_TIMEFRAMES _tf, uint _shift = 0) { return ChartStatic::iOpen(symbol, _tf, _shift); }
  double GetOpen(uint _shift = 0) { return ChartStatic::iOpen(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift); }

  /**
   * Returns close price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   *
   * @see http://docs.mql4.com/series/iclose
   */
  double GetClose(ENUM_TIMEFRAMES _tf, int _shift = 0) { return ChartStatic::iClose(symbol, _tf, _shift); }
  double GetClose(int _shift = 0) { return ChartStatic::iClose(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift); }

  /**
   * Returns low price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  double GetLow(ENUM_TIMEFRAMES _tf, uint _shift = 0) { return ChartStatic::iLow(symbol, _tf, _shift); }
  double GetLow(uint _shift = 0) { return ChartStatic::iLow(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift); }

  /**
   * Returns low price value for the bar of indicated symbol.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  double GetHigh(ENUM_TIMEFRAMES _tf, uint _shift = 0) { return ChartStatic::iHigh(symbol, _tf, _shift); }
  double GetHigh(uint _shift = 0) { return ChartStatic::iHigh(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift); }

  /**
   * Returns the current price value given applied price type.
   */
  double GetPrice(ENUM_APPLIED_PRICE _ap, int _shift = 0) {
    return ChartStatic::iPrice(_ap, symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift);
  }

  /**
   * Returns tick volume value for the bar.
   *
   * If local history is empty (not loaded), function returns 0.
   */
  long GetVolume(ENUM_TIMEFRAMES _tf, uint _shift = 0) { return ChartStatic::iVolume(symbol, _tf, _shift); }
  long GetVolume(uint _shift = 0) { return ChartStatic::iVolume(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _shift); }

  /**
   * Returns the shift of the maximum value over a specific number of periods depending on type.
   */
  int GetHighest(ENUM_TIMEFRAMES _tf, int type, int _count = WHOLE_ARRAY, int _start = 0) {
    return ChartStatic::iHighest(symbol, _tf, type, _count, _start);
  }
  int GetHighest(int type, int _count = WHOLE_ARRAY, int _start = 0) {
    return ChartStatic::iHighest(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), type, _count, _start);
  }

  /**
   * Returns the shift of the lowest value over a specific number of periods depending on type.
   */
  int GetLowest(int _type, int _count = WHOLE_ARRAY, int _start = 0) {
    return ChartStatic::iLowest(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _type, _count, _start);
  }

  /**
   * Returns the number of bars on the specified chart.
   */
  int GetBars() { return ChartStatic::iBars(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF)); }

  /**
   * Search for a bar by its time.
   *
   * Returns the index of the bar which covers the specified time.
   */
  int GetBarShift(datetime _time, bool _exact = false) {
    return ChartStatic::iBarShift(symbol, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), _time, _exact);
  }

  /**
   * Get peak price at given number of bars.
   *
   * In case of error, check it via GetLastError().
   */
  double GetPeakPrice(int bars, int mode, int index, ENUM_TIMEFRAMES timeframe = PERIOD_CURRENT) {
    int ibar = -1;
    // @todo: Add symbol parameter.
    double peak_price = GetOpen(0);
    switch (mode) {
      case MODE_HIGH:
        ibar = ChartStatic::iHighest(symbol, timeframe, MODE_HIGH, bars, index);
        return ibar >= 0 ? GetHigh(timeframe, ibar) : false;
      case MODE_LOW:
        ibar = ChartStatic::iLowest(symbol, timeframe, MODE_LOW, bars, index);
        return ibar >= 0 ? GetLow(timeframe, ibar) : false;
      default:
        return false;
    }
  }
  double GetPeakPrice(int bars, int mode = MODE_HIGH, int index = 0) {
    return GetPeakPrice(bars, mode, index, Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF));
  }

  /**
   * List active timeframes.
   *
   * @param
   * _all bool If true, return also non-active timeframes.
   *
   * @return
   * Returns textual representation of list of timeframes.
   */
  static string ListTimeframes(bool _all = false, string _prefix = "Timeframes: ") {
    string output = _prefix;
    for (int _tfi = 0; _tfi < FINAL_ENUM_TIMEFRAMES_INDEX; _tfi++) {
      if (_all) {
        output += StringFormat("%s: %s; ", ChartTf::IndexToString((ENUM_TIMEFRAMES_INDEX)_tfi),
                               Chart::IsValidTfIndex((ENUM_TIMEFRAMES_INDEX)_tfi) ? "On" : "Off");
      } else {
        output += Chart::IsValidTfIndex((ENUM_TIMEFRAMES_INDEX)_tfi)
                      ? ChartTf::IndexToString((ENUM_TIMEFRAMES_INDEX)_tfi) + "; "
                      : "";
      }
    }
    return output;
  }

  /* Chart */

  /**
   * Sets a flag hiding indicators.
   *
   * After the Expert Advisor has been tested and the appropriate chart opened, the flagged indicators will not be drawn
   * in the testing chart. Every indicator called will first be flagged with the current hiding flag. It must be noted
   * that only those indicators can be drawn in the testing chart that are directly called from the expert under test.
   *
   * @param
   * _hide bool Flag for hiding indicators when testing. Set true to hide created indicators, otherwise false.
   */
  static void HideTestIndicators(bool _hide = false) {
#ifdef __MQL4__
    ::HideTestIndicators(_hide);
#else  // __MQL5__
    ::TesterHideIndicators(_hide);
#endif
  }

  /* Calculation methods */

  /**
   * Calculate modelling quality.
   *
   * @see:
   * - https://www.mql5.com/en/articles/1486
   * - https://www.mql5.com/en/articles/1513
   */
  static double CalcModellingQuality(ENUM_TIMEFRAMES TimePr = PERIOD_CURRENT) {
    int i;
    int nBarsInM1 = 0;
    int nBarsInPr = 0;
    int nBarsInNearPr = 0;
    ENUM_TIMEFRAMES TimeNearPr = PERIOD_M1;
    double ModellingQuality = 0;
    long StartGen = 0;
    long StartBar = 0;
    long StartGenM1 = 0;
    long HistoryTotal = 0;
    datetime x = StrToTime("1971.01.01 00:00");
    datetime modeling_start_time = StrToTime("1971.01.01 00:00");

    if (TimePr == NULL) TimePr = (ENUM_TIMEFRAMES)Period();
    if (TimePr == PERIOD_M1) TimeNearPr = PERIOD_M1;
    if (TimePr == PERIOD_M5) TimeNearPr = PERIOD_M1;
    if (TimePr == PERIOD_M15) TimeNearPr = PERIOD_M5;
    if (TimePr == PERIOD_M30) TimeNearPr = PERIOD_M15;
    if (TimePr == PERIOD_H1) TimeNearPr = PERIOD_M30;
    if (TimePr == PERIOD_H4) TimeNearPr = PERIOD_H1;
    if (TimePr == PERIOD_D1) TimeNearPr = PERIOD_H4;
    if (TimePr == PERIOD_W1) TimeNearPr = PERIOD_D1;
    if (TimePr == PERIOD_MN1) TimeNearPr = PERIOD_W1;

    // 1 minute.
    double nBars = fmin(iBars(NULL, TimePr) * TimePr, iBars(NULL, PERIOD_M1));
    for (i = 0; i < nBars; i++) {
      if (ChartStatic::iOpen(NULL, PERIOD_M1, i) >= 0.000001) {
        if (ChartStatic::iTime(NULL, PERIOD_M1, i) >= modeling_start_time) {
          nBarsInM1++;
        }
      }
    }

    // Nearest time.
    nBars = ChartStatic::iBars(NULL, TimePr);
    for (i = 0; i < nBars; i++) {
      if (ChartStatic::iOpen(NULL, TimePr, i) >= 0.000001) {
        if (ChartStatic::iTime(NULL, TimePr, i) >= modeling_start_time) nBarsInPr++;
      }
    }

    // Period time.
    nBars = fmin(ChartStatic::iBars(NULL, TimePr) * TimePr / TimeNearPr, iBars(NULL, TimeNearPr));
    for (i = 0; i < nBars; i++) {
      if (ChartStatic::iOpen(NULL, TimeNearPr, (int)i) >= 0.000001) {
        if (ChartStatic::iTime(NULL, TimeNearPr, i) >= modeling_start_time) nBarsInNearPr++;
      }
    }

    HistoryTotal = nBarsInPr;
    nBarsInM1 = nBarsInM1 / TimePr;
    nBarsInNearPr = nBarsInNearPr * TimeNearPr / TimePr;
    StartGenM1 = HistoryTotal - nBarsInM1;
    StartBar = HistoryTotal - nBarsInPr;
    StartBar = 0;
    StartGen = HistoryTotal - nBarsInNearPr;

    if (TimePr == PERIOD_M1) {
      StartGenM1 = HistoryTotal;
      StartGen = StartGenM1;
    }
    if ((HistoryTotal - StartBar) != 0) {
      ModellingQuality =
          ((0.25 * (StartGen - StartBar) + 0.5 * (StartGenM1 - StartGen) + 0.9 * (HistoryTotal - StartGenM1)) /
           (HistoryTotal - StartBar)) *
          100;
    }
    return (ModellingQuality);
  }

  /* Setters */

  /**
   * Sets a chart parameter value.
   */
  template <typename T>
  void Set(ENUM_CHART_PARAM _param, T _value) {
    cparams.Set<T>(_param, _value);
  }

  /**
   * Sets chart entry.
   */
  void SetEntry(ChartEntry &_entry) { c_entry = _entry; }

  /**
   * Sets open time value for the last bar of indicated symbol with timeframe.
   */
  void SetLastBarTime() { last_bar_time = GetBarTime(); }

  /* State checking */

  /**
   * Check whether the price is in its peak for the current period.
   */
  static bool IsPeak(ENUM_TIMEFRAMES _period, string _symbol = NULL) {
    return SymbolInfoStatic::GetAsk(_symbol) >= ChartStatic::iHigh(_symbol, _period) ||
           SymbolInfoStatic::GetAsk(_symbol) <= ChartStatic::iLow(_symbol, _period);
  }
  bool IsPeak() { return IsPeak(Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF), symbol); }

  /**
   * Acknowledges chart that new tick happened.
   */
  virtual void OnTick() {
    ++tick_index;

    if (GetLastBarTime() != GetBarTime()) {
      ++bar_index;
    }
  }

  /**
   * Returns current tick index (incremented every OnTick()).
   */
  unsigned int GetTickIndex() { return tick_index == -1 ? 0 : tick_index; }

  /**
   * Returns current bar index (incremented every OnTick() if IsNewBar() is true).
   */
  unsigned int GetBarIndex() { return bar_index == -1 ? 0 : bar_index; }

  /**
   * Check if there is a new bar to parse.
   */
  bool IsNewBar() {
    // static datetime _last_itime = iTime();
    bool _result = false;
    if (GetLastBarTime() != GetBarTime()) {
      SetLastBarTime();
      _result = true;
    }
    return _result;
  }

  /* Chart operations */

  /**
   * Redraws the current chart forcedly.
   *
   * @see:
   * https://docs.mql4.com/chart_operations/chartredraw
   */
  static void WindowRedraw() {
#ifdef __MQLBUILD__
#ifdef __MQL4__
    ::WindowRedraw();
#else
    ::ChartRedraw(0);
#endif
#else  // C++
    printf("@todo: %s\n", "WindowRedraw()");
#endif
  }

  /* Getters */

  /**
   * Gets chart entry.
   */
  ChartEntry GetEntry() const { return c_entry; }

  /**
   * Returns list of modelling quality for all periods.
   */
  static string GetModellingQuality() {
    string output = "Modelling Quality: ";
    output += StringFormat(
        "%s: %.2f%%, %s: %.2f%%, %s: %.2f%%, %s: %.2f%%, %s: %.2f%%, %s: %.2f%%, %s: %.2f%%, %s: %.2f%%, %s: %.2f%%;",
        "M1", CalcModellingQuality(PERIOD_M1), "M5", CalcModellingQuality(PERIOD_M5), "M15",
        CalcModellingQuality(PERIOD_M15), "M30", CalcModellingQuality(PERIOD_M30), "H1",
        CalcModellingQuality(PERIOD_H1), "H4", CalcModellingQuality(PERIOD_H4), "D1", CalcModellingQuality(PERIOD_D1),
        "W1", CalcModellingQuality(PERIOD_W1), "MN1", CalcModellingQuality(PERIOD_MN1));
    return output;
  }

  /* Conditions */

  /**
   * Checks for chart condition.
   *
   * @param ENUM_CHART_CONDITION _cond
   *   Chart condition.
   * @param MqlParam _args
   *   Trade action arguments.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_CHART_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    float _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4;
    switch (_cond) {
      case CHART_COND_ASK_BAR_PEAK:
        return IsPeak();
      case CHART_COND_ASK_GT_BAR_HIGH:
        return GetAsk() > GetHigh();
      case CHART_COND_ASK_GT_BAR_LOW:
        return GetAsk() > GetLow();
      case CHART_COND_ASK_LT_BAR_HIGH:
        return GetAsk() < GetHigh();
      case CHART_COND_ASK_LT_BAR_LOW:
        return GetAsk() < GetLow();
      case CHART_COND_BAR_CLOSE_GT_PP_PP: {
        ChartEntry _centry = Chart::GetEntry(1);
        return GetClose() > _centry.bar.ohlc.GetPivot();
      }
      case CHART_COND_BAR_CLOSE_GT_PP_R1: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _r1;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_R2: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _r2;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_R3: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _r3;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_R4: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _r4;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_S1: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _s1;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_S2: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _s2;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_S3: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _s3;
      }
      case CHART_COND_BAR_CLOSE_GT_PP_S4: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() > _s4;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_PP: {
        ChartEntry _centry = Chart::GetEntry(1);
        return GetClose() < _centry.bar.ohlc.GetPivot();
      }
      case CHART_COND_BAR_CLOSE_LT_PP_R1: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _r1;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_R2: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _r2;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_R3: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _r3;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_R4: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _r4;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_S1: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _s1;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_S2: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _s2;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_S3: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _s3;
      }
      case CHART_COND_BAR_CLOSE_LT_PP_S4: {
        ChartEntry _centry = Chart::GetEntry(1);
        _centry.bar.ohlc.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
        return GetClose() < _s4;
      }
      case CHART_COND_BAR_HIGHEST_CURR_20:
        return GetHighest(MODE_CLOSE, 20) == 0;
      case CHART_COND_BAR_HIGHEST_CURR_50:
        return GetHighest(MODE_CLOSE, 50) == 0;
      case CHART_COND_BAR_HIGHEST_PREV_20:
        return GetHighest(MODE_CLOSE, 20) == 1;
      case CHART_COND_BAR_HIGHEST_PREV_50:
        return GetHighest(MODE_CLOSE, 50) == 1;
      case CHART_COND_BAR_HIGH_GT_OPEN:
        return GetHigh() > GetOpen();
      case CHART_COND_BAR_HIGH_LT_OPEN:
        return GetHigh() < GetOpen();
      case CHART_COND_BAR_INDEX_EQ_ARG:
        // Current bar's index equals argument value.
        if (ArraySize(_args) > 0) {
          return GetBarIndex() == DataParamEntry::ToInteger(_args[0]);
        } else {
          SetUserError(ERR_INVALID_PARAMETER);
          return false;
        }
      case CHART_COND_BAR_INDEX_GT_ARG:
        // Current bar's index greater than argument value.
        if (ArraySize(_args) > 0) {
          return GetBarIndex() > DataParamEntry::ToInteger(_args[0]);
        } else {
          SetUserError(ERR_INVALID_PARAMETER);
          return false;
        }
      case CHART_COND_BAR_INDEX_LT_ARG:
        // Current bar's index lower than argument value.
        if (ArraySize(_args) > 0) {
          return GetBarIndex() < DataParamEntry::ToInteger(_args[0]);
        } else {
          SetUserError(ERR_INVALID_PARAMETER);
          return false;
        }
      case CHART_COND_BAR_LOWEST_CURR_20:
        return GetLowest(MODE_CLOSE, 20) == 0;
      case CHART_COND_BAR_LOWEST_CURR_50:
        return GetLowest(MODE_CLOSE, 50) == 0;
      case CHART_COND_BAR_LOWEST_PREV_20:
        return GetLowest(MODE_CLOSE, 20) == 1;
      case CHART_COND_BAR_LOWEST_PREV_50:
        return GetLowest(MODE_CLOSE, 50) == 1;
      case CHART_COND_BAR_LOW_GT_OPEN:
        return GetLow() > GetOpen();
      case CHART_COND_BAR_LOW_LT_OPEN:
        return GetLow() < GetOpen();
      case CHART_COND_BAR_NEW:
        return IsNewBar();
      /*
      case CHART_COND_BAR_NEW_DAY:
        // @todo;
        return false;
      case CHART_COND_BAR_NEW_HOUR:
        // @todo;
        return false;
      case CHART_COND_BAR_NEW_MONTH:
        // @todo;
        return false;
      case CHART_COND_BAR_NEW_WEEK:
        // @todo;
        return false;
      case CHART_COND_BAR_NEW_YEAR:
        // @todo;
        return false;
      */
      default:
        GetLogger().Error(StringFormat("Invalid market condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
        return false;
    }
  }
  bool CheckCondition(ENUM_CHART_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Chart::CheckCondition(_cond, _args);
  }

  /* Printer methods */

  /**
   * Returns textual representation of the Chart class.
   */
  string ToString(unsigned int _shift = 0) {
    return StringFormat("%s: %s", ChartTf::TfToString(Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF)), GetEntry(_shift).ToCSV());
  }

  /* Static methods */

  /**
   * Returns the price value given applied price type.
   */
  static float GetAppliedPrice(ENUM_APPLIED_PRICE _ap, float _o, float _h, float _c, float _l) {
    BarOHLC _bar(_o, _h, _c, _l);
    return _bar.GetAppliedPrice(_ap);
  }

  /* Other methods */

  /* Snapshots */

  /**
   * Save the current BarOHLC values.
   *
   * @return
   *   Returns true if BarOHLC values has been saved, otherwise false.
   */
  bool SaveChartEntry() {
    // @todo: Use MqlRates.
    uint _last = ArraySize(chart_saves);
    if (ArrayResize(chart_saves, _last + 1, 100)) {
      chart_saves[_last].bar.ohlc.time = ChartStatic::iTime();
      chart_saves[_last].bar.ohlc.open = (float)Chart::GetOpen();
      chart_saves[_last].bar.ohlc.high = (float)Chart::GetHigh();
      chart_saves[_last].bar.ohlc.low = (float)Chart::GetLow();
      chart_saves[_last].bar.ohlc.close = (float)Chart::GetClose();
      return true;
    } else {
      return false;
    }
  }

  /**
   * Load stored BarOHLC values.
   *
   * @param
   *   _index uint Index of the element in BarOHLC array.
   * @return
   *   Returns BarOHLC struct element.
   */
  ChartEntry LoadChartEntry(uint _index = 0) { return chart_saves[_index]; }

  /**
   * Return size of BarOHLC array.
   */
  ulong SizeChartEntry() { return ArraySize(chart_saves); }

  /* Serializers */

  /**
   * Returns serialized representation of the object instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    ChartEntry _centry = GetEntry();
    _s.PassStruct(THIS_REF, "chart-entry", _centry, SERIALIZER_FIELD_FLAG_DYNAMIC);
    return SerializerNodeObject;
  }

  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
};

#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Chart.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerCsv.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Strategy.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: DrawIndicator.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Draw.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.define.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Group of functions intended for working with graphic objects relating to any specified chart.
 */

// Class dependencies.
class Chart;
class Draw;

// Includes.



#ifndef __MQL4__
// Defines macros (for MQL4 backward compatibility).
#define SetIndexArrow(_index, _value) (PlotIndexSetInteger(_index, PLOT_ARROW, _value))
#define SetIndexDrawBegin(_index, _value) (PlotIndexSetInteger(_index, PLOT_DRAW_BEGIN, _value))
#define SetIndexEmptyValue(_index, _value) (PlotIndexSetDouble(_index, PLOT_EMPTY_VALUE, _value))
#define SetIndexShift(_index, _value) (PlotIndexSetInteger(_index, PLOT_SHIFT, _value))
#endif

#ifndef __MQL4__
// Defines global functions (for MQL4 backward compatibility).
bool ObjectCreate(string _name, ENUM_OBJECT _otype, int _swindow, datetime _t1, double _p1) {
  return Draw::ObjectCreate(0, _name, _otype, _swindow, _t1, _p1);
}
bool ObjectDelete(string _name) { return Draw::ObjectDelete(_name); }
bool ObjectSet(string _name, int _prop_id, double _value) { return Draw::ObjectSet(_name, _prop_id, _value); }
int ObjectsTotal(int _type = EMPTY) { return Draw::ObjectsTotal(); }
string ObjectName(int _index) { return Draw::ObjectName(_index); }
void SetIndexLabel(int _index, string _text) { Draw::SetIndexLabel(_index, _text); }
void SetIndexStyle(int _index, int _type, int _style = EMPTY, int _width = EMPTY, color _clr = CLR_NONE) {
  Draw::SetIndexStyle(_index, _type, _style, _width, _clr);
}
#endif

#define WINDOW_MAIN 0

#ifdef __MQL5__
#define OBJPROP_TIME1 ((ENUM_OBJECT_PROPERTY_INTEGER)0)
#define OBJPROP_PRICE1 1
#define OBJPROP_TIME2 2
#define OBJPROP_PRICE2 3
#define OBJPROP_TIME3 4
#define OBJPROP_PRICE3 5
#define OBJPROP_COLOR ((ENUM_OBJECT_PROPERTY_INTEGER)6)
#define OBJPROP_STYLE 7
#define OBJPROP_WIDTH 8
#define OBJPROP_BACK ((ENUM_OBJECT_PROPERTY_INTEGER)9)
#define OBJPROP_FIBOLEVELS 200
#endif

/**
 * Class to provide drawing methods working with graphic objects.
 */
class Draw : public Chart {
 protected:
  // Variables.
  long chart_id;
  // Class variables.

 public:
  /**
   * Class constructor.
   */
  Draw(long _chart_id = 0) : chart_id(_chart_id != 0 ? _chart_id : ChartID()) {}

  /* Graphic object related methods */

  /* Getters */

  /**
   * Returns the name of the corresponding object.
   *
   * @return
   * Name of the object is returned in case of success.
   */
  static string ObjectName(long _chart_id, int _pos, int _sub_window = -1, int _type = -1) {
    return ::ObjectName(_chart_id, _pos, _sub_window, _type);
  }
  static string ObjectName(int _index) { return Draw::ObjectName(0, _index); }

  /**
   * Returns the number of objects in the specified chart,
   * specified subwindow, of the specified type.
   *
   * @return
   * The number of objects.
   */
  static int ObjectsTotal(long chart_id, int type = EMPTY, int window = -1) {
#ifdef __MQL4__
    return ::ObjectsTotal(chart_id, window, type);
#else
    return ::ObjectsTotal(chart_id, window, type);
#endif
  }
  static int ObjectsTotal() { return Draw::ObjectsTotal(0); }

  /* Setters */

  /**
   * Sets drawing line description for showing in the DataWindow and in the tooltip.
   *
   * @return
   * If successful, returns true, otherwise false.
   */
  static bool SetIndexLabel(int index, string text) {
#ifdef __MQL4__
    // https://docs.mql4.com/customind/setindexlabel
    ::SetIndexLabel(index, text);
    return true;
#else
    // https://www.mql5.com/en/docs/customind/plotindexsetstring
    return PlotIndexSetString(index, PLOT_LABEL, text);
#endif
  }

  /**
   * Sets the new type, style, width and color for a given indicator line.
   *
   */
  static void SetIndexStyle(int index, int type, int style = EMPTY, int width = EMPTY, color clr = CLR_NONE) {
#ifdef __MQL4__
    // https://docs.mql4.com/customind/setindexstyle
    ::SetIndexStyle(index, type, style, width, clr);
#else
    if (width != EMPTY) {
      PlotIndexSetInteger(index, PLOT_LINE_WIDTH, width);
    }
    if (clr != CLR_NONE) {
      PlotIndexSetInteger(index, PLOT_LINE_COLOR, clr);
    }
    PlotIndexSetInteger(index, PLOT_DRAW_TYPE, type);
    PlotIndexSetInteger(index, PLOT_LINE_STYLE, style);
#endif
  }

  /**
   * Changes the value of the specified object property.
   *
   * @see:
   * - https://docs.mql4.com/objects/objectset
   * - https://docs.mql4.com/constants/objectconstants/enum_object_property
   */
  static bool ObjectSet(string name, int prop_id, double prop_value, long chart_id = 0) {
#ifdef __MQL4__
    return ::ObjectSet(name, prop_id, prop_value);
#else  // __MQL5__
    switch (prop_id) {
      // Datetime value to set/get first coordinate time part.
      case OBJPROP_TIME1:
        return ObjectSetInteger(chart_id, name, OBJPROP_TIME, (long)prop_value);
      // Datetime value to set/get second coordinate time part.
      case OBJPROP_TIME2:
        return ObjectSetInteger(chart_id, name, OBJPROP_TIME, 1, (long)prop_value);
      // Datetime value to set/get third coordinate time part.
      case OBJPROP_TIME3:
        return ObjectSetInteger(chart_id, name, OBJPROP_TIME, 2, (long)prop_value);
      // Double value to set/get first coordinate price part.
      case OBJPROP_PRICE1:
        return ObjectSetDouble(chart_id, name, OBJPROP_PRICE, (double)prop_value);
      // Double value to set/get second coordinate price part.
      case OBJPROP_PRICE2:
        return ObjectSetDouble(chart_id, name, OBJPROP_PRICE, 1, prop_value);
      // Double value to set/get third coordinate price part.
      case OBJPROP_PRICE3:
        return ObjectSetDouble(chart_id, name, OBJPROP_PRICE, 2, prop_value);
      case OBJPROP_ANGLE:      // Double value to set/get angle object property in degrees.
      case OBJPROP_DEVIATION:  // Double value to set/get deviation property for Standard deviation objects.
      case OBJPROP_SCALE:      // Double value to set/get scale object property.
        return ObjectSetDouble(chart_id, name, (ENUM_OBJECT_PROPERTY_DOUBLE)prop_id, (double)prop_value);
      case OBJPROP_RAY:
        // Boolean value to set/get ray flag of object.
        return ObjectSetInteger(chart_id, name, OBJPROP_RAY_RIGHT, (long)prop_value);
      case OBJPROP_FIBOLEVELS:
        // Integer value to set/get Fibonacci object level count. Can be from 0 to 32.
        return ObjectSetInteger(chart_id, name, OBJPROP_LEVELS, (long)prop_value);
      case OBJPROP_ARROWCODE:   // Arrow code for the Arrow object (char).
      case OBJPROP_BACK:        // Boolean value to set/get background drawing flag for object.
      case OBJPROP_COLOR:       // Color value to set/get object color.
      case OBJPROP_CORNER:      // The corner of the chart to link a graphical object.
      case OBJPROP_ELLIPSE:     // Boolean value to set/get ellipse flag for fibo arcs.
      case OBJPROP_FONTSIZE:    // Font size (int).
      case OBJPROP_LEVELCOLOR:  // Color of the line-level (color).
      case OBJPROP_LEVELSTYLE:  // Style of the line-level (ENUM_LINE_STYLE).
      case OBJPROP_LEVELWIDTH:  // Thickness of the line-level (int).
      case OBJPROP_STYLE:       // Value is one of the constants to set/get object line style.
      case OBJPROP_TIMEFRAMES:  // Visibility of an object at timeframes (flags).
      case OBJPROP_WIDTH:       // Integer value to set/get object line width. Can be from 1 to 5.
      case OBJPROP_XDISTANCE:   // The distance in pixels along the X axis from the binding corner (int).
      case OBJPROP_YDISTANCE:   // The distance in pixels along the Y axis from the binding corner (int).
        return ObjectSetInteger(chart_id, name, (ENUM_OBJECT_PROPERTY_INTEGER)prop_id, (long)prop_value);
      default:
        break;
    }
    return (false);
#endif
  }

  /* Object methods */

  /**
   * Creates an object with the specified name, type, and the initial coordinates.
   */
  static bool ObjectCreate(long _cid, string _name, ENUM_OBJECT _otype, int _swindow, datetime _t1, double _p1) {
#ifdef __MQL4__
    // https://docs.mql4.com/objects/objectcreate
    return ::ObjectCreate(_name, _otype, _swindow, _t1, _p1);
#else
    // https://www.mql5.com/en/docs/objects/objectcreate
    return ::ObjectCreate(_cid, _name, _otype, _swindow, _t1, _p1);
#endif
  }
  static bool ObjectCreate(long _cid, string _name, ENUM_OBJECT _otype, int _swindow, datetime _t1, double _p1,
                           datetime _t2, double _p2) {
#ifdef __MQL4__
    // https://docs.mql4.com/objects/objectcreate
    return ::ObjectCreate(_name, _otype, _swindow, _t1, _p1, _t2, _p2);
#else
    // https://www.mql5.com/en/docs/objects/objectcreate
    return ::ObjectCreate(_cid, _name, _otype, _swindow, _t1, _p1, _t2, _p2);
#endif
  }

  /**
   * Moves an object coordinate in the chart.
   */
  bool ObjectMove(string name, int point, datetime time1, double price1) {
#ifdef __MQL4__
    return ::ObjectMove(name, point, time1, price1);
#else
    return ::ObjectMove(chart_id, name, point, time1, price1);
#endif
  }

  /**
   * Deletes object via name.
   */
  static bool ObjectDelete(long chart_id, string name) {
#ifdef __MQL4__
    // https://docs.mql4.com/objects/objectdelete
    return ::ObjectDelete(name);
#else
    // https://www.mql5.com/en/docs/objects/objectdelete
    return ::ObjectDelete(chart_id, name);
#endif
  }
  static bool ObjectDelete(string name) { return Draw::ObjectDelete(0, name); }

  /**
   * Draw a vertical line.
   */
  bool DrawVLine(string oname, datetime tm) {
    bool result = Draw::ObjectCreate(NULL, oname, OBJ_VLINE, 0, tm, 0);
    if (!result) PrintFormat("%(): Can't create vertical line! code #", __FUNCTION__, GetLastError());
    return (result);
  }

  /**
   * Draw a horizontal line.
   */
  bool DrawHLine(string oname, double value) {
    bool result = Draw::ObjectCreate(NULL, oname, OBJ_HLINE, 0, 0, value);
    if (!result) PrintFormat("%(): Can't create horizontal line! code #", __FUNCTION__, GetLastError());
    return (result);
  }

  /**
   * Delete a vertical line.
   */
  bool DeleteVertLine(string oname) {
    bool result = Draw::ObjectDelete(NULL, oname);
    if (!result) PrintFormat("%(): Can't delete vertical line! code #", __FUNCTION__, GetLastError());
    return (result);
  }

  /**
   * Draw a line given the price.
   */
  void ShowLine(string oname, double price, int colour = Yellow) {
    Draw::ObjectCreate(chart_id, oname, OBJ_HLINE, 0, GetBarTime(), price);
    Draw::ObjectSet(oname, OBJPROP_COLOR, colour);
    Draw::ObjectMove(oname, 0, GetBarTime(), price);
  }

  /**
   * Draw a trend line.
   */
  bool TLine(string name, double p1, double p2, datetime d1, datetime d2, color clr = clrYellow, bool ray = false,
             int window = WINDOW_MAIN) {
    if (ObjectFind(chart_id, name) >= 0 && Draw::ObjectMove(name, 0, d1, p1)) {
      Draw::ObjectMove(name, 1, d2, p2);
    } else if (!Draw::ObjectCreate(chart_id, name, OBJ_TREND, window, d1, p1, d2, p2)) {
      // Note: In case of error, check the message by GetLastError().
      if (GetLastError() == 4206) {
        // No specified subwindow.
        ResetLastError();
      }
      return false;
    }

    if (!Draw::ObjectSet(name, OBJPROP_RAY, ray)) {
      return false;
    }

    if (clr && !Draw::ObjectSet(name, OBJPROP_COLOR, clr)) {
      return false;
    }

    ResetLastError();
    return true;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Draw.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DrawIndicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Group of functions intended for working with graphic objects relating to any specified chart.
 */

// Ignore processing of this file if already included.
#ifndef DRAW_INDICATOR_MQH
#define DRAW_INDICATOR_MQH

// Includes.





// Forward declaration.
class IndicatorBase;

class DrawPoint {
 public:
  datetime time;
  double value;
  // Operator overloading methods.
  void operator=(const DrawPoint& r) {
    time = r.time;
    value = r.value;
  }
  // Special methods.
  DrawPoint(const DrawPoint& r) : time(r.time), value(r.value) {}
  DrawPoint(datetime _time = NULL, double _value = 0) : time(_time), value(_value) {}
};

class DrawIndicator {
 protected:
  color color_line;
  Draw* draw;
  IndicatorBase* indi;

 public:
  // Object variables.
  DictObject<string, DrawPoint> last_points;

  /* Special methods */

  /**
   * Class constructor.
   */
  DrawIndicator(IndicatorBase* _indi) : indi(_indi) {
    // color_line = Object::IsValid(_indi) ? _indi.GetParams().indi_color : clrRed; // @fixme
    draw = new Draw();
  }

  /**
   * Class deconstructor.
   */
  ~DrawIndicator() {
    if (draw != NULL) {
      delete draw;
    }
    /* @fixme
    for (DictObjectIterator<string, DrawPoint> iter = indis.Begin(); iter.IsValid(); ++iter) {
     delete iter.Value();
    }
    */
  }

  /* Setters */

  /* Class methods */

  /**
   * Sets color of line.
   */
  void SetColorLine(color _clr) { color_line = _clr; }

  /**
   * Draw line from the last point.
   */
  void DrawLineTo(string _name, datetime _time, double _value, int _window = WINDOW_MAIN) {
    if (!last_points.KeyExists(_name)) {
      last_points.Set(_name, DrawPoint(_time, _value));
    } else {
      DrawPoint* last_point = last_points.GetByKey(_name);

      draw.TLine(_name + "_" + IntegerToString(_time), last_point.value, _value, last_point.time, _time, color_line,
                 false, _window);

      last_point.time = _time;
      last_point.value = _value;
    }
  }
};
#endif  // DRAW_INDICATOR_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: DrawIndicator.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: String.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Strategy.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Strategy's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Enumeration for strategy bitwise open methods. */
enum ENUM_OPEN_METHOD {
  OPEN_METHOD1 = 1 << 0,    // Method #1.
  OPEN_METHOD2 = 1 << 1,    // Method #2.
  OPEN_METHOD3 = 1 << 2,    // Method #3.
  OPEN_METHOD4 = 1 << 3,    // Method #4.
  OPEN_METHOD5 = 1 << 4,    // Method #5.
  OPEN_METHOD6 = 1 << 5,    // Method #6.
  OPEN_METHOD7 = 1 << 6,    // Method #7.
  OPEN_METHOD8 = 1 << 7,    // Method #8.
  OPEN_METHOD9 = 1 << 8,    // Method #9.
  OPEN_METHOD10 = 1 << 9,   // Method #10.
  OPEN_METHOD11 = 1 << 10,  // Method #11.
  OPEN_METHOD12 = 1 << 11,  // Method #12.
};

/* Enumeration for strategy actions. */
enum ENUM_STRATEGY_ACTION {
  STRAT_ACTION_DISABLE = 0,  // Disables strategy.
  STRAT_ACTION_ENABLE,       // Enables strategy.
  STRAT_ACTION_SUSPEND,      // Suspend Strategy.
  STRAT_ACTION_TRADE_EXE,    // Execute trade action.
  STRAT_ACTION_UNSUSPEND,    // Unsuspend Strategy.
  FINAL_STRATEGY_ACTION_ENTRY
};

/* Enumeration for strategy conditions. */
enum ENUM_STRATEGY_CONDITION {
  STRAT_COND_IS_ENABLED = 1,  // Strategy is enabled.
  STRAT_COND_IS_SUSPENDED,    // Strategy is suspended.
  STRAT_COND_IS_TREND,        // Strategy is in trend.
  STRAT_COND_SIGNALOPEN,      // On strategy's signal to open.
  STRAT_COND_TRADE_COND,      // On strategy's trade condition (args).
  FINAL_STRATEGY_CONDITION_ENTRY
};

// Defines enumeration for strategy parameters.
enum ENUM_STRATEGY_PARAM {
  STRAT_PARAM_ID,          // ID (magic number)
  STRAT_PARAM_LS,          // Lot size
  STRAT_PARAM_LSF,         // Lot size factor
  STRAT_PARAM_MAX_RISK,    // Max risk
  STRAT_PARAM_MAX_SPREAD,  // Max spread
  STRAT_PARAM_OCL,         // Order close loss
  STRAT_PARAM_OCP,         // Order close profit
  STRAT_PARAM_OCT,         // Order close time
  STRAT_PARAM_PPL,         // Signal profit level
  STRAT_PARAM_PPM,         // Signal profit method
  STRAT_PARAM_PSL,         // Price stop level
  STRAT_PARAM_PSM,         // Price stop method
  STRAT_PARAM_SCFM,        // Signal close filter method
  STRAT_PARAM_SCFT,        // Signal close filter time
  STRAT_PARAM_SCL,         // Signal close level
  STRAT_PARAM_SCM,         // Signal close method
  STRAT_PARAM_SHIFT,       // Shift
  STRAT_PARAM_SOB,         // Signal open boost method
  STRAT_PARAM_SOFM,        // Signal open filter method
  STRAT_PARAM_SOFT,        // Signal open filter time
  STRAT_PARAM_SOL,         // Signal open level
  STRAT_PARAM_SOM,         // Signal open method
  STRAT_PARAM_TF,          // Timeframe
  STRAT_PARAM_TFM,         // Tick filter method
  STRAT_PARAM_TYPE,        // Type
  STRAT_PARAM_WEIGHT,      // Weight
  FINAL_ENUM_STRATEGY_PARAM
};

/* Enumeration for strategy periodical statistics. */
enum ENUM_STRATEGY_STATS_PERIOD {
  EA_STATS_DAILY,
  EA_STATS_WEEKLY,
  EA_STATS_MONTHLY,
  EA_STATS_TOTAL,
  FINAL_ENUM_STRATEGY_STATS_PERIOD
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Strategy.enum.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Task.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Action.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: EA.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Action.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Action.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.enum.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: Market.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indicator.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Trade.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Trade's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Trade actions.
enum ENUM_TRADE_ACTION {
  TRADE_ACTION_CALC_LOT_SIZE = 1,            // Recalculate lot size
  TRADE_ACTION_ORDER_CLOSE_LEAST_LOSS,       // Close order with least loss
  TRADE_ACTION_ORDER_CLOSE_LEAST_PROFIT,     // Close order with least profit
  TRADE_ACTION_ORDER_CLOSE_MOST_LOSS,        // Close order with most loss
  TRADE_ACTION_ORDER_CLOSE_MOST_PROFIT,      // Close order with most profit
  TRADE_ACTION_ORDER_OPEN,                   // Open order
  TRADE_ACTION_ORDERS_CLOSE_ALL,             // Close open sell orders
  TRADE_ACTION_ORDERS_CLOSE_BY_TYPE,         // Close open orders by type (args)
  TRADE_ACTION_ORDERS_CLOSE_IN_PROFIT,       // Close open orders in profit
  TRADE_ACTION_ORDERS_CLOSE_IN_TREND,        // Close open orders in trend
  TRADE_ACTION_ORDERS_CLOSE_IN_TREND_NOT,    // Close open orders NOT in trend
  TRADE_ACTION_ORDERS_CLOSE_SIDE_IN_LOSS,    // Close orders in loss side
  TRADE_ACTION_ORDERS_CLOSE_SIDE_IN_PROFIT,  // Close orders in profit side
  // TRADE_ACTION_ORDERS_REMOVE_ALL_PENDING,
  TRADE_ACTION_ORDERS_LIMIT_SET,  // Set orders per period limit
  TRADE_ACTION_STATE_ADD,         // Add trade specific state (1 arg)
  FINAL_ENUM_TRADE_ACTION_ENTRY
};

// Trade conditions.
enum ENUM_TRADE_CONDITION {
  TRADE_COND_ACCOUNT = 1,            // Account condition (1 arg)
  TRADE_COND_ALLOWED_NOT,            // When trade is not allowed
  TRADE_COND_HAS_STATE,              // Trade as specific state (1 arg)
  TRADE_COND_IS_ORDER_LIMIT,         // Trade has reached order limits
  TRADE_COND_IS_PEAK,                // Market is at peak level
  TRADE_COND_IS_PIVOT,               // Market is in pivot levels
  TRADE_COND_ORDERS_PROFIT_GT_01PC,  // Equity > 1%
  TRADE_COND_ORDERS_PROFIT_LT_01PC,  // Equity < 1%
  TRADE_COND_ORDERS_PROFIT_GT_02PC,  // Equity > 2%
  TRADE_COND_ORDERS_PROFIT_LT_02PC,  // Equity < 2%
  TRADE_COND_ORDERS_PROFIT_GT_05PC,  // Equity > 5%
  TRADE_COND_ORDERS_PROFIT_LT_05PC,  // Equity < 5%
  TRADE_COND_ORDERS_PROFIT_GT_10PC,  // Equity > 10%
  TRADE_COND_ORDERS_PROFIT_LT_10PC,  // Equity < 10%
  // TRADE_ORDER_CONDS_IN_TREND       = 2, // Open orders with trend
  // TRADE_ORDER_CONDS_IN_TREND_NOT   = 3, // Open orders against trend
  FINAL_ENUM_TRADE_CONDITION_ENTRY = 4
};

// Defines enumeration for trade parameters.
enum ENUM_TRADE_PARAM {
  TRADE_PARAM_BARS_MIN = 0,   // Bars minimum
  TRADE_PARAM_LOT_SIZE,       // Lot size
  TRADE_PARAM_MAGIC_NO,       // Magic number
  TRADE_PARAM_ORDER_COMMENT,  // Order comment
  TRADE_PARAM_RISK_MARGIN,    // Risk margin
  TRADE_PARAM_SLIPPAGE,       // Slippage
  FINAL_ENUM_TRADE_PARAM
};

// Defines enumeration for stat periods.
enum ENUM_TRADE_STAT_PERIOD {
  TRADE_STAT_ALL = 0,        // Stats for all periods
  TRADE_STAT_PER_HOUR = 1,   // Stats per hour
  TRADE_STAT_PER_DAY = 2,    // Stats per day
  TRADE_STAT_PER_WEEK = 3,   // Stats per week
  TRADE_STAT_PER_MONTH = 4,  // Stats per month
  TRADE_STAT_PER_YEAR = 5,   // Stats per year
  FINAL_ENUM_TRADE_STAT_PERIOD
};

// Defines enumeration for stat types.
enum ENUM_TRADE_STAT_TYPE {
  TRADE_STAT_ORDERS_CLOSED = 0,             // Orders closed
  TRADE_STAT_ORDERS_CLOSED_WINS = 1,        // Orders closed wins
  TRADE_STAT_ORDERS_ERRORS = 2,             // Orders with errors
  TRADE_STAT_ORDERS_OPENED = 3,             // Orders opened
  TRADE_STAT_ORDERS_PENDING_DELETED = 4,    // Pending orders deleted
  TRADE_STAT_ORDERS_PENDING_OPENED = 5,     // Pending orders opened
  TRADE_STAT_ORDERS_PENDING_TRIGGERED = 6,  // Pending orders triggered
  FINAL_ENUM_TRADE_STAT_TYPE
};

// Trade state.
enum ENUM_TRADE_STATE {
  TRADE_STATE_NONE = 0 << 0,                      // None
  TRADE_STATE_BARS_NOT_ENOUGH = 1 << 0,           // Not enough bars to trade
  TRADE_STATE_HEDGE_NOT_ALLOWED = 1 << 1,         // Hedging not allowed by broker
  TRADE_STATE_MARGIN_MAX_HARD = 1 << 2,           // Hard limit of trade margin reached
  TRADE_STATE_MARGIN_MAX_SOFT = 1 << 3,           // Soft limit of trade margin reached
  TRADE_STATE_MARKET_CLOSED = 1 << 4,             // Trade market closed
  TRADE_STATE_MONEY_NOT_ENOUGH = 1 << 5,          // Not enough money to trade
  TRADE_STATE_ORDERS_ACTIVE = 1 << 6,             // There are active orders
  TRADE_STATE_ORDERS_MAX_HARD = 1 << 7,           // Soft limit of maximum orders reached
  TRADE_STATE_ORDERS_MAX_SOFT = 1 << 8,           // Hard limit of maximum orders reached
  TRADE_STATE_PERIOD_LIMIT_REACHED = 1 << 9,      // Per period limit reached
  TRADE_STATE_SPREAD_TOO_HIGH = 1 << 10,          // Spread too high
  TRADE_STATE_TRADE_NOT_ALLOWED = 1 << 11,        // Trade not allowed
  TRADE_STATE_TRADE_NOT_POSSIBLE = 1 << 12,       // Trade not possible
  TRADE_STATE_TRADE_TERMINAL_BUSY = 1 << 13,      // Terminal context busy
  TRADE_STATE_TRADE_TERMINAL_OFFLINE = 1 << 14,   // Terminal offline
  TRADE_STATE_TRADE_TERMINAL_SHUTDOWN = 1 << 15,  // Terminal is shutting down
  // Pre-defined trade state enumerations.
  TRADE_STATE_TRADE_CANNOT = TRADE_STATE_MARGIN_MAX_HARD | TRADE_STATE_ORDERS_MAX_HARD | TRADE_STATE_MARKET_CLOSED |
                             TRADE_STATE_MONEY_NOT_ENOUGH | TRADE_STATE_TRADE_NOT_ALLOWED |
                             TRADE_STATE_TRADE_NOT_POSSIBLE | TRADE_STATE_TRADE_TERMINAL_BUSY |
                             TRADE_STATE_TRADE_TERMINAL_OFFLINE | TRADE_STATE_TRADE_TERMINAL_SHUTDOWN,
  TRADE_STATE_TRADE_SHOULDNT = TRADE_STATE_BARS_NOT_ENOUGH | TRADE_STATE_MARGIN_MAX_SOFT | TRADE_STATE_ORDERS_MAX_SOFT |
                               TRADE_STATE_PERIOD_LIMIT_REACHED | TRADE_STATE_SPREAD_TOO_HIGH,
  TRADE_STATE_TRADE_WONT = TRADE_STATE_TRADE_CANNOT | TRADE_STATE_TRADE_SHOULDNT,
  TRADE_STATE_TRADE_CAN = ~TRADE_STATE_TRADE_CANNOT,
  FINAL_ENUM_TRADE_STATE,
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Trade.enum.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Account.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Strategy.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: EA.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes EA's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Defines EA input data types. */
enum ENUM_EA_DATA_STORE_TYPE {
  EA_DATA_STORE_NONE = 0 << 0,
  EA_DATA_STORE_CHART = 1 << 0,      // Chart data (OHCL).
  EA_DATA_STORE_INDICATOR = 1 << 1,  // Indicator data.
  EA_DATA_STORE_STRATEGY = 1 << 2,   // Strategy data.
  EA_DATA_STORE_SYMBOL = 1 << 3,     // Symbol data (tick).
  EA_DATA_STORE_TRADE = 1 << 4,      // Trade data.
  EA_DATA_STORE_ALL = (1 << 5) - 1,  // All data to store.
};

/* Defines EA data export methods. */
enum ENUM_EA_DATA_EXPORT_METHOD {
  EA_DATA_EXPORT_NONE = 0 << 0,       // (None)
  EA_DATA_EXPORT_CSV = 1 << 0,        // CSV file
  EA_DATA_EXPORT_DB = 1 << 1,         // Database (SQLite)
  EA_DATA_EXPORT_JSON = 1 << 2,       // JSON file
  EA_DATA_EXPORT_ALL = (1 << 3) - 1,  // All
};

/* Defines EA state flags. */
enum ENUM_EA_PARAM_FLAGS {
  EA_PARAM_FLAG_NONE = 0 << 0,           // None flags.
  EA_PARAM_FLAG_LOTSIZE_AUTO = 1 << 0,   // Auto calculate lot size.
  EA_PARAM_FLAG_REPORT_EXPORT = 1 << 1,  // Export report on exit.
  EA_PARAM_FLAG_REPORT_PRINT = 1 << 2,   // Print report on exit.
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: EA.enum.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Action.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Task.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Task's enums.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

/* Structure for task actions for Action class. */
enum ENUM_TASK_ACTION {
  TASK_ACTION_NONE = 0,  // Does nothing.
  TASK_ACTION_PROCESS,   // Process tasks.
  FINAL_TASK_ACTION_ENTRY
};

/* Structure for task conditions for Action class. */
enum ENUM_TASK_CONDITION {
  TASK_COND_NONE = 0,     // Empty condition.
  TASK_COND_IS_ACTIVE,    // Is active.
  TASK_COND_IS_DONE,      // Is done.
  TASK_COND_IS_FAILED,    // Is failed.
  TASK_COND_IS_FINISHED,  // Is finished.
  TASK_COND_IS_INVALID,   // Is invalid.
  FINAL_TASK_CONDITION_ENTRY
};

/* Structure for task entry flags. */
enum ENUM_TASK_ENTRY_FLAGS {
  TASK_ENTRY_FLAG_NONE = 0,
  TASK_ENTRY_FLAG_IS_ACTIVE = 1,
  TASK_ENTRY_FLAG_IS_DONE = 2,
  TASK_ENTRY_FLAG_IS_EXPIRED = 4,
  TASK_ENTRY_FLAG_IS_FAILED = 8,
  TASK_ENTRY_FLAG_IS_INVALID = 16
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Task.enum.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Includes Action's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.






//






/* Entry for Action class. */
struct ActionEntry {
  unsigned char flags;   /* Action flags. */
  datetime last_success; /* Time of the previous check. */
  int frequency;         /* How often to check. */
  long action_id;        /* Action ID. */
  short tries;           /* Number of retries left. */
  void *obj;             /* Reference to associated object. */
  ENUM_ACTION_TYPE type; /* Action type. */
  DataParamEntry args[]; /* Action arguments. */
  // Constructors.
  ActionEntry() : type(FINAL_ACTION_TYPE_ENTRY), action_id(WRONG_VALUE) { Init(); }
  ActionEntry(long _action_id, ENUM_ACTION_TYPE _type) : type(_type), action_id(_action_id) { Init(); }
  ActionEntry(ActionEntry &_ae) { this = _ae; }
  ActionEntry(ENUM_EA_ACTION _action_id) : type(ACTION_TYPE_EA), action_id(_action_id) { Init(); }
  ActionEntry(ENUM_ORDER_ACTION _action_id) : type(ACTION_TYPE_ORDER), action_id(_action_id) { Init(); }
  ActionEntry(ENUM_INDICATOR_ACTION _action_id) : type(ACTION_TYPE_INDICATOR), action_id(_action_id) { Init(); }
  ActionEntry(ENUM_STRATEGY_ACTION _action_id) : type(ACTION_TYPE_STRATEGY), action_id(_action_id) { Init(); }
  ActionEntry(ENUM_TASK_ACTION _action_id) : type(ACTION_TYPE_TASK), action_id(_action_id) { Init(); }
  ActionEntry(ENUM_TRADE_ACTION _action_id) : type(ACTION_TYPE_TRADE), action_id(_action_id) { Init(); }
  // Deconstructor.
  ~ActionEntry() {
    // Object::Delete(obj);
  }
  // Flag methods.
  bool HasFlag(unsigned char _flag) { return bool(flags & _flag); }
  void AddFlags(unsigned char _flags) { flags |= _flags; }
  void RemoveFlags(unsigned char _flags) { flags &= ~_flags; }
  void SetFlag(ENUM_ACTION_ENTRY_FLAGS _flag, bool _value) {
    if (_value)
      AddFlags(_flag);
    else
      RemoveFlags(_flag);
  }
  void SetFlags(unsigned char _flags) { flags = _flags; }
  // State methods.
  bool IsActive() { return HasFlag(ACTION_ENTRY_FLAG_IS_ACTIVE); }
  bool IsDone() { return HasFlag(ACTION_ENTRY_FLAG_IS_DONE); }
  bool IsFailed() { return HasFlag(ACTION_ENTRY_FLAG_IS_FAILED); }
  bool IsInvalid() { return HasFlag(ACTION_ENTRY_FLAG_IS_INVALID); }
  bool IsValid() { return !IsInvalid(); }
  // Getters.
  long GetId() { return action_id; }
  ENUM_ACTION_TYPE GetType() { return type; }
  // Setter methods.
  void AddArg(MqlParam &_arg) {
    // @todo: Add another value to args[].
  }
  void Init() {
    flags = ACTION_ENTRY_FLAG_NONE;
    frequency = 60;
    SetFlag(ACTION_ENTRY_FLAG_IS_ACTIVE, action_id != WRONG_VALUE);
    SetFlag(ACTION_ENTRY_FLAG_IS_INVALID, action_id == WRONG_VALUE);
    last_success = 0;
    tries = 1;
  }
  void SetArgs(ARRAY_REF(MqlParam, _args)) {
    // @todo: for().
  }
  void SetObject(void *_obj) { obj = _obj; }
  void SetTries(short _count) { tries = _count; }

  SerializerNodeType Serialize(Serializer &s) {
    s.Pass(THIS_REF, "flags", flags);
    s.Pass(THIS_REF, "last_success", last_success);
    s.Pass(THIS_REF, "action_id", action_id);
    //  s.Pass(THIS_REF, "tries", tries);
    s.PassEnum(THIS_REF, "type", type);
    s.PassEnum(THIS_REF, "frequency", frequency);
    s.PassArray(this, "args", args);
    return SerializerNodeObject;
  }

  SERIALIZER_EMPTY_STUB;
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Action.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Condition.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Provides integration with actions.
 */

// Prevents processing this includes file for the second time.
#ifndef ACTION_MQH
#define ACTION_MQH

// Forward class declaration.
class Action;

// Includes.





/**
 * Action class.
 */
class Action {
 public:
 protected:
  // Class variables.
  Ref<Log> logger;

 public:
  // Class variables.
  DictStruct<short, ActionEntry> actions;

  /* Special methods */

  /**
   * Class constructor.
   */
  Action() {}
  Action(ActionEntry &_entry) { actions.Push(_entry); }
  Action(long _action_id, ENUM_ACTION_TYPE _type) {
    ActionEntry _entry(_action_id, _type);
    actions.Push(_entry);
  }
  template <typename T>
  Action(T _action_id, void *_obj = NULL) {
    ActionEntry _entry(_action_id);
    if (_obj != NULL) {
      _entry.SetObject(_obj);
    }
    actions.Push(_entry);
  }
  template <typename T>
  Action(T _action_id, MqlParam &_args[], void *_obj = NULL) {
    ActionEntry _entry(_action_id);
    _entry.SetArgs(_args);
    if (_obj != NULL) {
      _entry.SetObject(_obj);
    }
    actions.Push(_entry);
  }

  /**
   * Class copy constructor.
   */
  Action(Action &_cond) { actions = _cond.GetActions(); }

  /* Main methods */

  /**
   * Execute actions.
   */
  bool Execute() {
    bool _result = true, _executed = false;
    for (DictStructIterator<short, ActionEntry> iter = actions.Begin(); iter.IsValid(); ++iter) {
      bool _curr_result = false;
      ActionEntry _entry = iter.Value();
      if (!_entry.IsValid()) {
        // Ignore invalid entries.
        continue;
      }
      if (_entry.IsActive()) {
        _executed = _result &= Execute(_entry);
      }
    }
    return _result && _executed;
  }

  /**
   * Execute specific action.
   */
  static bool Execute(ActionEntry &_entry) {
    bool _result = false;
    switch (_entry.type) {
      case ACTION_TYPE_ACTION:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Action *)_entry.obj).ExecuteAction((ENUM_ACTION_ACTION)_entry.action_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
      case ACTION_TYPE_EA:
        if (Object::IsValid(_entry.obj)) {
          _result = ((EA *)_entry.obj).ExecuteAction((ENUM_EA_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#ifdef ORDER_MQH
      case ACTION_TYPE_ORDER:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Order *)_entry.obj).ExecuteAction((ENUM_ORDER_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
#ifdef INDICATOR_MQH
      case ACTION_TYPE_INDICATOR:
        if (Object::IsValid(_entry.obj)) {
          _result = ((IndicatorBase *)_entry.obj).ExecuteAction((ENUM_INDICATOR_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
#ifdef STRATEGY_MQH
      case ACTION_TYPE_STRATEGY:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Strategy *)_entry.obj).ExecuteAction((ENUM_STRATEGY_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
#ifdef TASK_MQH
      case ACTION_TYPE_TASK:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Task *)_entry.obj).ExecuteAction((ENUM_TASK_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
      case ACTION_TYPE_TRADE:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Trade *)_entry.obj).ExecuteAction((ENUM_TRADE_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#ifdef TERMINAL_MQH
      case ACTION_TYPE_TERMINAL:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Terminal *)_entry.obj).ExecuteAction((ENUM_TERMINAL_ACTION)_entry.action_id);
        } else {
          _result = false;
          _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
    }
    if (_result) {
      _entry.AddFlags(ACTION_ENTRY_FLAG_IS_DONE);
      _entry.RemoveFlags(ACTION_ENTRY_FLAG_IS_ACTIVE);
      _entry.last_success = TimeCurrent();
    } else {
      if (--_entry.tries <= 0) {
        _entry.AddFlags(ACTION_ENTRY_FLAG_IS_INVALID);
        _entry.RemoveFlags(ACTION_ENTRY_FLAG_IS_ACTIVE);
      }
    }
    return _result;
  }

  /* State methods */

  /**
   * Check if action is active.
   */
  bool IsActive() {
    // The whole action is active when at least one action is active.
    return GetFlagCount(ACTION_ENTRY_FLAG_IS_ACTIVE) > 0;
  }

  /**
   * Check if action is done.
   */
  bool IsDone() {
    // The whole action is done when all actions has been executed successfully.
    return GetFlagCount(ACTION_ENTRY_FLAG_IS_DONE) == actions.Size();
  }

  /**
   * Check if action has failed.
   */
  bool IsFailed() {
    // The whole action is failed when at least one action failed.
    return GetFlagCount(ACTION_ENTRY_FLAG_IS_FAILED) > 0;
  }

  /**
   * Check if action is finished.
   */
  bool IsFinished() {
    // The whole action is finished when there are no more active actions.
    return GetFlagCount(ACTION_ENTRY_FLAG_IS_ACTIVE) == 0;
  }

  /**
   * Check if action is invalid.
   */
  bool IsInvalid() {
    // The whole action is invalid when at least one action is invalid.
    return GetFlagCount(ACTION_ENTRY_FLAG_IS_INVALID) > 0;
  }

  /* Getters */

  /**
   * Returns actions.
   */
  DictStruct<short, ActionEntry> *GetActions() { return &actions; }

  /**
   * Count entry flags.
   */
  unsigned int GetFlagCount(ENUM_ACTION_ENTRY_FLAGS _flag) {
    unsigned int _counter = 0;
    for (DictStructIterator<short, ActionEntry> iter = actions.Begin(); iter.IsValid(); ++iter) {
      ActionEntry _entry = iter.Value();
      if (_entry.HasFlag(_flag)) {
        _counter++;
      }
    }
    return _counter;
  }

  /* Setters */

  /**
   * Sets entry flags.
   */
  bool SetFlags(ENUM_ACTION_ENTRY_FLAGS _flag, bool _value = true) {
    unsigned int _counter = 0;
    for (DictStructIterator<short, ActionEntry> iter = actions.Begin(); iter.IsValid(); ++iter) {
      ActionEntry _entry = iter.Value();
      switch (_value) {
        case false:
          if (_entry.HasFlag(_flag)) {
            _entry.SetFlag(_flag, _value);
            _counter++;
          }
          break;
        case true:
          if (!_entry.HasFlag(_flag)) {
            _entry.SetFlag(_flag, _value);
            _counter++;
          }
          break;
      }
    }
    return _counter > 0;
  }

  /* Conditions and actions */

  /**
   * Checks for Task condition.
   *
   * @param ENUM_ACTION_CONDITION _cond
   *   Action condition.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_ACTION_CONDITION _cond, DataParamEntry &_args[]) {
    bool _result = false;
    switch (_cond) {
      case ACTION_COND_IS_ACTIVE:
        // Is active;
        return IsActive();
      case ACTION_COND_IS_DONE:
        // Is done.
        return IsDone();
      case ACTION_COND_IS_FAILED:
        // Is failed.
        return IsFailed();
      case ACTION_COND_IS_FINISHED:
        // Is finished.
        return IsFinished();
      case ACTION_COND_IS_INVALID:
        // Is invalid.
        return IsInvalid();
      default:
        logger.Ptr().Error(StringFormat("Invalid Action condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
        break;
    }
    return _result;
  }
  bool CheckCondition(ENUM_ACTION_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Action::CheckCondition(_cond, _args);
  }

  /**
   * Execute action of action.
   *
   * @param ENUM_ACTION_ACTION _action
   *   Action of action to execute.
   * @return
   *   Returns true when the action has been executed successfully.
   */
  bool ExecuteAction(ENUM_ACTION_ACTION _action, DataParamEntry &_args[]) {
    bool _result = false;
    switch (_action) {
      case ACTION_ACTION_DISABLE:
        // Disable action.
        return SetFlags(ACTION_ENTRY_FLAG_IS_ACTIVE, false);
      case ACTION_ACTION_EXECUTE:
        // Execute action.
        return Execute();
      case ACTION_ACTION_MARK_AS_DONE:
        // Marks as done.
        return SetFlags(ACTION_ENTRY_FLAG_IS_DONE);
      case ACTION_ACTION_MARK_AS_FAILED:
        // Mark as failed.
        return SetFlags(ACTION_ENTRY_FLAG_IS_FAILED);
      case ACTION_ACTION_MARK_AS_FINISHED:
        // Mark as finished.
        return SetFlags(ACTION_ENTRY_FLAG_IS_ACTIVE, false);
      case ACTION_ACTION_MARK_AS_INVALID:
        // Mark as invalid.
        return SetFlags(ACTION_ENTRY_FLAG_IS_INVALID);
      default:
        logger.Ptr().Error(StringFormat("Invalid action of action: %s!", EnumToString(_action), __FUNCTION_LINE__));
        break;
    }
    return _result;
  }
  bool ExecuteAction(ENUM_ACTION_ACTION _action) {
    ARRAY(DataParamEntry, _args);
    return Action::ExecuteAction(_action, _args);
  }

  /* Other methods */
};

#endif  // ACTION_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Action.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictStruct.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Task.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Refs.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Condition.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Condition.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.enum.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: Market.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indicator.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Trade.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Account.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Strategy.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: EA.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Task.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 *  This file is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Includes Condition's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.





//





struct ConditionEntry {
  unsigned char flags;                      // Condition flags.
  datetime last_check;                      // Time of the latest check.
  datetime last_success;                    // Time of the last success.
  int frequency;                            // How often to check.
  long cond_id;                             // Condition ID.
  short tries;                              // Number of successful tries left.
  void *obj;                                // Reference to associated object.
  ENUM_CONDITION_STATEMENT next_statement;  // Statement type of the next condition.
  ENUM_CONDITION_TYPE type;                 // Condition type.
  DataParamEntry args[];                    // Condition arguments.
  // Constructors.
  void ConditionEntry() : type(FINAL_CONDITION_TYPE_ENTRY), cond_id(WRONG_VALUE) { Init(); }
  void ConditionEntry(long _cond_id, ENUM_CONDITION_TYPE _type) : type(_type), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ConditionEntry &_ce) { this = _ce; }
  void ConditionEntry(ENUM_ACCOUNT_CONDITION _cond_id) : type(COND_TYPE_ACCOUNT), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_CHART_CONDITION _cond_id) : type(COND_TYPE_CHART), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_DATETIME_CONDITION _cond_id) : type(COND_TYPE_DATETIME), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_EA_CONDITION _cond_id) : type(COND_TYPE_EA), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_INDICATOR_CONDITION _cond_id) : type(COND_TYPE_INDICATOR), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_MARKET_CONDITION _cond_id) : type(COND_TYPE_MARKET), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_ORDER_CONDITION _cond_id) : type(COND_TYPE_ORDER), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_STRATEGY_CONDITION _cond_id) : type(COND_TYPE_STRATEGY), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_TASK_CONDITION _cond_id) : type(COND_TYPE_TASK), cond_id(_cond_id) { Init(); }
  void ConditionEntry(ENUM_TRADE_CONDITION _cond_id) : type(COND_TYPE_TRADE), cond_id(_cond_id) { Init(); }
  // Deconstructor.
  void ~ConditionEntry() {
    // Object::Delete(obj);
  }
  // Flag methods.
  bool HasFlag(unsigned char _flag) { return bool(flags & _flag); }
  void AddFlags(unsigned char _flags) { flags |= _flags; }
  void RemoveFlags(unsigned char _flags) { flags &= ~_flags; }
  void SetFlag(ENUM_CONDITION_ENTRY_FLAGS _flag, bool _value) {
    if (_value)
      AddFlags(_flag);
    else
      RemoveFlags(_flag);
  }
  void SetFlags(unsigned char _flags) { flags = _flags; }
  // State methods.
  bool IsActive() { return HasFlag(COND_ENTRY_FLAG_IS_ACTIVE); }
  bool IsExpired() { return HasFlag(COND_ENTRY_FLAG_IS_EXPIRED); }
  bool IsReady() { return HasFlag(COND_ENTRY_FLAG_IS_READY); }
  bool IsInvalid() { return HasFlag(COND_ENTRY_FLAG_IS_INVALID); }
  bool IsValid() { return !IsInvalid(); }
  // Getters.
  long GetId() { return cond_id; }
  ENUM_CONDITION_TYPE GetType() { return type; }
  // Setters.
  void AddArg(MqlParam &_arg) {
    // @todo: Add another value to args[].
  }
  void Init() {
    flags = COND_ENTRY_FLAG_NONE;
    frequency = 60;
    SetFlag(COND_ENTRY_FLAG_IS_ACTIVE, cond_id != WRONG_VALUE);
    SetFlag(COND_ENTRY_FLAG_IS_INVALID, cond_id == WRONG_VALUE);
    last_check = last_success = 0;
    next_statement = COND_AND;
    tries = 1;
  }
  void SetArgs(MqlParam &_args[]) {
    // @todo: for().
  }
  void SetObject(void *_obj) { obj = _obj; }
  void SetTries(short _count) { tries = _count; }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Condition.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Account.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Data.struct.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Account.struct.h
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Account's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once

#endif

// Forward class declaration.
class Serializer;

// Includes.


// Struct for account entries.
struct AccountEntry {
  datetime dtime;
  double balance;
  double credit;
  double equity;
  double profit;
  double margin_used;
  double margin_free;
  double margin_avail;
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer& _s) {
    _s.Pass(THIS_REF, "time", dtime, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "balance", balance, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "credit", credit, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "equity", equity, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "profit", profit, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "margin_used", margin_used, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "margin_free", margin_free, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "margin_avail", margin_avail, SERIALIZER_FIELD_FLAG_DYNAMIC);
    return SerializerNodeObject;
  }
  /* Getters */
  double Get(ENUM_ACCOUNT_INFO_DOUBLE _param) {
    switch (_param) {
      case ACCOUNT_BALANCE:
        // Account balance in the deposit currency (double).
        return balance;
      case ACCOUNT_CREDIT:
        // Account credit in the deposit currency (double).
        return credit;
      case ACCOUNT_PROFIT:
        // Current profit of an account in the deposit currency (double).
        return profit;
      case ACCOUNT_EQUITY:
        // Account equity in the deposit currency (double).
        return equity;
      case ACCOUNT_MARGIN:
        // Account margin used in the deposit currency (double).
        return margin_used;
      case ACCOUNT_MARGIN_FREE:
        // Free margin of an account in the deposit currency (double).
        return margin_free;
      case ACCOUNT_MARGIN_LEVEL:
        // Account margin level in percents (double).
        return margin_avail;
      default:
        break;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Account.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Account.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Trade.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Trade.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Trade's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward declarations.
struct TradeStats;

// Includes.



/* Structure for trade parameters. */
struct TradeParams {
  float lot_size;        // Default lot size.
  float risk_margin;     // Maximum account margin to risk (in %).
  string order_comment;  // Order comment.
  unsigned int limits_stats[FINAL_ENUM_TRADE_STAT_TYPE][FINAL_ENUM_TRADE_STAT_PERIOD];
  unsigned int slippage;     // Value of the maximum price slippage in points.
  unsigned long magic_no;    // Unique magic number used for the trading.
  unsigned short bars_min;   // Minimum bars to trade.
  ENUM_LOG_LEVEL log_level;  // Log verbosity level.
  // Constructors.
  TradeParams(float _lot_size = 0, float _risk_margin = 1.0, unsigned int _slippage = 50)
      : bars_min(100),
        order_comment(""),
        lot_size(_lot_size),
        magic_no(rand()),
        risk_margin(_risk_margin),
        slippage(_slippage) {
    SetLimits(0);
  }
  TradeParams(unsigned long _magic_no, ENUM_LOG_LEVEL _ll = V_INFO)
      : bars_min(100), lot_size(0), order_comment(""), log_level(_ll), magic_no(_magic_no) {}
  TradeParams(TradeParams &_tparams) { this = _tparams; }
  // Deconstructor.
  ~TradeParams() {}
  // Getters.
  template <typename T>
  T Get(ENUM_TRADE_PARAM _param) {
    switch (_param) {
      case TRADE_PARAM_BARS_MIN:
        return (T)bars_min;
      case TRADE_PARAM_LOT_SIZE:
        return (T)lot_size;
      case TRADE_PARAM_MAGIC_NO:
        return (T)magic_no;
      case TRADE_PARAM_ORDER_COMMENT:
        return (T)order_comment;
      case TRADE_PARAM_RISK_MARGIN:
        return (T)risk_margin;
      case TRADE_PARAM_SLIPPAGE:
        return (T)slippage;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
  float GetRiskMargin() { return risk_margin; }
  unsigned int GetLimits(ENUM_TRADE_STAT_TYPE _type, ENUM_TRADE_STAT_PERIOD _period) {
    return limits_stats[(int)_type][(int)_period];
  }
  unsigned short GetBarsMin() { return bars_min; }
  // State checkers.
  bool IsLimitGe(ENUM_TRADE_STAT_TYPE _type, ARRAY_REF(unsigned int, _value)) {
    // Is limit greater or equal than given value for given array of types.
    for (int p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
      if (_value[p] > 0 && IsLimitGe(_type, (ENUM_TRADE_STAT_PERIOD)p, _value[p])) {
        return true;
      }
    }
    return false;
  }
  bool IsLimitGe(ENUM_TRADE_STAT_TYPE _type, ENUM_TRADE_STAT_PERIOD _period, unsigned int _value) {
    // Is limit greater or equal than given value for given type and period.
#ifdef __debug__
    Print("Checking for trade limit. Limit for type ", EnumToString(_type), " and period ", EnumToString(_period),
          " is ", limits_stats[_type][_period], ". Current trades = ", _value);
#endif
    return limits_stats[(int)_type][(int)_period] > 0 && _value >= limits_stats[(int)_type][(int)_period];
  }
  bool IsLimitGe(TradeStats &_stats) {
    // @todo: Improve code performance.
    for (ENUM_TRADE_STAT_TYPE t = 0; t < FINAL_ENUM_TRADE_STAT_TYPE; t++) {
      for (ENUM_TRADE_STAT_PERIOD p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
        unsigned int _stat_value = _stats.GetOrderStats(t, p);
        if (_stat_value > 0 && IsLimitGe(t, p, _stat_value)) {
          return true;
        }
      }
    }
    return false;
  }
  // Setters.
  template <typename T>
  void Set(ENUM_TRADE_PARAM _param, T _value) {
    switch (_param) {
      case TRADE_PARAM_BARS_MIN:
        bars_min = (unsigned short)_value;
        return;
      case TRADE_PARAM_LOT_SIZE:
        lot_size = (float)_value;
        return;
      case TRADE_PARAM_MAGIC_NO:
        magic_no = (unsigned long)_value;
        return;
      case TRADE_PARAM_ORDER_COMMENT:
        order_comment = (string)_value;
        return;
      case TRADE_PARAM_RISK_MARGIN:
        risk_margin = (float)_value;
        return;
      case TRADE_PARAM_SLIPPAGE:
        slippage = (unsigned int)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(ENUM_TRADE_PARAM _enum_param, MqlParam &_mql_param) {
    if (_mql_param.type == TYPE_DOUBLE || _mql_param.type == TYPE_FLOAT) {
      Set(_enum_param, _mql_param.double_value);
    } else {
      Set(_enum_param, _mql_param.integer_value);
    }
  }
  void SetBarsMin(unsigned short _value) { bars_min = _value; }
  void SetLimits(ENUM_TRADE_STAT_TYPE _type, ENUM_TRADE_STAT_PERIOD _period, uint _value = 0) {
    // Set new trading limits for the given type and period.
#ifdef __debug__
    Print("Setting trade limit for type ", EnumToString(_type), " and period ", EnumToString(_period), " to ", _value);
#endif
    limits_stats[(int)_type][(int)_period] = _value;
  }
  void SetLimits(ENUM_TRADE_STAT_PERIOD _period, uint _value = 0) {
    // Set new trading limits for the given period.
    for (int t = 0; t < FINAL_ENUM_TRADE_STAT_TYPE; t++) {
#ifdef __debug__
      Print("Setting trade limit for type ", EnumToString((ENUM_TRADE_STAT_TYPE)t), " and period ",
            EnumToString(_period), " to ", _value);
#endif
      limits_stats[(int)t][(int)_period] = _value;
    }
  }
  void SetLimits(ENUM_TRADE_STAT_TYPE _type, uint _value = 0) {
    // Set new trading limits for the given type.
    for (ENUM_TRADE_STAT_PERIOD p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
      limits_stats[(int)_type][(int)p] = _value;
    }
  }
  void SetLimits(uint _value = 0) {
    // Set new trading limits for all types and periods.
    // Zero value is for no limits.
    for (ENUM_TRADE_STAT_TYPE t = 0; t < FINAL_ENUM_TRADE_STAT_TYPE; t++) {
      for (ENUM_TRADE_STAT_PERIOD p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
        limits_stats[(int)t][(int)p] = _value;
      }
    }
  }
  void SetLotSize(float _lot_size) { lot_size = _lot_size; }
  void SetMagicNo(unsigned long _mn) { magic_no = _mn; }
  void SetRiskMargin(float _value) { risk_margin = _value; }
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer &_s) {
    _s.Pass(THIS_REF, "lot_size", lot_size);
    _s.Pass(THIS_REF, "magic", magic_no);
    _s.Pass(THIS_REF, "risk_margin", risk_margin);
    _s.Pass(THIS_REF, "slippage", slippage);
    return SerializerNodeObject;
  }
} trade_params_defaults;

/* Structure for trade statistics. */
struct TradeStats {
  DateTime dt[FINAL_ENUM_TRADE_STAT_TYPE][FINAL_ENUM_TRADE_STAT_PERIOD];
  unsigned int order_stats[FINAL_ENUM_TRADE_STAT_TYPE][FINAL_ENUM_TRADE_STAT_PERIOD];
  // Struct constructors.
  TradeStats() { ResetStats(); }
  // Check statistics for new periods
  void Check() {}
  /* Getters */
  // Get order stats for the given type and period.
  unsigned int GetOrderStats(ENUM_TRADE_STAT_TYPE _type, ENUM_TRADE_STAT_PERIOD _period, bool _reset = true) {
#ifdef __debug__
    Print("GetOrderStats: type ", EnumToString(_type), ", period ", EnumToString(_period), ", reset = ", _reset);
#endif
    if (_reset && _period > TRADE_STAT_ALL) {
      unsigned int _periods_started = dt[(int)_type][(int)_period].GetStartedPeriods(true, false);
#ifdef __debug__
      Print("GetOrderStats: _periods_started = ", _periods_started);
#endif
      if (_periods_started >= DATETIME_HOUR) {
        ResetStats(_type, _period, _periods_started);
      }
    }
    return order_stats[(int)_type][(int)_period];
  }
  /* Setters */
  // Add value for the given type and period.
  void Add(ENUM_TRADE_STAT_TYPE _type, int _value = 1) {
    for (int p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
      order_stats[(int)_type][(int)p] += _value;
    }
  }
  /* Reset stats for the given periods. */
  void ResetStats(ENUM_TRADE_STAT_TYPE _type, ENUM_TRADE_STAT_PERIOD _period, unsigned int _periods) {
    if ((_periods & DATETIME_HOUR) != 0) {
      ResetStats(TRADE_STAT_PER_HOUR);
    }
    if ((_periods & DATETIME_DAY) != 0) {
      ResetStats(TRADE_STAT_PER_DAY);
    }
    if ((_periods & DATETIME_WEEK) != 0) {
      ResetStats(TRADE_STAT_PER_WEEK);
    }
    if ((_periods & DATETIME_MONTH) != 0) {
      ResetStats(TRADE_STAT_PER_MONTH);
    }
    if ((_periods & DATETIME_YEAR) != 0) {
      ResetStats(TRADE_STAT_PER_YEAR);
    }
  }
  /* Reset stats for the given type and period. */
  void ResetStats(ENUM_TRADE_STAT_TYPE _type, ENUM_TRADE_STAT_PERIOD _period) {
    order_stats[(int)_type][(int)_period] = 0;
  }
  /* Reset stats for the given period. */
  void ResetStats(ENUM_TRADE_STAT_PERIOD _period) {
    for (ENUM_TRADE_STAT_TYPE t = 0; t < FINAL_ENUM_TRADE_STAT_TYPE; t++) {
      order_stats[(int)t][(int)_period] = 0;
#ifdef __debug__
      Print("Resetting trade counter for type ", EnumToString(t), " and  period ", EnumToString(_period));
#endif
      dt[(int)t][(int)_period].GetStartedPeriods(true, true);
    }
  }
  /* Reset stats for the given type. */
  void ResetStats(ENUM_TRADE_STAT_TYPE _type) {
    for (ENUM_TRADE_STAT_PERIOD p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
      order_stats[(int)_type][(int)p] = 0;
#ifdef __debug__
      Print("Resetting trade counter for type ", EnumToString(_type), " and  period ", EnumToString(p));
#endif
      dt[(int)_type][(int)p].GetStartedPeriods(true, true);
    }
  }
  /* Reset all stats. */
  void ResetStats() {
    for (ENUM_TRADE_STAT_TYPE t = 0; t < FINAL_ENUM_TRADE_STAT_TYPE; t++) {
      for (ENUM_TRADE_STAT_PERIOD p = 0; p < FINAL_ENUM_TRADE_STAT_PERIOD; p++) {
        order_stats[(int)t][(int)p] = 0;
#ifdef __debug__
        Print("Resetting trade counter for type ", EnumToString(t), " and  period ", EnumToString(p));
#endif
        dt[(int)t][(int)p].GetStartedPeriods(true, true);
      }
    }
  }
};

/* Structure for trade states. */
struct TradeStates {
 protected:
  datetime last_check;
  unsigned int states;

 protected:
  // Protected methods.
  void UpdateCheck() {
    // Refresh timestamp for the last access.
    last_check = TimeCurrent();
  }

 public:
  // Struct constructor.
  TradeStates() : last_check(0), states(0) {}
  // Getters.
  bool Get(ENUM_TRADE_STATE _prop) { return CheckState(_prop); }
  int GetLastCheckDiff() { return (int)(TimeCurrent() - last_check); }
  static string GetStateMessage(ENUM_TRADE_STATE _state) {
    switch (_state) {
      case TRADE_STATE_BARS_NOT_ENOUGH:
        return "Not enough bars to trade";
      case TRADE_STATE_HEDGE_NOT_ALLOWED:
        return "Hedging not allowed by broker";
      case TRADE_STATE_MARGIN_MAX_HARD:
        return "Hard limit of trade margin reached";
      case TRADE_STATE_MARGIN_MAX_SOFT:
        return "Soft limit of trade margin reached";
      case TRADE_STATE_MARKET_CLOSED:
        return "Trade market closed";
      case TRADE_STATE_MONEY_NOT_ENOUGH:
        return "Not enough money to trade";
      case TRADE_STATE_ORDERS_ACTIVE:
        return "New orders has been placed";
      case TRADE_STATE_ORDERS_MAX_HARD:
        return "Soft limit of maximum orders reached";
      case TRADE_STATE_ORDERS_MAX_SOFT:
        return "Hard limit of maximum orders reached";
      case TRADE_STATE_PERIOD_LIMIT_REACHED:
        return "Per period limit reached";
      case TRADE_STATE_SPREAD_TOO_HIGH:
        return "Spread too high";
      case TRADE_STATE_TRADE_NOT_ALLOWED:
        return "Trade not allowed";
      case TRADE_STATE_TRADE_NOT_POSSIBLE:
        return "Trade not possible";
      case TRADE_STATE_TRADE_TERMINAL_BUSY:
        return "Terminal context busy";
      case TRADE_STATE_TRADE_TERMINAL_OFFLINE:
        return "Terminal offline";
      case TRADE_STATE_TRADE_TERMINAL_SHUTDOWN:
        return "Terminal is shutting down";
    }
    return "Unknown!";
  }
  unsigned int GetStates() {
    UpdateCheck();
    return states;
  }
  // Struct methods for bitwise operations.
  bool CheckState(unsigned int _states) { return (states & _states) != 0 || states == _states; }
  bool CheckStatesAll(unsigned int _states) { return (states & _states) == _states; }
  static bool CheckState(unsigned int _states1, unsigned int _states2) {
    return (_states2 & _states1) != 0 || _states2 == _states1;
  }
  void AddState(unsigned int _states) { states |= _states; }
  void RemoveState(unsigned int _states) { states &= ~_states; }
  void SetState(ENUM_TRADE_STATE _state, bool _value = true) {
    if (_value) {
      AddState(_state);
    } else {
      RemoveState(_state);
    }
  }
  void SetState(unsigned int _states) { states = _states; }
  // Serializers.
  void SerializeStub(int _n1 = 1, int _n2 = 1, int _n3 = 1, int _n4 = 1, int _n5 = 1) {}
  SerializerNodeType Serialize(Serializer &_s) {
    int _size = sizeof(int) * 8;
    for (int i = 0; i < _size; i++) {
      int _value = CheckState(1 << i) ? 1 : 0;
      _s.Pass(THIS_REF, (string)(i + 1), _value, SERIALIZER_FIELD_FLAG_DYNAMIC);
    }
    return SerializerNodeObject;
  }
};

// Structure for trade static methods.
struct TradeStatic {
  /**
   * Returns the number of active orders/positions.
   *
   * @docs
   * - https://docs.mql4.com/trading/orderstotal
   * - https://www.mql5.com/en/docs/trading/positionstotal
   *
   */
  static int TotalActive() {
#ifdef __MQL4__
    return ::OrdersTotal();
#else
    return ::PositionsTotal();
#endif
  }
};

// Structure for trade history static methods.
struct TradeHistoryStatic {
  /**
   * Returns the number of closed orders in the account history loaded into the terminal.
   */
  static int HistoryOrdersTotal() {
#ifdef __MQL4__
    return ::OrdersHistoryTotal();
#else
    ::HistorySelect(0, ::TimeCurrent());  // @todo: Use DateTimeStatic().
    return ::HistoryOrdersTotal();
#endif
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Trade.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indicator.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Orders.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Account.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Log.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Math.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Forward declarations.
class Orders;

// Includes.







/* Defines */

// Index in the order pool.
#ifndef SELECT_BY_POS
#define SELECT_BY_POS 0
#endif

// Index by the order ticket.
#ifndef SELECT_BY_TICKET
#define SELECT_BY_TICKET 1
#endif

// Delay pauses between operations.
#define TRADE_PAUSE_SHORT 500
#define TRADE_PAUSE_LONG 5000

/**
 * Class to provide methods to deal with the orders.
 */
#ifndef ORDERS_MQH

// Enums.
enum ENUM_ORDERS_POOL {
  ORDERS_POOL_TRADES = MODE_TRADES,    // Trading pool (opened and pending orders).
  ORDERS_POOL_HISTORY = MODE_HISTORY,  // History pool (closed and canceled order).
  ORDERS_POOL_DUMMY = 3                // Dummy pool for testing purposes.
};

class Orders {
 protected:
  // Structs.
  struct TPositionCount {
    int buy_count;
    int sell_count;
  };
  struct TDealTime {
    datetime buy_time;
    datetime sell_time;
  };
// Class variables.
#ifdef __MQL5__
// CTrade ctrade; // @removeme
// CPositionInfo position_info; // @removeme
#endif
  // Enum variables.
  ENUM_ORDERS_POOL pool;
  // Struct variables.
  Order *orders[];
  // Class variables.
  Ref<Log> logger;
  // Market *market;

 public:
  /**
   * Class constructor.
   */
  Orders(ENUM_ORDERS_POOL _pool, Log *_log = NULL) : pool(_pool), logger(_log != NULL ? _log : new Log) {}

  /**
   * Class deconstructor.
   */
  ~Orders() {
    for (int i = 0; i < ArraySize(orders); ++i) delete orders[i];
  }

  Log *Logger() { return logger.Ptr(); }

  /**
   * Open a new order.
   */
  bool NewOrder(MqlTradeRequest &_req, MqlTradeResult &_res) {
    int _size = ArraySize(orders);
    if (ArrayResize(orders, _size + 1, 100)) {
      orders[_size] = new Order(_req);
      return true;
    } else {
      Logger().Error("Cannot allocate the memory.", __FUNCTION__);
      return false;
    }
  }

  /* Order selection methods */

  /**
   * Finds order in the selected pool.
   */
  Order *SelectOrder(ulong _ticket) {
    for (uint _pos = ArraySize(orders); _pos >= 0; _pos--) {
      if (orders[_pos].Get<ulong>(ORDER_PROP_TICKET) == _ticket) {
        return orders[_pos];
      }
    }
    return NULL;
  }

  /**
   * Select order object by ticket.
   */
  Order *SelectByTicket(ulong _ticket) {
    Order *_order = SelectOrder(_ticket);
    if (_order != NULL) {
      return _order;
    } else if ((pool == ORDERS_POOL_TRADES && Order::TryOrderSelect(_ticket, SELECT_BY_TICKET, MODE_TRADES)) ||
               (pool == ORDERS_POOL_HISTORY && Order::TryOrderSelect(_ticket, SELECT_BY_TICKET, MODE_HISTORY))) {
      uint _size = ArraySize(orders);
      ArrayResize(orders, _size + 1, 100);
      return orders[_size] = new Order(_ticket);
    }
    Logger().Error(StringFormat("Cannot select order (ticket=#%d)!", _ticket), __FUNCTION__);
    return NULL;
  }

  /* Calculation and parsing methods */

  /**
   * Calculate number of lots for open positions.
   */
  static double GetOpenLots(string _symbol = NULL, long magic_number = 0, int magic_range = 0) {
    double total_lots = 0;
    // @todo: Convert to MQL5.
    _symbol = _symbol != NULL ? _symbol : _Symbol;
    for (int i = 0; i < OrdersTotal(); i++) {
      if (Order::TryOrderSelect(i, SELECT_BY_POS, MODE_TRADES) == false) break;
      if (Order::OrderSymbol() == _symbol) {
        if ((magic_number > 0) &&
            (Order::OrderMagicNumber() < magic_number || Order::OrderMagicNumber() > magic_number + magic_range)) {
          continue;
        }
        // This calculates the total no of lots opened in current orders.
        total_lots += Order::OrderLots();
      }
    }
    return total_lots;
  }

  /**
   * Calculate sum of all stop loss or profit take points of opened orders.
   *
   * @return
   *   Returns sum of all stop loss or profit take points
   *   from all opened orders for the given symbol.
   */
  static double TotalSLTP(ENUM_ORDER_TYPE _cmd = NULL, bool sl = true) {
    double total_buy_sl = 0, total_buy_tp = 0;
    double total_sell_sl = 0, total_sell_tp = 0;
    // @todo: Convert to MQL5.
    for (int i = 0; i < OrdersTotal(); i++) {
      if (!Order::TryOrderSelect(i, SELECT_BY_POS)) {
        // Logger().Error(StringFormat("OrderSelect (%d) returned the error", i), __FUNCTION__,
        // Terminal::GetErrorText(GetLastError()));
        break;
      }
      if (Order::OrderSymbol() == _Symbol) {
        double order_tp = Order::OrderTakeProfit();
        double order_sl = Order::OrderStopLoss();
        switch (Order::OrderType()) {
          case ORDER_TYPE_BUY:
            order_tp = order_tp == 0 ? ChartStatic::iHigh(Order::OrderSymbol(), PERIOD_W1, 0) : order_tp;
            order_sl = order_sl == 0 ? ChartStatic::iLow(Order::OrderSymbol(), PERIOD_W1, 0) : order_sl;
            total_buy_sl += Order::OrderLots() * (Order::OrderOpenPrice() - order_sl);
            total_buy_tp += Order::OrderLots() * (order_tp - Order::OrderOpenPrice());
            // PrintFormat("%s:%d/%d: OP_BUY: TP=%g, SL=%g, total: %g/%g", __FUNCTION__, i, OrdersTotal(), order_tp,
            // order_sl, total_buy_sl, total_buy_tp);
            break;
          case ORDER_TYPE_SELL:
            order_tp = order_tp == 0 ? ChartStatic::iLow(Order::OrderSymbol(), PERIOD_W1, 0) : order_tp;
            order_sl = order_sl == 0 ? ChartStatic::iHigh(Order::OrderSymbol(), PERIOD_W1, 0) : order_sl;
            total_sell_sl += Order::OrderLots() * (order_sl - Order::OrderOpenPrice());
            total_sell_tp += Order::OrderLots() * (Order::OrderOpenPrice() - order_tp);
            // PrintFormat("%s:%d%d: OP_SELL: TP=%g, SL=%g, total: %g/%g", __FUNCTION__, i, OrdersTotal(), order_tp,
            // order_sl, total_sell_sl, total_sell_tp);
            break;
        }
      }
    }
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        return sl ? total_buy_sl : total_buy_tp;
      case ORDER_TYPE_SELL:
        return sl ? total_sell_sl : total_sell_tp;
      default:
        return sl ? fabs(total_buy_sl - total_sell_sl) : fabs(total_buy_tp - total_sell_tp);
    }
  }

  /**
   * Get sum of total stop loss values of opened orders.
   */
  double TotalSL(ENUM_ORDER_TYPE _cmd = NULL) { return TotalSLTP(_cmd, true); }

  /**
   * Get sum of total take profit values of opened orders.
   *
   * @return
   *   Returns total take profit points.
   */
  double TotalTP(ENUM_ORDER_TYPE _cmd = NULL) { return TotalSLTP(_cmd, false); }

  /**
   * Get ratio of total stop loss points.
   *
   * @return
   *   Returns ratio between 0 and 1.
   */
  double RatioSL(ENUM_ORDER_TYPE _cmd = NULL) {
    return 1.0 / fmax(TotalSL(_cmd) + TotalTP(_cmd), 0.01) * TotalSL(_cmd);
  }

  /**
   * Get ratio of total profit take points.
   *
   * @return
   *   Returns ratio between 0 and 1.
   */
  double RatioTP(ENUM_ORDER_TYPE _cmd = NULL) {
    return 1.0 / fmax(TotalSL(_cmd) + TotalTP(_cmd), 0.01) * TotalTP(_cmd);
  }

  /**
   * Calculate sum of all lots of opened orders.
   *
   * @return
   *   Returns sum of all lots from all opened orders.
   */
  double TotalLots(ENUM_ORDER_TYPE _cmd = NULL) {
    double buy_lots = 0, sell_lots = 0;
    // @todo: Convert to MQL5.
    for (int i = 0; i < OrdersTotal(); i++) {
      if (!Order::OrderSelect(i, SELECT_BY_POS)) {
        Logger().Error(StringFormat("OrderSelect (%d) returned the error", i), __FUNCTION__,
                       Terminal::GetErrorText(GetLastError()));
        break;
      }
      if (Order::OrderSymbol() == _Symbol) {
        switch (Order::OrderType()) {
          case ORDER_TYPE_BUY:
            buy_lots += Order::OrderLots();
            break;
          case ORDER_TYPE_SELL:
            sell_lots += Order::OrderLots();
            break;
        }
      }
    }
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        return buy_lots;
      case ORDER_TYPE_SELL:
        return sell_lots;
      default:
        return buy_lots + sell_lots;
    }
  }

  /**
   * Get order type based on the majority of opened orders.
   *
   * @return
   *   Returns order type of majority of opened orders. Otherwise NULL.
   */
  ENUM_ORDER_TYPE GetOrderTypeByOrders() {
    double _buy_lots = TotalLots(ORDER_TYPE_BUY);
    double _sell_lots = TotalLots(ORDER_TYPE_SELL);
    if (_buy_lots > 0 && _buy_lots > _sell_lots) {
      return ORDER_TYPE_BUY;
    } else if (_sell_lots > 0 && _sell_lots > _buy_lots) {
      return ORDER_TYPE_SELL;
    } else {
      return NULL;
    }
  }

  /**
   * Close all orders.
   *
   * @return
   *   Returns true on success.
   */
  bool OrdersCloseAll(const string _symbol = NULL, const ENUM_POSITION_TYPE _type = (ENUM_POSITION_TYPE)-1,
                      const int _magic = -1) {
#ifdef __MQL4__

    //---
    if (!(_type == POSITION_TYPE_BUY || _type == POSITION_TYPE_SELL || _type == -1)) {
      return (false);
    }

    bool result = true;
    uint total = OrdersTotal();
    for (uint i = total - 1; i >= 0; i--) {
      if (!Order::TryOrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
        return (false);
      }

      int order_type = OrderType();

      if ((_symbol == NULL || OrderSymbol() == _symbol) &&
          ((_type == -1 && (order_type == OP_BUY || order_type == OP_SELL)) || order_type == _type) &&
          (_magic == -1 || OrderMagicNumber() == _magic)) {
        string o_symbol = OrderSymbol();

        uint _digits = SymbolInfoStatic::GetDigits(o_symbol);
        bool res_one = false;
        int attempts = 10;
        while (attempts > 0) {
          ResetLastError();

          if (IsTradeContextBusy()) {
            Sleep(500);
            attempts--;
            continue;
          }

          RefreshRates();

          double close_price = 0.0;
          if (order_type == OP_BUY) {
            close_price = SymbolInfoStatic::GetBid(o_symbol);
          }
          if (order_type == OP_SELL) {
            close_price = SymbolInfoStatic::GetAsk(o_symbol);
          }

          //---
          uint slippage = SymbolInfoStatic::GetSpread(o_symbol);

          //---
          if (OrderClose(OrderTicket(), OrderLots(), close_price, slippage)) {
            res_one = true;
            break;
          } else {
            Logger().AddLastError();
            Sleep(TRADE_PAUSE_LONG);
            break;
          }
          attempts--;
        }

        result &= res_one;
      }
    }

#endif

#ifdef __MQL5__
    uint total = PositionsTotal();
    /* @fixme
    for (uint i = total - 1; i >= 0; i--) {
      if (!position_info.SelectByIndex(i))
        return(false);

      //--- check symbol
      if (_symbol != NULL && position_info.Symbol() != _symbol)
        continue;

      //--- check type
      if (_type != -1 && position_info.PositionType() != _type)
        continue;

      //--- check magic
      if (_magic != -1 && position_info.Magic() != _magic)
        continue;

      //---
      ctrade.SetTypeFilling(Order::GetOrderFilling((string) position_info.Symbol()));
      if (!ctrade.PositionClose(position_info.Ticket(), market.GetSpreadInPts())) {
        Logger().Error(ctrade.ResultRetcodeDescription());
      }
    }
    */
#endif
    //---
    return (true);
  }

  /**
   * Get time of the last deal.
   *
   * @return
   *   Returns true on success.
   */
  bool DealLastTime(TDealTime &last_time, const string _symbol, const int _magic) {
    last_time.buy_time = 0;
    last_time.sell_time = 0;
    //---
#ifdef __MQL4__
    int orders_total = TradeHistoryStatic::HistoryOrdersTotal();
    for (int i = orders_total - 1; i >= 0; i--) {
      if (!Order::TryOrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) {
        return (false);
      }

      if (_symbol != NULL && OrderSymbol() != _symbol) continue;
      if (_magic != -1 && OrderMagicNumber() != _magic) continue;
      //---
      if (OrderType() == OP_BUY && last_time.buy_time == 0) last_time.buy_time = OrderOpenTime();
      //---
      if (OrderType() == OP_SELL && last_time.sell_time == 0) last_time.sell_time = OrderOpenTime();
      //---
      break;
    }
#else  // __MQL5__
/* @fixme: Rewrite without using CDealInfo.
    CDealInfo deal;

    if (!HistorySelect(0, TimeCurrent()))
      return(false);

    int total = HistoryDealsTotal();
    for (int i = total - 1; i >= 0; i--) {
      if (!deal.SelectByIndex(i))
        return(false);

      if (deal.Symbol() != _Symbol)
        continue;

      if (deal.Entry() == DEAL_ENTRY_IN) {
        //---
        if (deal.DealType() == DEAL_TYPE_BUY &&
            last_time.buy_time == 0) {
          last_time.buy_time = deal.Time();
          if (last_time.sell_time>0)
            break;
        }

        //---
        if (deal.DealType() == DEAL_TYPE_SELL &&
            last_time.sell_time == 0)
        {
          last_time.sell_time = deal.Time();
          if (last_time.buy_time > 0)
            break;
        }

      }
    }
*/
#endif
    return (true);
  }

  /**
   * Get total of open positions.
   *
   * @return
   *   Returns true on success.
   */
  /*
  bool PositonTotal(TPositionCount &count, const int _magic = 0) {

    ResetLastError();

    count.buy_count=0;
    count.sell_count=0;

    #ifdef __MQL4__
    uint total = OrdersTotal();
    for (uint i = 0; i < total; i++) {
      if (!Order::OrderSelect(i, SELECT_BY_POS)) {
        return false;
      }

      if (Order::OrderSymbol() != market.GetSymbol())
        continue;

      if (_magic != -1 && Order::OrderMagicNumber() != _magic)
        continue;

      if (Order::OrderType() == OP_BUY)
        count.buy_count++;

      if (Order::OrderType() == OP_SELL)
        count.sell_count++;
    }
    #else // __MQL5__
    CPositionInfo pos;
    int total = PositionsTotal();
    for(int i=0; i<total; i++) {
      if (!pos.SelectByIndex(i)) {
        return (false);
      }
      //---
      if ((pos.Symbol() == symbol || symbol == NULL) &&
          (pos.Magic() == _magic  || _magic ==-1)) {
        if (pos.PositionType() == POSITION_TYPE_BUY) {
          count.buy_count++;
        }
        if (pos.PositionType() == POSITION_TYPE_SELL) {
          count.sell_count++;
        }
      }
    }
    #endif
    return (true);
  }
  */

  /**
   * Count open positions by order type.
   */
  static uint GetOrdersByType(ENUM_ORDER_TYPE _cmd, string _symbol = NULL) {
    uint _counter = 0;
    _symbol = _symbol != NULL ? _symbol : _Symbol;
    for (int i = 0; i < OrdersTotal(); i++) {
      if (Order::TryOrderSelect(i, SELECT_BY_POS, MODE_TRADES) == false) break;
      if (Order::OrderSymbol() == _symbol) {
        if (Order::OrderType() == _cmd) _counter++;
      }
    }
    return _counter;
  }

  /**
   * Get realized P&L (Profit and Loss).
   */
  /*
  double GetRealizedPL() const {
    double profit = 0;
    for (int i = 0; i <= numberOrders; ++i) {
      if (this.orders[i].getOrderType() == ORDER_FINAL) {
        // @todo
        // profit += this.orders[i].getOrderProfit();
      }
    }
    return profit;
  }
  */

  /**
   * Get unrealized P&L (Profit and Loss).
   *
   * A reflection of what profit or loss
   * that could be realized if the position were closed at that time.
   */
  /*
  double GetUnrealizedPL() const {
    double profit = 0;
    for (int i = 0; i <= numberOrders; ++i) {
      if (this.orders[i].getOrderType() != ORDER_FINAL) {
        profit += this.orders[i].getOrderProfit();
      }
    }
    return profit;
  }

  double GetTotalEquity() const {
    double profit = 0;
    for (int i = 0; i <= numberOrders; ++i) {
      profit += this.orders[i].GetOrderProfit();
    }
    return profit;
  }

  double GetTotalCommission() const {
    double commission = 0;
    for (int i = 0; i <= numberOrders; ++i) {
      commission += this.orders[i].GetOrderCommission();
    }
    return commission;
  }

  double GetTotalSwap() const {
    double swap = 0;
    for (int i = 0; i <= numberOrders; ++i) {
      swap += this.orders[i].GetOrderSwap();
    }
    return swap;
  }
  */
};
#define ORDERS_MQH
#endif

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Orders.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Array.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SymbolInfo.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Account.define.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Defines.
#define ACC_OP_BALANCE 6  // Undocumented balance history statement entry.
#define ACC_OP_CREDIT 7   // Undocumented credit history statement entry.

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Account.define.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: BufferStruct.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictStruct.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictBase.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef BUFFER_STRUCT_MQH
#define BUFFER_STRUCT_MQH

// Includes.




/**
 * Implements BufferStruct's Overflow Listener.
 *
 * @see DictBase
 */
bool BufferStructOverflowListener(ENUM_DICT_OVERFLOW_REASON _reason, int _size, int _num_conflicts) {
  // We allow resize if dictionary size is less than 10000 slots.
  return _size < 10000;
}

/**
 * Class to store struct data.
 */
template <typename TStruct>
class BufferStruct : public DictStruct<long, TStruct> {
 protected:
  long min, max;

 public:
  /* Constructors */

  /**
   * Constructor.
   */
  BufferStruct() : max(INT_MIN), min(INT_MAX) { SetOverflowListener(BufferStructOverflowListener, 10); }
  BufferStruct(BufferStruct& _right) : max(INT_MIN), min(INT_MAX) {
    this = _right;
    SetOverflowListener(BufferStructOverflowListener, 10);
  }

  /**
   * Adds new value.
   */
  void Add(TStruct& _value, long _dt = 0) {
    _dt = _dt > 0 ? _dt : TimeCurrent();
    if (Set(_dt, _value)) {
      min = _dt < min ? _dt : min;
      max = _dt > max ? _dt : max;
    }
  }

  /**
   * Clear entries older than given timestamp.
   */
  void Clear(long _dt = 0, bool _older = true) {
    min = INT_MAX;
    max = INT_MIN;
    if (_dt > 0) {
      for (DictStructIterator<long, TStruct> iter(Begin()); iter.IsValid(); ++iter) {
        long _time = iter.Key();
        if (_older && _time < _dt) {
          Unset(iter.Key());
          continue;
        } else if (!_older && _time > _dt) {
          Unset(iter.Key());
          continue;
        }
        min = _time < min ? _time : min;
        max = _time > max ? _time : max;
      }
    } else {
      DictStruct<long, TStruct>::Clear();
    }
  }

  /* Getters */

  /**
   * Gets the newest timestamp.
   */
  long GetMax() { return max; }

  /**
   * Gets the oldest timestamp.
   */
  long GetMin() { return min; }
};

#endif  // BUFFER_STRUCT_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: BufferStruct.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef ACCOUNT_MQH
#define ACCOUNT_MQH

// Forward class declaration.
class Account;

// Includes.















/**
 * Class to provide functions that return parameters of the current account.
 */
class Account {
 protected:
  // Struct variables.
  BufferStruct<AccountEntry> entries;

  // Variables.
  double init_balance, start_balance, start_credit;
  // Store daily, weekly and monthly account statistics.
  double acc_stats[FINAL_ENUM_ACC_STAT_VALUE][FINAL_ENUM_ACC_STAT_PERIOD][FINAL_ENUM_ACC_STAT_TYPE]
                  [FINAL_ENUM_ACC_STAT_INDEX];

 public:
  /**
   * Class constructor.
   */
  Account() : init_balance(CalcInitDeposit()), start_balance(GetBalance()), start_credit(GetCredit()) {}

  /**
   * Class deconstructor.
   */
  ~Account() {}

  /* Entries */

  /**
   * Gets account entry.
   *
   * @return
   *  Returns account entry.
   */
  AccountEntry GetEntry() {
    AccountEntry _entry;
    _entry.dtime = TimeCurrent();
    _entry.balance = GetBalance();
    _entry.credit = GetCredit();
    _entry.equity = GetEquity();
    _entry.profit = GetProfit();
    _entry.margin_used = GetMarginUsed();
    _entry.margin_free = GetMarginFree();
    _entry.margin_avail = GetMarginAvail();
    return _entry;
  }

  /**
   * Saves account entry.
   *.
   */
  void EntrySave() {
    AccountEntry _entry = GetEntry();
    entries.Add(_entry);
  }

  /* MT account methods */

  /**
   * Returns the current account name.
   */
  static string AccountName() { return AccountInfoString(ACCOUNT_NAME); }
  string GetAccountName() { return AccountName(); }

  /**
   * Returns the connected server name.
   */
  static string AccountServer() { return AccountInfoString(ACCOUNT_SERVER); }
  static string GetServerName() { return AccountServer(); }

  /**
   * Returns currency name of the current account.
   */
  static string AccountCurrency() { return AccountInfoString(ACCOUNT_CURRENCY); }
  string GetCurrency() { return AccountCurrency(); }

  /**
   * Returns the brokerage company name where the current account was registered.
   */
  static string AccountCompany() { return AccountInfoString(ACCOUNT_COMPANY); }
  string GetCompanyName() { return AccountCompany(); }

  /* Double getters */

  /**
   * Returns balance value of the current account.
   */
  static double AccountBalance() { return AccountInfoDouble(ACCOUNT_BALANCE); }
  float GetBalance() {
    // @todo: Adds caching.
    // return UpdateStats(ACC_BALANCE, AccountBalance());
    return (float)Account::AccountBalance();
  }

  /**
   * Returns credit value of the current account.
   */
  static double AccountCredit() { return AccountInfoDouble(ACCOUNT_CREDIT); }
  float GetCredit() {
    // @todo: Adds caching.
    // return UpdateStats(ACC_CREDIT, AccountCredit());
    return (float)Account::AccountCredit();
  }

  /**
   * Returns profit value of the current account.
   */
  static double AccountProfit() { return AccountInfoDouble(ACCOUNT_PROFIT); }
  float GetProfit() {
    // @todo: Adds caching.
    // return UpdateStats(ACC_PROFIT, AccountProfit());
    return (float)Account::AccountProfit();
  }

  /**
   * Returns equity value of the current account.
   */
  static double AccountEquity() { return AccountInfoDouble(ACCOUNT_EQUITY); }
  float GetEquity() {
    // @todo: Adds caching.
    // return UpdateStats(ACC_EQUITY, AccountEquity());
    return (float)Account::AccountEquity();
  }

  /**
   * Returns margin value of the current account.
   */
  static double AccountMargin() { return AccountInfoDouble(ACCOUNT_MARGIN); }
  float GetMarginUsed() {
    // @todo: Adds caching.
    // return UpdateStats(ACC_MARGIN_USED, AccountMargin());
    return (float)Account::AccountMargin();
  }

  /**
   * Get account's used margin in percentage.
   *
   * @return
   *   Account's margin used in percentage.
   */
  double GetMarginUsedInPct() {
    double _margin_avail = GetMarginAvail();
    double _margin_used = GetMarginUsed();
    return _margin_avail > 0 ? 100 / _margin_avail * _margin_used : 100;
  }

  /**
   * Returns free margin value of the current account.
   */
  static double AccountFreeMargin() { return AccountInfoDouble(ACCOUNT_MARGIN_FREE); }
  float GetMarginFree() {
    // @todo: Adds caching.
    // return UpdateStats(ACC_MARGIN_FREE, AccountFreeMargin());
    return (float)Account::AccountFreeMargin();
  }

  /**
   * Returns free margin value of the current account in percentage.
   *
   * @return
   *   Account's free margin in percentage.
   */
  double GetMarginFreeInPct() {
    double _margin_free = GetMarginFree();
    double _margin_avail = GetMarginAvail();
    return _margin_avail > 0 ? 100 / _margin_avail * _margin_free : 0;
  }

  /**
   * Returns the current account number.
   */
  static long AccountNumber() { return AccountInfoInteger(ACCOUNT_LOGIN); }
  long GetLogin() { return AccountNumber(); }

  /**
   * Returns leverage of the current account.
   */
  static long AccountLeverage() { return AccountInfoInteger(ACCOUNT_LEVERAGE); }
  long GetLeverage() { return AccountLeverage(); }

  /**
   * Returns the calculation mode for the Stop Out level.
   */
  static int AccountStopoutMode() { return (int)AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE); }
  int GetStopoutMode() { return AccountStopoutMode(); }

  /**
   * Returns the value of the Stop Out level.
   *
   * Depending on the set ACCOUNT_MARGIN_SO_MODE,
   * is expressed in percents or in the deposit currency.
   */
  static double AccountStopoutLevel() { return AccountInfoDouble(ACCOUNT_MARGIN_SO_SO); }
  double GetStopoutLevel() { return AccountStopoutLevel(); }

  /**
   * Get a maximum allowed number of active pending orders set by broker.
   *
   * @return
   *   Returns the limit orders (0 for unlimited).
   */
  static long AccountLimitOrders() { return AccountInfoInteger(ACCOUNT_LIMIT_ORDERS); }
  long GetLimitOrders(uint _max = 999) {
    long _limit = AccountLimitOrders();
    return _limit > 0 ? _limit : _max;
  }

  /* Other account methods */

  /**
   * Get account total balance (including credit).
   */
  static double AccountTotalBalance() { return AccountBalance() + AccountCredit(); }
  float GetTotalBalance() { return (float)(GetBalance() + GetCredit()); }

  /**
   * Get account available margin.
   */
  static double AccountAvailMargin() { return fmin(AccountFreeMargin(), AccountTotalBalance()); }
  float GetMarginAvail() { return (float)AccountAvailMargin(); }

  /**
   * Returns the calculation mode of free margin allowed to open orders on the current account.
   */
  static double AccountFreeMarginMode() {
#ifdef __MQL4__
    /*
     *  The calculation mode can take the following values:
     *  0 - floating profit/loss is not used for calculation;
     *  1 - both floating profit and loss on opened orders on the current account are used for free margin calculation;
     *  2 - only profit value is used for calculation, the current loss on opened orders is not considered;
     *  3 - only loss value is used for calculation, the current loss on opened orders is not considered.
     */
    return ::AccountFreeMarginMode();
#else
    // @todo: Not implemented yet.
    return NULL;
#endif
  }
  static double GetAccountFreeMarginMode() { return Account::AccountFreeMarginMode(); }

  /* State checkers */

  /**
   * Indicates if an Expert Advisor is allowed to trade on the account.
   */
  static bool IsExpertEnabled() { return (bool)AccountInfoInteger(ACCOUNT_TRADE_EXPERT); }

  /**
   * Check the permission to trade for the current account.
   */
  static bool IsTradeAllowed() { return (bool)AccountInfoInteger(ACCOUNT_TRADE_ALLOWED); }

  /**
   * Check if the Expert Advisor runs on a demo account.
   */
  static bool IsDemo() {
#ifdef __MQL4__
    return ::IsDemo();
#else  // __MQL5__
    return AccountInfoInteger(ACCOUNT_TRADE_MODE) == ACCOUNT_TRADE_MODE_DEMO;
#endif
  }

  /**
   * Returns type of account (Demo or Live).
   */
  static string GetType() { return Account::GetServerName() != "" ? (IsDemo() ? "Demo" : "Live") : "Off-line"; }

  /* Setters */

  double UpdateStats(ENUM_ACC_STAT_VALUE _type, double _value) {
    static datetime _last_check = TimeCurrent();
    bool _stats_rotate = false;
    int _tindex = (int)_type;
    for (uint _pindex = 0; _pindex < FINAL_ENUM_ACC_STAT_PERIOD; _pindex++) {
      acc_stats[_tindex][_pindex][(int)ACC_VALUE_MIN][(int)ACC_VALUE_CURR] =
          fmin(acc_stats[_tindex][_pindex][(int)ACC_VALUE_MIN][(int)ACC_VALUE_CURR], _value);
      acc_stats[_tindex][_pindex][(int)ACC_VALUE_MAX][(int)ACC_VALUE_CURR] =
          fmin(acc_stats[_tindex][_pindex][(int)ACC_VALUE_MAX][(int)ACC_VALUE_CURR], _value);
      acc_stats[_tindex][_pindex][(int)ACC_VALUE_AVG][(int)ACC_VALUE_CURR] =
          (acc_stats[_tindex][_pindex][(int)ACC_VALUE_AVG][(int)ACC_VALUE_CURR] + _value) / 2;
      switch (_pindex) {
        case ACC_DAILY:
          _stats_rotate = _last_check < ChartStatic::iTime(_Symbol, PERIOD_D1);
          break;
        case ACC_WEEKLY:
          _stats_rotate = _last_check < ChartStatic::iTime(_Symbol, PERIOD_W1);
          break;
        case ACC_MONTHLY:
          _stats_rotate = _last_check < ChartStatic::iTime(_Symbol, PERIOD_MN1);
          break;
      }
      if (_stats_rotate) {
        acc_stats[_tindex][_pindex][(int)ACC_VALUE_MIN][(int)ACC_VALUE_PREV] =
            acc_stats[_tindex][_pindex][(int)ACC_VALUE_MIN][(int)ACC_VALUE_CURR];
        acc_stats[_tindex][_pindex][(int)ACC_VALUE_MAX][(int)ACC_VALUE_PREV] =
            acc_stats[_tindex][_pindex][(int)ACC_VALUE_MAX][(int)ACC_VALUE_CURR];
        acc_stats[_tindex][_pindex][(int)ACC_VALUE_AVG][(int)ACC_VALUE_PREV] =
            acc_stats[_tindex][_pindex][(int)ACC_VALUE_AVG][(int)ACC_VALUE_CURR];
        acc_stats[_tindex][_pindex][(int)ACC_VALUE_MIN][(int)ACC_VALUE_CURR] = _value;
        acc_stats[_tindex][_pindex][(int)ACC_VALUE_MAX][(int)ACC_VALUE_CURR] = _value;
        acc_stats[_tindex][_pindex][(int)ACC_VALUE_AVG][(int)ACC_VALUE_CURR] = _value;
        _last_check = TimeCurrent();
      }
    }
    return _value;
  }

  /* Class getters */

  /**
   * Get account init balance.
   */
  double GetInitBalance() { return init_balance; }

  /**
   * Get account start balance.
   */
  double GetStartBalance() { return start_balance; }

  /**
   * Get account init credit.
   */
  double GetStartCredit() { return start_credit; }

  /* Calculation methods */

  /**
   * Get account stopout level in range: 0.0 - 1.0 where 1.0 is 100%.
   *
   * Note:
   *  - if(AccountEquity()/AccountMargin()*100 < AccountStopoutLevel()) { BrokerClosesOrders(); }
   */
  static double GetAccountStopoutLevel() {
    int mode = AccountStopoutMode();
    double level = AccountStopoutLevel();
    if (mode == 0 && level > 0) {
      // Calculation of percentage ratio between margin and equity.
      return (double)level / 100;
    } else if (mode == 1) {
      // Comparison of the free margin level to the absolute value.
      return 1.0;
    } else {
      // @todo: Add logging.
      // if (verbose) PrintFormat("%s(): Not supported mode (%d).", __FUNCTION__, mode);
    }
    return 1.0;
  }

  /**
   * Returns free margin that remains after the specified order has been opened at the current price on the current
   * account.
   *
   * @return
   * Free margin that remains after the specified order has been opened at the current price on the current account.
   * If the free margin is insufficient, an error 134 (ERR_NOT_ENOUGH_MONEY) will be generated.
   */
  static double AccountFreeMarginCheck(string _symbol, ENUM_ORDER_TYPE _cmd, double _volume) {
// Notes:
// AccountFreeMarginCheck =  FreeMargin - Margin1Lot * Lot;
// FreeMargin = Equity - Margin;
// Equity = Balance + Profit;
// FreeMargin =  Balance + Profit - Margin;
// AccountFreeMarginCheck = Balance + Profit - Margin - Margin1Lot * Lot;
#ifdef __MQL4__
    return ::AccountFreeMarginCheck(_symbol, _cmd, _volume);
#else
    // @see: CAccountInfo::FreeMarginCheck
    double _margin;
    return (::OrderCalcMargin(
                _cmd, _symbol, _volume,
                SymbolInfoStatic::SymbolInfoDouble(_symbol, (_cmd == ORDER_TYPE_BUY) ? SYMBOL_ASK : SYMBOL_BID),
                _margin)
                ? AccountInfoDouble(ACCOUNT_MARGIN_FREE) - _margin
                : -1);
#endif
  }
  double GetAccountFreeMarginCheck(ENUM_ORDER_TYPE _cmd, double _volume) {
    return AccountFreeMarginCheck(_Symbol, _cmd, _volume);
  }

  /**
   * Get current account drawdown in percent.
   */
  static double GetDrawdownInPct() {
    double _balance_total = AccountTotalBalance();
    return _balance_total != 0 ? (100 / AccountTotalBalance()) * (AccountTotalBalance() - AccountEquity()) : 0.0;
  }

  /**
   * Get current account risk margin level.
   *
   * The risk is calculated based on the stop loss sum of opened orders.
   *
   * @return
   *   Returns value from 0.0 (no risk) and 1.0 (100% risk).
   *   The risk higher than 1.0 means that the risk is extremely high.
   */
  /* @fixme
  double GetRiskMarginLevel(ENUM_ORDER_TYPE _cmd = NULL) {
    double _avail_margin = AccountAvailMargin() * Convert::ValueToMoney(trades.TotalSL(_cmd));
    return _avail_margin > 0 ? 1 / _avail_margin : 0;
  }
  */

  /**
   * Calculates initial deposit based on the current balance and previous orders.
   */
  static double CalcInitDeposit() {
    double deposit = Account::AccountInfoDouble(ACCOUNT_BALANCE);
    for (int i = TradeHistoryStatic::HistoryOrdersTotal() - 1; i >= 0; i--) {
      if (!Order::TryOrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) continue;
      int type = Order::OrderType();
      // Initial balance not considered.
      if (i == 0 && type == ACC_OP_BALANCE) break;
      if (type == ORDER_TYPE_BUY || type == ORDER_TYPE_SELL) {
        // Calculate profit.
        double profit = OrderStatic::Profit() + OrderStatic::Commission() + OrderStatic::Swap();
        // Calculate decrease balance.
        deposit -= profit;
      }
      if (type == ACC_OP_BALANCE || type == ACC_OP_CREDIT) {
        deposit -= OrderStatic::Profit();
      }
    }
    return deposit;
  }

  /**
   * Calculate total profit.
   */
  double GetTotalProfit() {
    /* @todo
      double total_profit = 0;
      for (int id = 0; id < ArrayRange(stats, 0); id++) {
        total_profit += stats[id][TOTAL_NET_PROFIT];
      }
      return total_profit;
    */
    return 0;
  }

  /**
   * Returns min/max/avg daily/weekly/monthly account balance/equity/margin.
   */
  double GetStatValue(ENUM_ACC_STAT_VALUE _value_type, ENUM_ACC_STAT_PERIOD _period, ENUM_ACC_STAT_TYPE _stat_type,
                      ENUM_ACC_STAT_INDEX _shift = ACC_VALUE_CURR) {
    // @fixme
    return acc_stats[(int)_value_type][(int)_period][(int)_stat_type][(int)_shift];
  }

  /* State checkers */

  /**
   * Check account free margin.
   *
   * @return
   *   Returns true, when free margin is sufficient, false when insufficient or on error.
   */
  bool IsFreeMargin(ENUM_ORDER_TYPE _cmd, double size_of_lot, string _symbol = NULL) {
    bool _res = true;
    double margin = AccountFreeMarginCheck(_symbol, _cmd, size_of_lot);
    if (GetLastError() == 134 /* NOT_ENOUGH_MONEY */) _res = false;
    return (_res);
  }

  /* Conditions */

  /**
   * Checks for account condition.
   *
   * @param ENUM_ACCOUNT_CONDITION _cond
   *   Account condition.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_ACCOUNT_CONDITION _cond, ARRAY_REF(DataParamEntry, _args)) {
    switch (_cond) {
      /* @todo
      case ACCOUNT_COND_BALM_GT_YEARLY:
        // @todo
        return false;
      case ACCOUNT_COND_BALM_LT_YEARLY:
        // @todo
        return false;
      case ACCOUNT_COND_BALT_GT_WEEKLY:
        return
          trade.Account().GetStatValue(ACC_BALANCE, ACC_DAILY,  (ENUM_ACC_STAT_TYPE) fmin(0,
      fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX)))) > trade.Account().GetStatValue(ACC_BALANCE,
      ACC_WEEKLY, (ENUM_ACC_STAT_TYPE) fmin(0, fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX))));
      case ACCOUNT_COND_BALT_IN_LOSS:
        // @todo
        return false;
      case ACCOUNT_COND_BALT_IN_PROFIT:
        // @todo
        return false;
      case ACCOUNT_COND_BALT_LT_WEEKLY:
        return
          trade.Account().GetStatValue(ACC_BALANCE, ACC_DAILY,  (ENUM_ACC_STAT_TYPE) fmin(0,
      fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX)))) < trade.Account().GetStatValue(ACC_BALANCE,
      ACC_WEEKLY, (ENUM_ACC_STAT_TYPE) fmin(0, fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX))));
      case ACCOUNT_COND_BALW_GT_MONTHLY:
        return
          trade.Account().GetStatValue(ACC_BALANCE, ACC_WEEKLY,  (ENUM_ACC_STAT_TYPE) fmin(0,
      fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX)))) > trade.Account().GetStatValue(ACC_BALANCE,
      ACC_MONTHLY, (ENUM_ACC_STAT_TYPE) fmin(0, fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX))));
      case ACCOUNT_COND_BALW_LT_MONTHLY:
        return
          trade.Account().GetStatValue(ACC_BALANCE, ACC_WEEKLY,  (ENUM_ACC_STAT_TYPE) fmin(0,
      fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, ACC_VALUE_MAX)))) < trade.Account().GetStatValue(ACC_BALANCE,
      ACC_MONTHLY, (ENUM_ACC_STAT_TYPE) fmin(0, fmax(FINAL_ENUM_ACC_STAT_TYPE - 1, GetArg(_index, 0, 1)))); case
      ACCOUNT_COND_BALY_IN_LOSS: return trade.Account().GetProfit() < trade.Account().GetProfit() / 100 * (100 -
      GetArg(_index, 0, 10)); case ACCOUNT_COND_BALY_IN_PROFIT: return trade.Account().GetProfit() >
      trade.Account().GetProfit() / 100 * (100 + GetArg(_index, 0, 10));
      */
      case ACCOUNT_COND_BAL_IN_LOSS:
        return GetBalance() < start_balance;
      case ACCOUNT_COND_BAL_IN_PROFIT:
        return GetBalance() > start_balance;
      case ACCOUNT_COND_EQUITY_01PC_HIGH:
        return AccountEquity() > (GetTotalBalance()) / 100 * 101;
      case ACCOUNT_COND_EQUITY_01PC_LOW:
        return AccountEquity() < (GetTotalBalance()) / 100 * 99;
      case ACCOUNT_COND_EQUITY_02PC_HIGH:
        return AccountEquity() > (GetTotalBalance()) / 100 * 102;
      case ACCOUNT_COND_EQUITY_02PC_LOW:
        return AccountEquity() < (GetTotalBalance()) / 100 * 98;
      case ACCOUNT_COND_EQUITY_05PC_HIGH:
        return AccountEquity() > (GetTotalBalance()) / 100 * 105;
      case ACCOUNT_COND_EQUITY_05PC_LOW:
        return AccountEquity() < (GetTotalBalance()) / 100 * 95;
      case ACCOUNT_COND_EQUITY_10PC_HIGH:
        return AccountEquity() > (GetTotalBalance()) / 100 * 110;
      case ACCOUNT_COND_EQUITY_10PC_LOW:
        return AccountEquity() < (GetTotalBalance()) / 100 * 90;
      case ACCOUNT_COND_EQUITY_20PC_HIGH:
        return AccountEquity() > (GetTotalBalance()) / 100 * 120;
      case ACCOUNT_COND_EQUITY_20PC_LOW:
        return AccountEquity() < (GetTotalBalance()) / 100 * 80;
      case ACCOUNT_COND_EQUITY_IN_LOSS:
        return GetEquity() < GetTotalBalance();
      case ACCOUNT_COND_EQUITY_IN_PROFIT:
        return GetEquity() > GetTotalBalance();
      /*
      case ACCOUNT_COND_MARGIN_CALL_10PC:
        // @todo
        return false;
      case ACCOUNT_COND_MARGIN_CALL_20PC:
        // @todo
        return false;
      */
      case ACCOUNT_COND_MARGIN_FREE_IN_PC:
        // Arguments:
        // arg[0] - Specify value in percentage.
        // arg[1] - Math comparison operators (@see: ENUM_MATH_CONDITION).
        return Math::Compare(GetMarginFreeInPct(), _args[0].ToValue<double>(),
                             (ENUM_MATH_CONDITION)_args[1].ToValue<int>());
      case ACCOUNT_COND_MARGIN_USED_10PC:
        return GetMarginUsedInPct() >= 10;
      case ACCOUNT_COND_MARGIN_USED_20PC:
        return GetMarginUsedInPct() >= 20;
      case ACCOUNT_COND_MARGIN_USED_50PC:
        return GetMarginUsedInPct() >= 50;
      case ACCOUNT_COND_MARGIN_USED_80PC:
        return GetMarginUsedInPct() >= 80;
      case ACCOUNT_COND_MARGIN_USED_99PC:
        return GetMarginUsedInPct() >= 99;
      case ACCOUNT_COND_MARGIN_USED_IN_PC:
        // Arguments:
        // arg[0] - Specify value in percentage.
        // arg[1] - Math comparison operators (@see: ENUM_MATH_CONDITION).
        return Math::Compare(GetMarginUsedInPct(), _args[0].ToValue<double>(),
                             (ENUM_MATH_CONDITION)_args[1].ToValue<int>());
      default:
        // logger.Error(StringFormat("Invalid account condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
#ifdef __debug__
        Print(StringFormat("%s: Error: Invalid account condition: %d!", __FUNCTION__, _cond));
#endif
        return false;
    }
  }
  bool CheckCondition(ENUM_ACCOUNT_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Account::CheckCondition(_cond, _args);
  }
  bool CheckCondition(ENUM_ACCOUNT_CONDITION _cond, long _arg1) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    ArrayPushObject(_args, _param1);
    return Account::CheckCondition(_cond, _args);
  }
  bool CheckCondition(ENUM_ACCOUNT_CONDITION _cond, long _arg1, long _arg2) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    DataParamEntry _param2 = _arg2;
    ArrayPushObject(_args, _param1);
    ArrayPushObject(_args, _param2);
    return Account::CheckCondition(_cond, _args);
  }

  /* Printers */

  /**
   * Returns text info about the account.
   */
  string ToString() {
    return StringFormat(
        "Type: %s, Server/Company/Name: %s/%s/%s, Currency: %s, Balance: %g, Credit: %g, Equity: %g, Profit: %g, "
        "Margin Used/Free/Avail: %g(%.1f%%)/%g/%g, Orders limit: %g: Leverage: 1:%d, StopOut Level: %d (Mode: %d)",
        GetType(), GetServerName(), GetCompanyName(), GetAccountName(), GetCurrency(), GetBalance(), GetCredit(),
        GetEquity(), GetProfit(), GetMarginUsed(), GetMarginUsedInPct(), GetMarginFree(), GetMarginAvail(),
        GetLimitOrders(), GetLeverage(), GetStopoutLevel(), GetStopoutMode());
  }

  /**
   * Returns info about the account in CSV format.
   */
  string ToCSV() {
    return StringFormat("%g,%g,%g,%g,%g,%g", GetTotalBalance(), GetEquity(), GetProfit(), GetMarginUsed(),
                        GetMarginFree(), GetMarginAvail());
  }

  /* Serializers */

  /**
   * Returns serialized representation of the object instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    AccountEntry _entry = GetEntry();
    _s.PassStruct(THIS_REF, "account-entry", _entry, SERIALIZER_FIELD_FLAG_DYNAMIC);
    return SerializerNodeObject;
  }

  /* Static methods */

  /**
   * Returns the double value of the appropriate account property.
   *
   * @param
   * _prop_id Property identifier.
   *
   * @docs
   * - https://www.mql5.com/en/docs/account/accountinfodouble
   */
  static double AccountInfoDouble(ENUM_ACCOUNT_INFO_DOUBLE _prop_id) { return ::AccountInfoDouble(_prop_id); }

  /**
   * Returns the integer value of the appropriate account property.
   *
   * @param
   * _prop_id Property identifier.
   *
   * @docs
   * - https://www.mql5.com/en/docs/account/accountinfointeger
   */
  static long AccountInfoInteger(ENUM_ACCOUNT_INFO_INTEGER _prop_id) { return ::AccountInfoInteger(_prop_id); }

  /**
   * Returns the string value of the appropriate account property.
   *
   * @param
   * _prop_id Property identifier.
   *
   * @docs
   * - https://www.mql5.com/en/docs/account/accountinfostring
   */
  static string AccountInfoString(ENUM_ACCOUNT_INFO_STRING _prop_id) { return ::AccountInfoString(_prop_id); }
};
#endif  // ACCOUNT_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Account.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DrawIndicator.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictObject.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DictStruct.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: EA.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Market.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Condition.enum.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Provides integration with conditions.
 */

// Prevents processing this includes file for the second time.
#ifndef CONDITION_MQH
#define CONDITION_MQH

// Includes.










// Includes class enum and structs.



/**
 * Condition class.
 */
class Condition {
 public:
 protected:
  // Class variables.
  Ref<Log> logger;

 public:
  // Class variables.
  DictStruct<short, ConditionEntry> conds;

  /* Special methods */

  /**
   * Class constructor.
   */
  Condition() {}
  Condition(ConditionEntry &_entry) { conds.Push(_entry); }
  Condition(long _cond_id, ENUM_CONDITION_TYPE _type) {
    ConditionEntry _entry(_cond_id, _type);
    conds.Push(_entry);
  }
  template <typename T>
  Condition(T _cond_id, void *_obj = NULL) {
    ConditionEntry _entry(_cond_id);
    if (_obj != NULL) {
      _entry.SetObject(_obj);
    }
    conds.Push(_entry);
  }
  template <typename T>
  Condition(T _cond_id, MqlParam &_args[], void *_obj = NULL) {
    Init();
    ConditionEntry _entry(_cond_id);
    _entry.SetArgs(_args);
    if (_obj != NULL) {
      _entry.SetObject(_obj);
    }
    conds.Push(_entry);
  }

  /**
   * Class copy constructor.
   */
  Condition(Condition &_cond) { conds = _cond.GetConditions(); }

  /* Main methods */

  /**
   * Test conditions.
   */
  bool Test() {
    bool _result = false, _prev_result = true;
    for (DictStructIterator<short, ConditionEntry> iter = conds.Begin(); iter.IsValid(); ++iter) {
      bool _curr_result = false;
      ConditionEntry _entry = iter.Value();
      if (!_entry.IsValid()) {
        // Ignore invalid entries.
        continue;
      }
      if (_entry.IsActive()) {
        switch (_entry.next_statement) {
          case COND_AND:
            _curr_result = _prev_result && this.Test(_entry);
            break;
          case COND_OR:
            _curr_result = _prev_result || this.Test(_entry);
            break;
          case COND_SEQ:
            _curr_result = this.Test(_entry);
            if (!_curr_result) {
              // Do not check further conditions when the current condition is false.
              return false;
            }
        }
        _result = _prev_result = _curr_result;
      }
    }
    return _result;
  }

  /**
   * Test specific condition.
   */
  static bool Test(ConditionEntry &_entry) {
    bool _result = false;
    switch (_entry.type) {
      case COND_TYPE_ACCOUNT:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Account *)_entry.obj).CheckCondition((ENUM_ACCOUNT_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
      case COND_TYPE_CHART:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Chart *)_entry.obj).CheckCondition((ENUM_CHART_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
      case COND_TYPE_DATETIME:
        if (Object::IsValid(_entry.obj)) {
          _result = ((DateTime *)_entry.obj).CheckCondition((ENUM_DATETIME_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = DateTime::CheckCondition((ENUM_DATETIME_CONDITION)_entry.cond_id, _entry.args);
        }
        break;
      case COND_TYPE_EA:
        if (Object::IsValid(_entry.obj)) {
          _result = ((EA *)_entry.obj).CheckCondition((ENUM_EA_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#ifdef INDICATOR_MQH
      case COND_TYPE_INDICATOR:
        if (Object::IsValid(_entry.obj)) {
          _result = ((IndicatorBase *)_entry.obj).CheckCondition((ENUM_INDICATOR_CONDITION)_entry.cond_id, _entry.args);
        } else {
          // Static method not supported.
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
      case COND_TYPE_MARKET:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Market *)_entry.obj).CheckCondition((ENUM_MARKET_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#ifdef MATH_H
      case COND_TYPE_MATH:
        /*
          if (Object::IsValid(_entry.obj)) {
            _result = ((Math *)_entry.obj).CheckCondition((ENUM_MATH_CONDITION)_entry.cond_id, _entry.args);
          } else {
            _result = false;
            _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
          }
          */
        return false;
        break;
#endif  // MATH_M
#ifdef ORDER_MQH
      case COND_TYPE_ORDER:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Order *)_entry.obj).CheckCondition((ENUM_ORDER_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
#ifdef STRATEGY_MQH
      case COND_TYPE_STRATEGY:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Strategy *)_entry.obj).CheckCondition((ENUM_STRATEGY_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
#ifdef TASK_MQH
      case COND_TYPE_TASK:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Task *)_entry.obj).CheckCondition((ENUM_TASK_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
      case COND_TYPE_TRADE:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Trade *)_entry.obj).CheckCondition((ENUM_TRADE_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#ifdef TERMINAL_MQH
      case COND_TYPE_TERMINAL:
        if (Object::IsValid(_entry.obj)) {
          _result = ((Terminal *)_entry.obj).CheckCondition((ENUM_TERMINAL_CONDITION)_entry.cond_id, _entry.args);
        } else {
          _result = false;
          _entry.AddFlags(COND_ENTRY_FLAG_IS_INVALID);
        }
        break;
#endif
    }
    if (_result) {
      _entry.last_success = TimeCurrent();
      _entry.tries--;
    }
    _entry.last_check = TimeCurrent();
    return _result;
  }

  /* Other methods */

  /* Getters */

  /**
   * Returns conditions.
   */
  DictStruct<short, ConditionEntry> *GetConditions() { return &conds; }

  /* Setters */
};
#endif  // CONDITION_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Condition.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Task.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Condition.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Task.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Action.struct.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Task's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.




struct TaskEntry {
  ActionEntry action;     // Action of the task.
  ConditionEntry cond;    // Condition of the task.
  datetime expires;       // Time of expiration.
  datetime last_process;  // Time of the last process.
  datetime last_success;  // Time of the last success.
  unsigned char flags;    // Action flags.
  // Constructors.
  void TaskEntry() { Init(); }
  void TaskEntry(ActionEntry &_action, ConditionEntry &_cond) : action(_action), cond(_cond) { Init(); }
  void TaskEntry(long _aid, ENUM_ACTION_TYPE _atype, long _cid, ENUM_CONDITION_TYPE _ctype)
      : action(_aid, _atype), cond(_cid, _ctype) {
    Init();
  }
  template <typename AE, typename CE>
  void TaskEntry(AE _aid, CE _cid) : action(_aid), cond(_cid) {
    Init();
  }
  // Main methods.
  void Init() {
    flags = TASK_ENTRY_FLAG_NONE;
    SetFlag(TASK_ENTRY_FLAG_IS_ACTIVE, action.IsActive() && cond.IsActive());
    SetFlag(TASK_ENTRY_FLAG_IS_INVALID, action.IsInvalid() || cond.IsInvalid());
    expires = last_process = last_success = 0;
  }
  // Flag methods.
  bool HasFlag(unsigned char _flag) { return bool(flags & _flag); }
  void AddFlags(unsigned char _flags) { flags |= _flags; }
  void RemoveFlags(unsigned char _flags) { flags &= ~_flags; }
  void SetFlag(ENUM_TASK_ENTRY_FLAGS _flag, bool _value) {
    if (_value)
      AddFlags(_flag);
    else
      RemoveFlags(_flag);
  }
  void SetFlags(unsigned char _flags) { flags = _flags; }
  // State methods.
  bool IsActive() { return HasFlag(ACTION_ENTRY_FLAG_IS_ACTIVE); }
  bool IsDone() { return HasFlag(ACTION_ENTRY_FLAG_IS_DONE); }
  bool IsFailed() { return HasFlag(ACTION_ENTRY_FLAG_IS_FAILED); }
  bool IsValid() { return !HasFlag(ACTION_ENTRY_FLAG_IS_INVALID); }
  // Getters.
  long GetActionId() { return action.GetId(); }
  long GetConditionId() { return cond.GetId(); }
  ActionEntry GetAction() { return action; }
  ConditionEntry GetCondition() { return cond; }
  ENUM_ACTION_TYPE GetActionType() { return action.GetType(); }
  ENUM_CONDITION_TYPE GetConditionType() { return cond.GetType(); }
  // Setters.
  void SetActionObject(void *_obj) { action.SetObject(_obj); }
  void SetConditionObject(void *_obj) { cond.SetObject(_obj); }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Task.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Provides integration with tasks (manages conditions and actions).
 */

// Prevents processing this includes file for the second time.
#ifndef TASK_MQH
#define TASK_MQH

// Includes.







class Task {
 protected:
  // Class variables.
  Ref<Log> logger;

 public:
  // Class variables.
  DictStruct<short, TaskEntry> tasks;

  /* Special methods */

  /**
   * Class constructor.
   */
  Task() {}
  Task(TaskEntry &_entry) { Add(_entry); }

  /**
   * Class copy constructor.
   */
  Task(Task &_task) { tasks = _task.GetTasks(); }

  /**
   * Class deconstructor.
   */
  ~Task() {}

  Log *Logger() { return logger.Ptr(); }

  /* Main methods */

  /**
   * Adds new task.
   */
  void Add(TaskEntry &_entry) { tasks.Push(_entry); }

  /**
   * Process tasks.
   *
   * @return
   *   Returns true when tasks has been processed.
   */
  bool Process() {
    bool _result = false;
    for (DictStructIterator<short, TaskEntry> iter = tasks.Begin(); iter.IsValid(); ++iter) {
      bool _curr_result = false;
      TaskEntry _entry = iter.Value();
      Process(_entry);
    }
    return _result;
  }

  /**
   * Process task entry.
   *
   * @return
   *   Returns true when tasks has been processed.
   */
  static bool Process(TaskEntry &_entry) {
    bool _result = false;
    if (_entry.IsActive()) {
      if (Condition::Test(_entry.GetCondition())) {
        ActionEntry _action = _entry.GetAction();
        Action::Execute(_action);
        if (_action.IsDone()) {
          _entry.SetFlag(TASK_ENTRY_FLAG_IS_DONE, _action.IsDone());
          _entry.SetFlag(TASK_ENTRY_FLAG_IS_FAILED, _action.IsFailed());
          _entry.SetFlag(TASK_ENTRY_FLAG_IS_INVALID, _action.IsInvalid());
          _entry.RemoveFlags(TASK_ENTRY_FLAG_IS_ACTIVE);
        }
      }
      _entry.last_process = TimeCurrent();
      _result = true;
    }
    return _result;
  }

  /* State methods */

  /**
   * Check if task is active.
   */
  bool IsActive() {
    // The whole task is active when at least one task is active.
    return GetFlagCount(TASK_ENTRY_FLAG_IS_ACTIVE) > 0;
  }

  /**
   * Check if task is done.
   */
  bool IsDone() {
    // The whole task is done when all tasks has been executed successfully.
    return GetFlagCount(TASK_ENTRY_FLAG_IS_DONE) == tasks.Size();
  }

  /**
   * Check if task is failed.
   */
  bool IsFailed() {
    // The whole task is failed when at least one task failed.
    return GetFlagCount(TASK_ENTRY_FLAG_IS_FAILED) > 0;
  }

  /**
   * Check if task is finished.
   */
  bool IsFinished() {
    // The whole task is finished when there are no more active tasks.
    return GetFlagCount(TASK_ENTRY_FLAG_IS_ACTIVE) == 0;
  }

  /**
   * Check if task is invalid.
   */
  bool IsInvalid() {
    // The whole task is invalid when at least one task is invalid.
    return GetFlagCount(TASK_ENTRY_FLAG_IS_INVALID) > 0;
  }

  /* Getters */

  /**
   * Returns tasks.
   */
  DictStruct<short, TaskEntry> *GetTasks() { return &tasks; }

  /**
   * Count entry flags.
   */
  unsigned int GetFlagCount(ENUM_TASK_ENTRY_FLAGS _flag) {
    unsigned int _counter = 0;
    for (DictStructIterator<short, TaskEntry> iter = tasks.Begin(); iter.IsValid(); ++iter) {
      TaskEntry _entry = iter.Value();
      if (_entry.HasFlag(_flag)) {
        _counter++;
      }
    }
    return _counter;
  }

  /* Setters */

  /**
   * Sets entry flags.
   */
  bool SetFlags(ENUM_TASK_ENTRY_FLAGS _flag, bool _value = true) {
    unsigned int _counter = 0;
    for (DictStructIterator<short, TaskEntry> iter = tasks.Begin(); iter.IsValid(); ++iter) {
      TaskEntry _entry = iter.Value();
      switch (_value) {
        case false:
          if (_entry.HasFlag(_flag)) {
            _entry.SetFlag(_flag, _value);
            _counter++;
          }
          break;
        case true:
          if (!_entry.HasFlag(_flag)) {
            _entry.SetFlag(_flag, _value);
            _counter++;
          }
          break;
      }
    }
    return _counter > 0;
  }

  /* Conditions and actions */

  /**
   * Checks for Task condition.
   *
   * @param ENUM_TASK_CONDITION _cond
   *   Task condition.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_TASK_CONDITION _cond, DataParamEntry &_args[]) {
    switch (_cond) {
      case TASK_COND_IS_ACTIVE:
        // Is active;
        return IsActive();
      case TASK_COND_IS_DONE:
        // Is done.
        return IsDone();
      case TASK_COND_IS_FAILED:
        // Is failed.
        return IsFailed();
      case TASK_COND_IS_FINISHED:
        // Is finished.
        return IsFinished();
      case TASK_COND_IS_INVALID:
        // Is invalid.
        return IsInvalid();
      default:
        Logger().Error(StringFormat("Invalid Task condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
        return false;
    }
  }
  bool CheckCondition(ENUM_TASK_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return Task::CheckCondition(_cond, _args);
  }

  /**
   * Execute Task action.
   *
   * @param ENUM_TASK_ACTION _action
   *   Task action to execute.
   * @return
   *   Returns true when the action has been executed successfully.
   */
  bool ExecuteAction(ENUM_TASK_ACTION _action, DataParamEntry &_args[]) {
    bool _result = true;
    switch (_action) {
      case TASK_ACTION_PROCESS:
        // Process tasks.
        return Process();
      default:
        Logger().Error(StringFormat("Invalid Task action: %s!", EnumToString(_action), __FUNCTION_LINE__));
        return false;
    }
    return _result;
  }
  bool ExecuteAction(ENUM_TASK_ACTION _action) {
    ARRAY(DataParamEntry, _args);
    return Task::ExecuteAction(_action, _args);
  }

  /* Other methods */
};
#endif  // TASK_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Task.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Strategy.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Serializer.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Strategy.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Strategy.struct.pricestop.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Chart.struct.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Indicator's signal structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Forward declaration.
struct ChartParams;
struct IndicatorDataEntry;
struct IndicatorParams;

// Includes.


/* Structure for strategy price stops. */
struct StrategyPriceStop {
  /* Define enumeration for strategy price stops. */
  enum ENUM_STRATEGY_PRICE_STOP {
    STRATEGY_PRICE_STOP_NONE = 0 << 0,                  // (None)
    STRATEGY_PRICE_STOP_INDI_PEAK = 1 << 0,             // Indicator value peak.
    STRATEGY_PRICE_STOP_INDI_PRICE = 1 << 1,            // Indicator value.
    STRATEGY_PRICE_STOP_PRICE = 1 << 2,                 // Price value.
    STRATEGY_PRICE_STOP_PRICE_PEAK = 1 << 3,            // Price value peak.
    STRATEGY_PRICE_STOP_PRICE_PP = 1 << 4,              // Price value of Pivot res/sup.
    STRATEGY_PRICE_STOP_VALUE_ADD_PRICE_DIFF = 1 << 5,  // Add price difference.
    STRATEGY_PRICE_STOP_VALUE_ADD_RANGE = 1 << 6,       // Add candle range to the trail value.
    // STRATEGY_PRICE_STOP_INDI_CHG_PCT = 1 << 0,  // Indicator value change (%).
  };

  float ivalue;         // Indicator price value.
  unsigned int method;  // Store price stop methods (@see: ENUM_STRATEGY_PRICE_STOP).
  // unsigned int mode[2]; // Indicator modes to use.
  ChartParams cparams;
  // IndicatorDataEntry idata[];
  // IndicatorParams iparams;

  /* Constructors */
  void StrategyPriceStop(int _method = 0, float _ivalue = 0) : method(_method), ivalue(_ivalue) {}
  // Main methods.
  // Calculate price stop value.
  float GetValue(int _shift = 0, int _direction = -1, float _min_trade_dist = 0.0f) {
    float _result = ivalue, _trail = _min_trade_dist;
    BarOHLC _ohlc0 = Chart::GetOHLC(cparams.tf.GetTf(), 0, cparams.symbol);
    BarOHLC _ohlc1 = Chart::GetOHLC(cparams.tf.GetTf(), _shift, cparams.symbol);
    if (CheckMethod(STRATEGY_PRICE_STOP_INDI_PRICE)) {
      _result = ivalue;
    }
    if (CheckMethod(STRATEGY_PRICE_STOP_PRICE)) {
      // Use price as a base line for the stop value.
      float _price;
      ENUM_APPLIED_PRICE _ap = PRICE_WEIGHTED;
      if (CheckMethod(STRATEGY_PRICE_STOP_PRICE_PEAK)) {
        // On peak, use low or high prices instead.
        _ap = _direction > 0 ? PRICE_HIGH : PRICE_LOW;
      }
      _price = (float)ChartStatic::iPrice(_ap, cparams.symbol, cparams.tf.GetTf(), _shift);
      _result = _direction > 0 ? fmax(_price, _result) : fmin(_price, _result);
    }
    if (CheckMethod(STRATEGY_PRICE_STOP_PRICE_PP)) {
      float _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4;
      float _prices[4];
      _prices[0] = _ohlc0.GetClose();
      _prices[1] = _direction > 0 ? _ohlc0.GetHigh() : _ohlc0.GetLow();
      _prices[2] = _direction > 0 ? _ohlc1.GetHigh() : _ohlc1.GetLow();
      _prices[3] = _ohlc1.GetOpen();
      BarOHLC _ohlc_pp(_prices, _ohlc0.GetTime());
      _ohlc_pp.GetPivots(PP_CLASSIC, _pp, _r1, _r2, _r3, _r4, _s1, _s2, _s3, _s4);
      _result = _direction > 0 ? fmax(_r1, _result) : fmin(_s1, _result);
    }
    if (CheckMethod(STRATEGY_PRICE_STOP_VALUE_ADD_PRICE_DIFF)) {
      _trail += fabs(_ohlc0.GetPivot() - _ohlc1.GetPivot());
    }
    if (CheckMethod(STRATEGY_PRICE_STOP_VALUE_ADD_RANGE)) {
      _trail += _ohlc1.GetRange();
    }
    _result = _result > 0 ? (_direction > 0 ? _result + _trail : _result - _trail) : 0;
    return _result;
  }
  /* Setters */
  void SetChartParams(ChartParams &_cparams) { cparams = _cparams; }
  void SetIndicatorPriceValue(float _ivalue) { ivalue = _ivalue; }
  /*
  void SetIndicatorDataEntry(IndicatorDataEntry &_data[]) {
    int _asize = ArraySize(idata);
    for (int i = 0; i < _asize; i++) {
      idata[i] = _data[i];
    }
  }
  void SetIndicatorParams(IndicatorParams &_iparams, int _m1 = 0, int _m2 = 0) {
    iparams = _iparams;
    mode[0] = _m1;
    mode[1] = _m2;
  }
  */
  /* Flag getters */
  bool CheckMethod(unsigned int _flags) { return (method & _flags) != 0; }
  bool CheckMethodsXor(unsigned int _flags) { return (method ^ _flags) != 0; }
  bool CheckMethodAll(unsigned int _flags) { return (method & _flags) == _flags; }
  bool CheckMethodXorAll(unsigned int _flags) { return (method ^ _flags) == _flags; }
  unsigned int GetMethod() { return method; }
  /* Flag setters */
  void AddMethod(unsigned int _flags) { method |= _flags; }
  void RemoveMethod(unsigned int _flags) { method &= ~_flags; }
  void SetMethod(ENUM_STRATEGY_PRICE_STOP _flag, bool _value = true) {
    if (_value) {
      AddMethod(_flag);
    } else {
      RemoveMethod(_flag);
    }
  }
  void SetMethod(unsigned int _flags) { method = _flags; }
  /* Serializers */
  SerializerNodeType Serialize(Serializer &_s) {
    int _size = sizeof(int) * 8;
    for (int i = 0; i < _size; i++) {
      int _value = CheckMethod(1 << i) ? 1 : 0;
      _s.Pass(this, (string)(i + 1), _value, SERIALIZER_FIELD_FLAG_DYNAMIC | SERIALIZER_FIELD_FLAG_FEATURE);
    }
    return SerializerNodeObject;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Strategy.struct.pricestop.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Task.struct.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes Strategy's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.





// Forward class declaration.
class Strategy;
class Trade;

/* Structure for strategy parameters. */
struct StgParams {
  // Strategy config parameters.
  bool is_enabled;                 // State of the strategy (whether enabled or not).
  bool is_suspended;               // State of the strategy (whether suspended or not)
  bool is_boosted;                 // State of the boost feature (to increase lot size).
  float weight;                    // Weight of the strategy.
  long order_close_time;           // Order close time in mins (>0) or bars (<0).
  float order_close_loss;          // Order close loss (in pips).
  float order_close_profit;        // Order close profit (in pips).
  int signal_open_method;          // Signal open method.
  float signal_open_level;         // Signal open level.
  int signal_open_filter_method;   // Signal open filter method.
  int signal_open_filter_time;     // Signal open filter time.
  int signal_open_boost;           // Signal open boost method (for lot size increase).
  int signal_close_method;         // Signal close method.
  float signal_close_level;        // Signal close level.
  int signal_close_filter_method;  // Signal close filter method.
  int signal_close_filter_time;    // Signal close filter method.
  int price_profit_method;         // Price profit method.
  float price_profit_level;        // Price profit level.
  int price_stop_method;           // Price stop method.
  float price_stop_level;          // Price stop level.
  int tick_filter_method;          // Tick filter.
  float trend_threshold;           // Trend strength threshold.
  float lot_size;                  // Lot size to trade.
  float lot_size_factor;           // Lot size multiplier factor.
  float max_risk;                  // Maximum risk to take (1.0 = normal, 2.0 = 2x).
  float max_spread;                // Maximum spread to trade (in pips).
  int tp_max;                      // Hard limit on maximum take profit (in pips).
  int sl_max;                      // Hard limit on maximum stop loss (in pips).
  int type;                        // Strategy type (@see: ENUM_STRATEGY).
  long id;                         // Unique identifier of the strategy.
  datetime refresh_time;           // Order refresh frequency (in sec).
  short shift;                     // Shift (relative to the current bar, 0 - default)
  ChartTf tf;                      // Main timeframe where strategy operates on.
  // Constructor.
  StgParams()
      : id(rand()),
        is_enabled(true),
        is_suspended(false),
        is_boosted(true),
        order_close_time(0),
        order_close_loss(0.0f),
        order_close_profit(0.0f),
        weight(0),
        signal_open_method(0),
        signal_open_level(0),
        signal_open_filter_method(0),
        signal_open_filter_time(0),
        signal_open_boost(0),
        signal_close_method(0),
        signal_close_level(0),
        signal_close_filter_method(0),
        signal_close_filter_time(0),
        price_profit_method(0),
        price_profit_level(0),
        price_stop_method(0),
        price_stop_level(0),
        tick_filter_method(0),
        trend_threshold(0.4f),
        lot_size(0),
        lot_size_factor(1.0),
        max_risk(1.0),
        max_spread(0.0),
        shift(0),
        tp_max(0),
        sl_max(0),
        type(0),
        refresh_time(0) {}
  StgParams(int _som, int _sofm, float _sol, int _sob, int _scm, int _scfm, float _scl, int _psm, float _psl, int _tfm,
            float _ms, short _s = 0)
      : id(rand()),
        order_close_loss(0.0f),
        order_close_profit(0.0f),
        order_close_time(0),
        signal_open_method(_som),
        signal_open_filter_method(_sofm),
        signal_open_level(_sol),
        signal_open_boost(_sob),
        signal_close_method(_scm),
        signal_close_filter_method(_scfm),
        signal_close_filter_time(0),
        signal_close_level(_scl),
        price_profit_method(_psm),
        price_profit_level(_psl),
        price_stop_method(_psm),
        price_stop_level(_psl),
        tick_filter_method(_tfm),
        shift(_s),
        is_enabled(true),
        is_suspended(false),
        is_boosted(true),
        weight(0),
        lot_size(0),
        lot_size_factor(1.0),
        max_risk(1.0),
        max_spread(0.0),
        tp_max(0),
        sl_max(0),
        type(0),
        refresh_time(0) {}
  StgParams(StgParams &_stg_params) { this = _stg_params; }
  // Deconstructor.
  ~StgParams() {}

  // Getters.
  template <typename T>
  T Get(ENUM_STRATEGY_PARAM _param) {
    switch (_param) {
      case STRAT_PARAM_ID:
        return (T)id;
      case STRAT_PARAM_LS:
        return (T)lot_size;
      case STRAT_PARAM_LSF:
        return (T)lot_size_factor;
      case STRAT_PARAM_MAX_RISK:
        return (T)max_risk;
      case STRAT_PARAM_MAX_SPREAD:
        return (T)max_spread;
      case STRAT_PARAM_SOL:
        return (T)signal_open_level;
      case STRAT_PARAM_SCL:
        return (T)signal_close_level;
      case STRAT_PARAM_PPL:
        return (T)price_profit_level;
      case STRAT_PARAM_PSL:
        return (T)price_stop_level;
      case STRAT_PARAM_OCL:
        return (T)order_close_loss;
      case STRAT_PARAM_OCP:
        return (T)order_close_profit;
      case STRAT_PARAM_OCT:
        return (T)order_close_time;
      case STRAT_PARAM_SOM:
        return (T)signal_open_method;
      case STRAT_PARAM_SOFM:
        return (T)signal_open_filter_method;
      case STRAT_PARAM_SOFT:
        return (T)signal_open_filter_time;
      case STRAT_PARAM_SOB:
        return (T)signal_open_boost;
      case STRAT_PARAM_SCFM:
        return (T)signal_close_filter_method;
      case STRAT_PARAM_SCFT:
        return (T)signal_close_filter_time;
      case STRAT_PARAM_SCM:
        return (T)signal_close_method;
      case STRAT_PARAM_SHIFT:
        return (T)shift;
      case STRAT_PARAM_PPM:
        return (T)price_profit_method;
      case STRAT_PARAM_PSM:
        return (T)price_stop_method;
      case STRAT_PARAM_TF:
        return (T)tf.GetTf();
      case STRAT_PARAM_TFM:
        return (T)tick_filter_method;
      case STRAT_PARAM_TYPE:
        return (T)type;
      case STRAT_PARAM_WEIGHT:
        return (T)weight;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return WRONG_VALUE;
  }
  bool IsBoosted() { return is_boosted; }
  bool IsEnabled() { return is_enabled; }
  bool IsSuspended() { return is_suspended; }
  // Setters.
  template <typename T>
  void Set(ENUM_STRATEGY_PARAM _param, T _value) {
    switch (_param) {
      case STRAT_PARAM_ID:  // ID (magic number).
        id = (long)_value;
        return;
      case STRAT_PARAM_LS:  // Lot size
        lot_size = (float)_value;
        return;
      case STRAT_PARAM_LSF:  // Lot size factor
        lot_size_factor = (float)_value;
        return;
      case STRAT_PARAM_MAX_RISK:
        max_risk = (float)_value;
        return;
      case STRAT_PARAM_MAX_SPREAD:
        max_spread = (float)_value;
        return;
      case STRAT_PARAM_SHIFT:  // Shift
        shift = (short)_value;
        return;
      case STRAT_PARAM_SOL:  // Signal open level
        signal_open_level = (float)_value;
        return;
      case STRAT_PARAM_SCL:  // Signal close level
        signal_close_level = (float)_value;
        return;
      case STRAT_PARAM_PPL:  // Signal profit level
        price_profit_level = (float)_value;
        return;
      case STRAT_PARAM_PSL:  // Price stop level
        price_stop_level = (float)_value;
        return;
      case STRAT_PARAM_OCL:  // Order close loss
        order_close_loss = (float)_value;
        return;
      case STRAT_PARAM_OCP:  // Order close profit
        order_close_profit = (float)_value;
        return;
      case STRAT_PARAM_OCT:  // Order close time
        order_close_time = (long)_value;
        return;
      case STRAT_PARAM_SOM:  // Signal open method
        signal_open_method = (int)_value;
        return;
      case STRAT_PARAM_SOFM:  // Signal open filter method
        signal_open_filter_method = (int)_value;
        return;
      case STRAT_PARAM_SOFT:  // Signal open filter time
        signal_open_filter_time = (int)_value;
        return;
      case STRAT_PARAM_SOB:  // Signal open boost method
        signal_open_boost = (int)_value;
        return;
      case STRAT_PARAM_SCFM:  // Signal close filter method
        signal_close_filter_method = (int)_value;
        return;
      case STRAT_PARAM_SCFT:  // Signal close filter time
        signal_close_filter_time = (int)_value;
        return;
      case STRAT_PARAM_SCM:  // Signal close method
        signal_close_method = (int)_value;
        return;
      case STRAT_PARAM_PPM:  // Signal profit method
        price_profit_method = (int)_value;
        return;
      case STRAT_PARAM_PSM:  // Price stop method
        price_stop_method = (int)_value;
        return;
      case STRAT_PARAM_TF:
        // Main timeframe where strategy operates on.
        tf = (ENUM_TIMEFRAMES)_value;
        return;
      case STRAT_PARAM_TFM:  // Tick filter method
        tick_filter_method = (int)_value;
        return;
      case STRAT_PARAM_TYPE:
        // Strategy type.
        type = (int)_value;
        return;
      case STRAT_PARAM_WEIGHT:  // Weight
        weight = (float)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(ENUM_STRATEGY_PARAM _enum_param, MqlParam &_mql_param) {
    if (_mql_param.type == TYPE_DOUBLE || _mql_param.type == TYPE_FLOAT) {
      Set(_enum_param, _mql_param.double_value);
    } else {
      Set(_enum_param, _mql_param.integer_value);
    }
  }
  void SetId(long _id) { id = _id; }
  void SetStops(Strategy *_sl = NULL, Strategy *_tp = NULL) {
    // @todo: To remove.
  }
  void SetSignals(int _som, float _sol, int _sofm, int _sob, int _csm, float _cl) {
    signal_open_method = _som;
    signal_open_level = _sol;
    signal_open_filter_method = _sofm;
    signal_open_boost = _sob;
    signal_close_method = _csm;
    signal_close_level = _cl;
  }
  void Enabled(bool _is_enabled) { is_enabled = _is_enabled; };
  void Suspended(bool _is_suspended) { is_suspended = _is_suspended; };
  void Boost(bool _is_boosted) { is_boosted = _is_boosted; };
  // Printers.
  string ToString() {
    // SerializerConverter _stub = SerializerConverter::MakeStubObject<StrategySignal>(SERIALIZER_FLAG_SKIP_HIDDEN);
    return SerializerConverter::FromObject(THIS_REF, SERIALIZER_FIELD_FLAG_DEFAULT | SERIALIZER_FLAG_SKIP_HIDDEN)
        .ToString<SerializerJson>(SERIALIZER_JSON_NO_WHITESPACES);
  }

  // Serializers.
  SERIALIZER_EMPTY_STUB;
  SerializerNodeType Serialize(Serializer &s) {
    s.Pass(THIS_REF, "is_enabled", is_enabled);
    s.Pass(THIS_REF, "is_suspended", is_suspended);
    s.Pass(THIS_REF, "is_boosted", is_boosted);
    s.Pass(THIS_REF, "id", id);
    s.Pass(THIS_REF, "weight", weight);
    s.Pass(THIS_REF, "ocl", order_close_loss);
    s.Pass(THIS_REF, "ocp", order_close_profit);
    s.Pass(THIS_REF, "oct", order_close_time);
    s.Pass(THIS_REF, "shift", shift);
    s.Pass(THIS_REF, "som", signal_open_method);
    s.Pass(THIS_REF, "sol", signal_open_level);
    s.Pass(THIS_REF, "sofm", signal_open_filter_method);
    s.Pass(THIS_REF, "soft", signal_open_filter_time);
    s.Pass(THIS_REF, "sob", signal_open_boost);
    s.Pass(THIS_REF, "scm", signal_close_method);
    s.Pass(THIS_REF, "scfm", signal_close_filter_method);
    s.Pass(THIS_REF, "scft", signal_close_filter_time);
    s.Pass(THIS_REF, "scl", signal_close_level);
    s.Pass(THIS_REF, "ppm", price_profit_method);
    s.Pass(THIS_REF, "ppl", price_profit_level);
    s.Pass(THIS_REF, "psm", price_stop_method);
    s.Pass(THIS_REF, "psl", price_stop_level);
    s.Pass(THIS_REF, "tfm", tick_filter_method);
    s.Pass(THIS_REF, "tt", trend_threshold);
    s.Pass(THIS_REF, "ls", lot_size);
    s.Pass(THIS_REF, "lsf", lot_size_factor);
    s.Pass(THIS_REF, "max_risk", max_risk);
    s.Pass(THIS_REF, "max_spread", max_spread);
    s.Pass(THIS_REF, "tp_max", tp_max);
    s.Pass(THIS_REF, "sl_max", sl_max);
    s.Pass(THIS_REF, "refresh_time", refresh_time);
    // @todo
    // Ref<Log> logger;           // Reference to Log object.
    // Trade *trade;              // Pointer to Trade class.
    // Indicator *data;           // Pointer to Indicator class.
    // Strategy *sl, *tp;         // References to Strategy class (stop-loss and profit-take).
    return SerializerNodeObject;
  }
} stg_params_defaults;

/* Structure for strategy's param values. */
struct Stg_Params {
  string symbol;
  ENUM_TIMEFRAMES tf;
  Stg_Params() : symbol(_Symbol), tf((ENUM_TIMEFRAMES)_Period) {}
};

/* Structure for strategy's process results. */
struct StgProcessResult {
  float boost_factor;                  // Boost factor used.
  float lot_size;                      // Lot size used.
  unsigned int last_error;             // Last error code.
  unsigned short pos_updated;          // Number of positions updated.
  unsigned short stops_invalid_sl;     // Number of invalid stop-loss values.
  unsigned short stops_invalid_tp;     // Number of invalid take-profit values.
  unsigned short tasks_processed;      // Task processed.
  unsigned short tasks_processed_not;  // Task not processed.
  // Struct constructor.
  StgProcessResult() { Reset(); }
  // Getters.
  float GetBoostFactor() { return boost_factor; }
  float GetLotSize() { return lot_size; }
  string ToString() { return StringFormat("%d,%d,%d,%d", pos_updated, stops_invalid_sl, stops_invalid_tp, last_error); }
  // Setters.
  void ProcessLastError() { last_error = fmax(last_error, Terminal::GetLastError()); }
  void Reset() {
    pos_updated = stops_invalid_sl = stops_invalid_tp = 0;
    last_error = ERR_NO_ERROR;
  }
  void SetBoostFactor(float _value) { boost_factor = _value; }
  void SetLotSize(float _value) { lot_size = _value; }
  // Serializers.
  SERIALIZER_EMPTY_STUB;
  SerializerNodeType Serialize(Serializer &_s) {
    _s.Pass(THIS_REF, "boost_factor", boost_factor, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "lot_size", lot_size, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "last_error", last_error, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "pos_updated", pos_updated, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "stops_invalid_sl", stops_invalid_sl, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "stops_invalid_tp", stops_invalid_tp, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "tasks_processed", tasks_processed, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "tasks_processed_not", tasks_processed_not, SERIALIZER_FIELD_FLAG_DYNAMIC);
    return SerializerNodeObject;
  }
};

/* Struture for strategy statistics */
struct StgStats {
  uint orders_open;  // Number of current opened orders.
  uint errors;       // Count reported errors.
};

/* Structure for strategy's statistical periods. */
struct StgStatsPeriod {
  // Statistics variables.
  uint orders_total;     // Number of total opened orders.
  uint orders_won;       // Number of total won orders.
  uint orders_lost;      // Number of total lost orders.
  double avg_spread;     // Average spread.
  double net_profit;     // Total net profit.
  double gross_profit;   // Total gross profit.
  double gross_loss;     // Total gross loss.
  double profit_factor;  // Profit factor.
  // Getters.
  string ToCSV() {
    return StringFormat("%d,%d,%d,%g,%g,%g,%g,%g", orders_total, orders_won, orders_lost, avg_spread, net_profit,
                        gross_profit, gross_loss, profit_factor);
  }
};

/* Structure for strategy's entry values. */
struct StgEntry {
  unsigned short signals;
  StgStatsPeriod stats_period[FINAL_ENUM_STRATEGY_STATS_PERIOD];
  string ToCSV() {
    return StringFormat("%s,%s,%s,%s", stats_period[(int)EA_STATS_DAILY].ToCSV(),
                        stats_period[(int)EA_STATS_WEEKLY].ToCSV(), stats_period[(int)EA_STATS_MONTHLY].ToCSV(),
                        stats_period[(int)EA_STATS_TOTAL].ToCSV());
  }
  // Struct setters.
  void SetStats(StgStatsPeriod &_stats, ENUM_STRATEGY_STATS_PERIOD _period) { stats_period[(int)_period] = _stats; }
  // Serializers.
  SERIALIZER_EMPTY_STUB
  SerializerNodeType Serialize(Serializer &_s) {
    // _s.Pass(THIS_REF, "signals", (int) signals);
    return SerializerNodeObject;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Strategy.struct.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: BasicTrade.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Provides basic trade functionality.
 */

// Class dependencies.
#ifdef __MQL5__
class CTrade;
#endif

//---
#define CUR    0
#define PREV   1
#define FAR    2
//---
#define ERR_ORDER_SELECT            ERR_USER_ERROR_FIRST + 102
#define ERR_INVALID_ORDER_TYPE      ERR_USER_ERROR_FIRST + 103
#define ERR_INVALID_SYMBOL_NAME     ERR_USER_ERROR_FIRST + 104
#define ERR_INVALID_EXPIRATION_TIME ERR_USER_ERROR_FIRST + 105
//---
#define TRADE_PAUSE_SHORT 500
#define TRADE_PAUSE_LONG  5000
#define OPEN_METHODS      8

#ifdef __MQL4__
//+------------------------------------------------------------------+
//|   ENUM_APPLIED_VOLUME                                            |
//+------------------------------------------------------------------+
enum ENUM_APPLIED_VOLUME {
  VOLUME_TICK,
  VOLUME_REAL
};
#endif

//+------------------------------------------------------------------+
#ifdef __MQL4__
#define TFS 9
const ENUM_TIMEFRAMES tf[TFS] = {
  PERIOD_M1,PERIOD_M5,PERIOD_M15,
  PERIOD_M30,PERIOD_H1,PERIOD_H4,
  PERIOD_D1,PERIOD_W1,PERIOD_MN1
};
#endif

//+------------------------------------------------------------------+
#ifdef __MQL5__

#define TFS 21
const ENUM_TIMEFRAMES tf[TFS] = {
  PERIOD_M1,PERIOD_M2,PERIOD_M3,PERIOD_M4,PERIOD_M5,PERIOD_M6,
  PERIOD_M10,PERIOD_M12,PERIOD_M15,PERIOD_M20,PERIOD_M30,PERIOD_H1,
  PERIOD_H2,PERIOD_H3,PERIOD_H4,PERIOD_H6,PERIOD_H8,PERIOD_H12,
  PERIOD_D1,PERIOD_W1,PERIOD_MN1
};
#endif
//+------------------------------------------------------------------+
//|   TPositionCount                                                 |
//+------------------------------------------------------------------+
struct TPositionCount {
  int               buy_count;
  int               sell_count;
};
//+------------------------------------------------------------------+
//|   TDealTime                                                      |
//+------------------------------------------------------------------+
struct TDealTime
{
  datetime          buy_time;
  datetime          sell_time;
};
//+------------------------------------------------------------------+
//|   ENUN_OPEN_METHOD                                               |
//+------------------------------------------------------------------+
enum ENUM_OPEN_METHOD
{
  OPEN_METHOD_ONE=-1,// One Of Methods
  OPEN_METHOD_SUM=0,// Sum Of Methods
  OPEN_METHOD1=1,   // Method #1 (1)
  OPEN_METHOD2=2,   // Method #2 (2)
  OPEN_METHOD3=4,   // Method #3 (4)
  OPEN_METHOD4=8,   // Method #4 (8)
  OPEN_METHOD5=16,  // Method #5 (16)
  OPEN_METHOD6=32,  // Method #6 (32)
  OPEN_METHOD7=64,  // Method #7 (64)
  OPEN_METHOD8=128  // Method #8 (128)
};
//+------------------------------------------------------------------+
//|   GetOpenMethod                                                  |
//+------------------------------------------------------------------+
int GetOpenMethod(const int open_method,const int one_of_methods,const int sum_of_methods)
{
  int result=open_method;

  if(open_method==OPEN_METHOD_ONE)
    result=-one_of_methods;

  if(open_method==OPEN_METHOD_SUM)
    result=sum_of_methods;

  return(result);
}
//+------------------------------------------------------------------+
//|   ENUM_TRADE_DIRECTION                                           |
//+------------------------------------------------------------------+
enum ENUM_TRADE_DIRECTION
{
  TRADE_NONE=-1, //None
  TRADE_BUY=0,   //Buy
  TRADE_SELL=1,  //Sell
  TRADE_BOTH=2   //Both
};
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
enum ENUM_RUN_MODE
{
  RUN_OPTIMIZATION,
  RUN_VISUAL,
  RUN_TESTER,
  RUN_LIVE
};
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
ENUM_RUN_MODE GetRunMode(void)
{
  if(MQLInfoInteger(MQL_OPTIMIZATION))
    return(RUN_OPTIMIZATION);
  if(MQLInfoInteger(MQL_VISUAL_MODE))
    return(RUN_VISUAL);
  if(MQLInfoInteger(MQL_TESTER))
    return(RUN_TESTER);
  return(RUN_LIVE);
}
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string BoolToString(const bool _value)
{
  if(_value)
    return("yes");
  return("no");
}
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string TimeframeToString(const ENUM_TIMEFRAMES _tf)
{
  return(StringSubstr(EnumToString(_tf),7));
}
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
string OpenMethodToString(const ENUM_OPEN_METHOD _open_method,
    const int one_of_methods,
    const int sum_of_methods)
{
  string result="";
  switch(_open_method)
  {
    case OPEN_METHOD_ONE: result="One Of Methods ("+IntegerToString(one_of_methods)+")"; break;
    case OPEN_METHOD_SUM: result="Sum Of Methods ("+IntegerToString(sum_of_methods)+")"; break;
    default: result=StringSubstr(EnumToString(_open_method),5); break;
  }
  return(result);
}

//+------------------------------------------------------------------+
//|   CBasicTrade                                                    |
//+------------------------------------------------------------------+
class CBasicTrade
{
  private:
    int               m_last_error;

  protected:
    //+------------------------------------------------------------------+
    double NormalizeVolume(const double _volume)
    {
      double lot_min=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
      double lot_max=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
      double lot_step=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
      //---
      double lot_value=_volume;
      if(lot_value<=lot_min)lot_value=lot_min;
      else if(lot_value>=lot_max)lot_value=lot_max;
      else lot_value=round(lot_value/lot_step)*lot_step;
      //---
      return(NormalizeDouble(lot_value,2));
    }

    //+------------------------------------------------------------------+
    int   TimeframeToIndex(ENUM_TIMEFRAMES _tf)
    {
      if(_tf==0 || _tf==PERIOD_CURRENT)
        _tf=(ENUM_TIMEFRAMES)_Period;
      int total=ArraySize(tf);
      for(int i=0;i<total;i++)
      {
        if(tf[i]==_tf)
          return(i);
      }
      return(0);
    }

  public:

    //+------------------------------------------------------------------+
    void  CBasicTrade(void)
    {
      m_last_error=0;
    }

    //+------------------------------------------------------------------+
    bool  Trade(string   _symbol,          // symbol
        ENUM_TRADE_DIRECTION _type,// operation
        double   _volume,          // volume
        int      _stop_loss,       // stop loss, pips
        int      _take_profit,     // take profit, pips
        string   _comment=NULL,    // comment
        int      _magic=0          // magic number
        ) {

      ResetLastError();
      m_last_error=0;

      //--- check symbol name
      double _point=SymbolInfoDouble(_symbol,SYMBOL_POINT);
      if(_point==0.0)
      {
        m_last_error=ERR_INVALID_SYMBOL_NAME;
        return(false);
      }

      //--- order type
      if(!(_type==TRADE_BUY || _type==TRADE_SELL))
      {
        m_last_error=ERR_INVALID_ORDER_TYPE;
        return(false);
      }

      //--- get digits
      int _digits=(int)SymbolInfoInteger(_symbol,SYMBOL_DIGITS);

      //--- get coef point
      int _coef_point=1;
      if(_digits==3 || _digits==5)
        _coef_point=10;

#ifdef __MQL4__

      int attempts=5;
      while(attempts>0)
      {
        ResetLastError();

        if(IsTradeContextBusy())
        {
          Sleep(TRADE_PAUSE_SHORT);
          attempts--;
          continue;
        }

        RefreshRates();

        //--- check the free margin
        if(AccountFreeMarginCheck(_symbol,_type,_volume)<=0 || _LastError==ERR_NOT_ENOUGH_MONEY)
        {
          m_last_error=ERR_NOT_ENOUGH_MONEY;
          return(false);
        }

        //---
        double price=0.0;
        if(_type==OP_BUY)
          price=NormalizeDouble(SymbolInfoDouble(_symbol,SYMBOL_ASK),_digits);
        if(_type==OP_SELL)
          price=NormalizeDouble(SymbolInfoDouble(_symbol,SYMBOL_BID),_digits);

        //---
        int slippage=(int)SymbolInfoInteger(_symbol,SYMBOL_SPREAD);

        //---
        double volume=NormalizeVolume(_volume);

        //---
        int ticket=OrderSend(_symbol,_type,volume,price,slippage,0,0,_comment,_magic,0,clrNONE);
        if(ticket>0)
        {
          if(_stop_loss>0 || _take_profit>0)
          {

            if(OrderSelect(ticket,SELECT_BY_TICKET))
            {

              //---
              double order_open_price=NormalizeDouble(OrderOpenPrice(),_digits);
              double order_stop_loss=NormalizeDouble(OrderStopLoss(),_digits);
              double order_take_profit=NormalizeDouble(OrderTakeProfit(),_digits);

              double sl=0.0;
              double tp=0.0;

              //---
              attempts=5;
              while(attempts>0)
              {
                ResetLastError();
                RefreshRates();
                //---
                double _bid = SymbolInfoDouble(_symbol, SYMBOL_BID);
                double _ask = SymbolInfoDouble(_symbol, SYMBOL_ASK);

                if(IsTradeContextBusy())
                {
                  attempts--;
                  Sleep(TRADE_PAUSE_SHORT);
                  continue;
                }

                //---
                int stop_level=(int)SymbolInfoInteger(_symbol,SYMBOL_TRADE_STOPS_LEVEL);
                int spread=(int)SymbolInfoInteger(_symbol,SYMBOL_SPREAD);
                stop_level=fmax(stop_level,spread);

                //---
                if(OrderType()==OP_BUY)
                {
                  if(_stop_loss==-1.0) sl=order_stop_loss;
                  else if(_stop_loss==0.0) sl=0.0;
                  else sl=NormalizeDouble(fmin(order_open_price-_stop_loss*_coef_point*_point,_bid-stop_level*_point),_digits);

                  if(_take_profit==-1.0) tp=order_take_profit;
                  else if(_take_profit==0.0) tp=0.0;
                  else tp=NormalizeDouble(fmax(order_open_price+_take_profit*_coef_point*_point,_bid+stop_level*_point),_digits);
                }

                if(OrderType()==OP_SELL)
                {
                  if(_stop_loss==-1.0) sl=order_stop_loss;
                  else if(_stop_loss==0.0) sl=0.0;
                  else sl=NormalizeDouble(fmax(order_open_price+_stop_loss*_coef_point*_point,_ask+stop_level*_point),_digits);

                  if(_take_profit==-1.0) tp=order_take_profit;
                  else if(_take_profit==0.0) tp=0.0;
                  else tp=NormalizeDouble(fmin(order_open_price-_take_profit*_coef_point*_point,_ask-stop_level*_point),_digits);
                }

                if(sl==order_stop_loss && tp==order_take_profit)
                  return(true);

                //---
                ResetLastError();
                if(OrderModify(ticket,order_open_price,sl,tp,0,clrNONE))
                {
                  return(true);
                }
                else
                {
                  //ENUM_ERROR_LEVEL level=PrintError(_LastError);
                  //if(level==LEVEL_ERROR)
                  {
                    Sleep(TRADE_PAUSE_LONG);
                    return(false);
                  }
                }

                //---
                Sleep(TRADE_PAUSE_SHORT);
                attempts--;
              }// end while

            }

            Sleep(TRADE_PAUSE_SHORT);
            return(true); //position opened
          }
          else
          {
            //ENUM_ERROR_LEVEL level=PrintError(_LastError);
            //if(level==LEVEL_ERROR)
            {
              Sleep(TRADE_PAUSE_LONG);
              break;
            }
          }// end else

          Sleep(TRADE_PAUSE_SHORT);
          attempts--;
        }
      }
#endif

      //---
#ifdef __MQL5__

      ENUM_ORDER_TYPE order_type=-1;
      double price=0.0;
      double sl=0.0;
      double tp=0.0;
      double _ask=SymbolInfoDouble(_symbol,SYMBOL_ASK);
      double _bid=SymbolInfoDouble(_symbol,SYMBOL_BID);
      int stop_level=(int)SymbolInfoInteger(_symbol,SYMBOL_TRADE_STOPS_LEVEL);
      if(_type==TRADE_BUY) {
        order_type=ORDER_TYPE_BUY;
        price=_ask;

        if(_stop_loss>0)
          sl=NormalizeDouble(fmin(price-_stop_loss*_coef_point*_point,_bid-stop_level*_point),_digits);

        if(_take_profit>0)
          tp=NormalizeDouble(fmax(price+_take_profit*_coef_point*_point,_bid+stop_level*_point),_digits);

      }
      if(_type==TRADE_SELL) {
        order_type=ORDER_TYPE_SELL;
        price=_bid;

        if(_stop_loss>0)
          sl=NormalizeDouble(fmax(price+_stop_loss*_coef_point*_point,_ask+stop_level*_point),_digits);

        if(_take_profit>0)
          tp=NormalizeDouble(fmin(price-_take_profit*_coef_point*_point,_ask-stop_level*_point),_digits);
      }

      double volume=NormalizeVolume(_volume);

      #ifdef CTrade
      // @todo: To test.
      CTrade trade;
      if (!trade) {
        return (false);
      }
      trade.SetDeviationInPoints(SymbolInfoInteger(_symbol, SYMBOL_SPREAD));
      trade.SetExpertMagicNumber(_magic);

      //---
      trade.SetTypeFilling(GetTypeFilling(_symbol));
      bool result=trade.PositionOpen(_symbol,order_type,volume,price,sl,tp,_comment);
      if (!result) {
        m_last_error=(int)trade.ResultRetcode();
      }
      #else
        return (false);
      #endif
#endif

      return (true);
    }

    //+------------------------------------------------------------------+
    int GetLastError()
    {
      return(m_last_error);
    }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: BasicTrade.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Dict.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Market.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef STRATEGY_MQH
#define STRATEGY_MQH

// Forward declaration.
class Trade;

// Includes.











// Defines.
// Primary inputs.
#ifdef __input__
#define INPUT input
#ifndef __MQL4__
#define INPUT_GROUP(name) input group #name
#else
#define INPUT_GROUP(name) static input string;  // #name
#endif
#else
#define INPUT static
#define INPUT_GROUP(name) static string
#endif
// Secondary inputs.
#ifdef __input2__
#define INPUT2 input
#ifndef __MQL4__
#define INPUT2_GROUP(name) input group #name
#else
#define INPUT2_GROUP(name) static input string;  // #name
#endif
#else
#define INPUT2 static
#define INPUT2_GROUP(name) static string
#endif
// Tertiary inputs.
#ifdef __input3__
#define INPUT3 input
#ifndef __MQL4__
#define INPUT3_GROUP(name) input group #name
#else
#define INPUT3_GROUP(name) static input string;  // #name
#endif
#else
#define INPUT3 static
#define INPUT3_GROUP(name) static string
#endif
#ifdef __optimize__
#define OINPUT input
#else
#define OINPUT static
#endif

/**
 * Implements strategy class.
 */
class Strategy : public Object {
 public:
  StgParams sparams;

 protected:
  Dict<int, double> ddata;
  Dict<int, float> fdata;
  Dict<int, int> idata;
  DictStruct<int, Ref<IndicatorBase>> indicators;  // Indicators list.
  DictStruct<short, TaskEntry> tasks;
  Log logger;  // Log instance.
  MqlTick last_tick;
  StgProcessResult sresult;
  Strategy *strat_sl, *strat_tp;  // Strategy pointers for stop-loss and profit-take.
  Trade trade;                    // Trade instance.
                                  // TradeSignalEntry last_signal;    // Last signals.

 private:
  // Strategy statistics.
  StgStats stats;
  StgStatsPeriod stats_period[FINAL_ENUM_STRATEGY_STATS_PERIOD];

 protected:
  // Base variables.
  string name;
  // Other variables.
  int filter_method[];    // Filter method to consider the trade.
  int open_condition[];   // Open conditions.
  int close_condition[];  // Close conditions.

 public:
  /* Special methods */

  /**
   * Class constructor.
   */
  Strategy(StgParams &_sparams, TradeParams &_tparams, ChartParams &_cparams, string _name = "")
      : sparams(_sparams), trade(_tparams, _cparams), Object(GetPointer(this), __LINE__) {
    // Initialize variables.
    name = _name;
    MqlTick _tick = {0};
    last_tick = _tick;

    // Link log instances.
    logger.Link(trade.GetLogger());

    // Statistics variables.
    // UpdateOrderStats(EA_STATS_DAILY);
    // UpdateOrderStats(EA_STATS_WEEKLY);
    // UpdateOrderStats(EA_STATS_MONTHLY);
    // UpdateOrderStats(EA_STATS_TOTAL);

    // Call strategy's OnInit method.
    Strategy::OnInit();
  }

  Log *GetLogger() { return GetPointer(logger); }

  /**
   * Class deconstructor.
   */
  ~Strategy() {}

  /* Processing methods */

  /**
   * Process strategy's signals and orders.
   *
   * @param ushort _periods_started
   *   Periods which started.
   *
   * @return
   *   Returns StgProcessResult struct.
   */
  StgProcessResult Process(unsigned short _periods_started = DATETIME_NONE) {
    sresult.last_error = ERR_NO_ERROR;
    if (_periods_started > 0) {
      ProcessTasks();
    }
    return sresult;
  }

  /* Tasks */

  /**
   * Add task.
   */
  void AddTask(TaskEntry &_entry) {
    if (_entry.IsValid()) {
      if (_entry.GetAction().GetType() == ACTION_TYPE_STRATEGY) {
        _entry.SetActionObject(GetPointer(this));
      }
      if (_entry.GetCondition().GetType() == COND_TYPE_STRATEGY) {
        _entry.SetConditionObject(GetPointer(this));
      }
      tasks.Push(_entry);
    }
  }

  /**
   * Process strategy's tasks.
   *
   * @return
   *   Returns StgProcessResult struct.
   */
  void ProcessTasks() {
    for (DictStructIterator<short, TaskEntry> iter = tasks.Begin(); iter.IsValid(); ++iter) {
      bool _is_processed = false;
      TaskEntry _entry = iter.Value();
      _is_processed = Task::Process(_entry);
      sresult.tasks_processed += (unsigned short)_is_processed;
      sresult.tasks_processed_not += (unsigned short)!_is_processed;
    }
  }

  /* State checkers */

  /**
   * Check state of the strategy.
   */
  bool IsEnabled() { return sparams.IsEnabled(); }

  /**
   * Check suspension status of the strategy.
   */
  bool IsSuspended() { return sparams.IsSuspended(); }

  /**
   * Checks if the current price is in trend given the order type.
   */
  bool IsTrend(ENUM_ORDER_TYPE _cmd) {
    bool _result = false;
    double _tvalue = TrendStrength();
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        _result = _tvalue > sparams.trend_threshold;
        break;
      case ORDER_TYPE_SELL:
        _result = _tvalue < -sparams.trend_threshold;
        break;
    }
    return _result;
  }

  /**
   * Check state of the strategy.
   */
  bool IsBoostEnabled() { return sparams.IsBoosted(); }

  /* Class getters */

  /**
   * Returns handler to the strategy's indicator class.
   */
  IndicatorBase *GetIndicator(int _id = 0) {
    if (indicators.KeyExists(_id)) {
      return indicators[_id].Ptr();
    }

    Alert("Missing indicator id ", _id);
    return NULL;
  }

  /**
   * Returns strategy's indicators.
   */
  DictStruct<int, Ref<IndicatorBase>> GetIndicators() { return indicators; }

  /* Struct getters */

  /**
   * Gets result of the last signal processing.
   */
  StgProcessResult GetProcessResult() { return sresult; }

  /* Getters */

  /**
   * Gets a strategy parameter value.
   */
  template <typename T>
  T Get(ENUM_STRATEGY_PARAM _param) {
    return sparams.Get<T>(_param);
  }

  /**
   * Gets a trade parameter value.
   */
  template <typename T>
  T Get(ENUM_TRADE_PARAM _param) {
    return trade.Get<T>(_param);
  }

  /**
   * Gets a trade state value.
   */
  template <typename T>
  T Get(ENUM_TRADE_STATE _prop) {
    return trade.Get<T>(_prop);
  }

  /**
   * Gets strategy entry.
   */
  StgEntry GetEntry() {
    StgEntry _entry = {};
    for (ENUM_STRATEGY_STATS_PERIOD _p = EA_STATS_DAILY; _p < FINAL_ENUM_STRATEGY_STATS_PERIOD; _p++) {
      _entry.SetStats(stats_period[(int)_p], _p);
    }
    return _entry;
  }

  /**
   * Gets pointer to strategy's stop-loss strategy.
   */
  Strategy *GetStratSl() { return strat_sl; }

  /**
   * Gets pointer to strategy's take-profit strategy.
   */
  Strategy *GetStratTp() { return strat_tp; }

  /**
   * Get strategy's name.
   */
  string GetName() { return name; }

  /**
   * Get strategy's ID.
   */
  virtual long GetId() { return sparams.id; }

  /**
   * Get strategy's signal open method.
   */
  int GetSignalOpenMethod() { return sparams.signal_open_method; }

  /**
   * Get strategy's signal open level.
   */
  double GetSignalOpenLevel() { return sparams.signal_open_level; }

  /**
   * Get strategy's signal close method.
   */
  int GetSignalCloseMethod() { return sparams.signal_close_method; }

  /**
   * Get strategy's signal close level.
   */
  double GetSignalCloseLevel() { return sparams.signal_close_level; }

  /**
   * Get strategy's price stop method.
   */
  int GetPriceStopMethod() { return sparams.signal_close_method; }

  /**
   * Get strategy's price stop level.
   */
  double GetPriceStopLevel() { return sparams.signal_close_level; }

  /**
   * Get strategy's order open comment.
   */
  string GetOrderOpenComment(string _prefix = "", string _suffix = "") {
    // @todo: Add spread.
    // return StringFormat("%s%s[%s];s:%gp%s", _prefix != "" ? _prefix + ": " : "", name, trade.chart.TfToString(),
    // GetCurrSpread(), _suffix != "" ? "| " + _suffix : "");

    return StringFormat("%s%s[%s]%s", _prefix, name, ChartTf::TfToString(trade.Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF)),
                        _suffix);
  }

  /**
   * Get strategy's order close comment.
   */
  string GetOrderCloseComment(string _prefix = "", string _suffix = "") {
    // @todo: Add spread.
    return StringFormat("%s%s[%s]%s", _prefix, name, ChartTf::TfToString(trade.Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF)),
                        _suffix);
  }

  /**
   * Get strategy orders currently open.
   */
  uint GetOrdersOpen() {
    // UpdateOrderStats(EA_STATS_TOTAL);
    // @todo
    return stats.orders_open;
  }

  /**
   * Get strategy's params.
   */
  StgParams GetParams() const { return sparams; }

  /**
   * Gets custom data.
   */
  Dict<int, double> *GetDataD() { return &ddata; }
  Dict<int, float> *GetDataF() { return &fdata; }
  Dict<int, int> *GetDataI() { return &idata; }

  /* Statistics */

  /**
   * Gets strategy orders total opened.
   */
  uint GetOrdersTotal(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].orders_total;
  }

  /**
   * Gets strategy orders won.
   */
  uint GetOrdersWon(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].orders_won;
  }

  /**
   * Gets strategy orders lost.
   */
  uint GetOrdersLost(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].orders_lost;
  }

  /**
   * Gets strategy net profit.
   */
  double GetNetProfit(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].net_profit;
  }

  /**
   * Gets strategy gross profit.
   */
  double GetGrossProfit(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].gross_profit;
  }

  /**
   * Gets strategy gross loss.
   */
  double GetGrossLoss(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].gross_loss;
  }

  /**
   * Gets the average spread of the strategy (in pips).
   */
  double GetAvgSpread(ENUM_STRATEGY_STATS_PERIOD _period = EA_STATS_TOTAL) {
    // UpdateOrderStats(_period);
    return stats_period[(int)_period].avg_spread;
  }

  /* Setters */

  /**
   * Sets a strategy parameter value.
   */
  template <typename T>
  void Set(ENUM_STRATEGY_PARAM _param, T _value) {
    sparams.Set<T>(_param, _value);
  }

  /**
   * Sets a trade parameter value.
   */
  template <typename T>
  void Set(ENUM_TRADE_PARAM _param, T _value) {
    trade.Set<T>(_param, _value);
  }

  /**
   * Sets strategy's name.
   */
  void SetName(string _name) { name = _name; }

  /**
   * Sets strategy's ID.
   */
  void SetId(long _id) {
    sparams.id = _id;
    ((Object *)GetPointer(this)).SetId(_id);
  }

  /**
   * Sets strategy's stops.
   */
  void SetStops(Strategy *_strat_sl = NULL, Strategy *_strat_tp = NULL) {
    strat_sl = _strat_sl != NULL ? _strat_sl : strat_sl;
    strat_tp = _strat_tp != NULL ? _strat_tp : strat_tp;
  }

  /**
   * Enable/disable the strategy.
   */
  void Enabled(bool _enable = true) { sparams.Enabled(_enable); }

  /**
   * Suspend the strategy.
   */
  void Suspended(bool _suspended = true) { sparams.Suspended(_suspended); }

  /**
   * Sets custom data.
   */
  void SetData(Dict<int, double> *_ddata) { ddata = _ddata; }
  void SetData(Dict<int, float> *_fdata) { fdata = _fdata; }
  void SetData(Dict<int, int> *_idata) { idata = _idata; }

  /**
   * Sets reference to indicator.
   */
  void SetIndicator(IndicatorBase *_indi, int _id = 0) {
    Ref<IndicatorBase> _ref = _indi;
    indicators.Set(_id, _ref);
  }

  /* Static setters */

  /**
   * Sets initial params based on the timeframe.
   */
  template <typename T>
  static void SetParamsByTf(T &_result, ENUM_TIMEFRAMES _tf, T &_m1, T &_m5, T &_m15, T &_m30, T &_h1, T &_h4, T &_h8) {
    switch (_tf) {
      case PERIOD_M1: {
        _result = _m1;
        break;
      }
      case PERIOD_M5: {
        _result = _m5;
        break;
      }
      case PERIOD_M15: {
        _result = _m15;
        break;
      }
      case PERIOD_M30: {
        _result = _m30;
        break;
      }
      case PERIOD_H1: {
        _result = _h1;
        break;
      }
      case PERIOD_H4: {
        _result = _h4;
        break;
      }
      case PERIOD_H8: {
        _result = _h8;
        break;
      }
    }
  }

  /* Calculation methods */

  /**
   * Get lot size factor.
   */
  double UpdateLotSizeFactor() { return 1.0; }

  /**
   * Update order stat variables.
   */
  /* @todo: Refactor.
  void UpdateOrderStats(ENUM_STRATEGY_STATS_PERIOD _period) {
    // @todo: Implement support for _period.
    static datetime _last_update = TimeCurrent();
    if (_last_update > TimeCurrent() - sparams.refresh_time) {
      return;  // Do not update too often.
    }
    unsigned int _total = 0, _won = 0, _lost = 0, _open = 0;
    int i;
    double _gross_profit = 0, _gross_loss = 0, _net_profit = 0, _order_profit = 0;
    datetime _order_datetime;
    for (i = 0; i < Trade::OrdersTotal(); i++) {
      // @todo: Select order.
      if (GetMarket().GetSymbol() == Order::OrderSymbol() && trade.tparams.GetMagicNo() == Order::OrderMagicNumber()) {
        _total++;
        _order_profit = Order::OrderProfit() - Order::OrderCommission() - Order::OrderSwap();
        _net_profit += _order_profit;
        if (Order::OrderSelect(i, SELECT_BY_POS, MODE_TRADES)) {
          _open++;
        } else {
          _order_datetime = (datetime)OrderGetInteger(ORDER_TIME_DONE);
          // s_daily_net_profit += @todo;
          // s_weekly_net_profit += @todo;
          // s_monhtly_net_profit += @todo;
          if (_order_profit > 0) {
            _won++;
            _gross_profit += _order_profit;
          } else {
            _lost++;
            _gross_loss += _order_profit;
          }
        }
      }
    }
    // stats.orders_open = _open;
    stats_period[_period].orders_won = _won;
    stats_period[_period].orders_lost = _lost;
    stats_period[_period].orders_total = _total;
    stats_period[_period].net_profit = _net_profit;
    stats_period[_period].gross_profit = _gross_loss;
    stats_period[_period].gross_loss = _gross_profit;
    // stats_period[_period].profit_factor = _profit_factor;
    _last_update = TimeCurrent();
  }
  */

  /**
   * Get profit factor of the strategy.
   */
  double GetProfitFactor() {
    // @todo
    return 0.0;
  }

  /**
   * Get current spread (in pips).
   */
  // double GetCurrSpread() { return trade.chart.GetSpreadInPips(); }

  /**
   * Convert timeframe constant to index value.
   */
  uint TfToIndex(ENUM_TIMEFRAMES _tf) { return ChartTf::TfToIndex(_tf); }

  /**
   * Class constructor.
   */
  /*
  bool Strategy() {

    // Trading variables.
    s_lot_size = si_lot_size;
    s_lot_factor = GetLotSizeFactor();
    s_avg_spread = GetCurrSpread();
    s_tp_max = 0;
    s_sl_max = 0;

    // Statistics variables.
    s_orders_open         = GetOrdersOpen();
    s_orders_total        = GetOrdersTotal();
    s_orders_won          = GetOrdersWon();
    s_orders_lost         = GetOrdersLost();
    s_profit_factor       = GetProfitFactor();
    s_avg_spread          = GetAvgSpread();
    s_total_net_profit    = GetTotalNetProfit();
    s_total_gross_profit  = GetTotalGrossProfit();
    s_total_gross_loss    = GetTotalGrossLoss();
    s_daily_net_profit    = GetDailyNetProfit();
    s_weekly_net_profit   = GetWeeklyNetProfit();
    s_monhtly_net_profit  = GetMonthlyNetProfit();

    // Other variables.
    s_refresh_time        = 10;
  }
  */

  /**
   * Initialize strategy.
   */
  bool Init() {
    if (!trade.IsValid()) {
      /* @fixme
      logger.Warning(StringFormat("Could not initialize %s on %s timeframe!", GetName(),
                                    trade.GetChart().TfToString()),
                       __FUNCTION__ + ": ");
      */
      return false;
    }
    return true;
  }

  /* Conditions and actions */

  /**
   * Checks for Strategy condition.
   *
   * @param ENUM_STRATEGY_CONDITION _cond
   *   Strategy condition.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_STRATEGY_CONDITION _cond, DataParamEntry &_args[]) {
    bool _result = false;
    long arg_size = ArraySize(_args);
    long _arg1l = ArraySize(_args) > 0 ? DataParamEntry::ToInteger(_args[0]) : WRONG_VALUE;
    long _arg2l = ArraySize(_args) > 1 ? DataParamEntry::ToInteger(_args[1]) : WRONG_VALUE;
    long _arg3l = ArraySize(_args) > 2 ? DataParamEntry::ToInteger(_args[2]) : WRONG_VALUE;
    switch (_cond) {
      case STRAT_COND_IS_ENABLED:
        return sparams.IsEnabled();
      case STRAT_COND_IS_SUSPENDED:
        return sparams.IsSuspended();
      case STRAT_COND_IS_TREND:
        _arg1l = _arg1l != WRONG_VALUE ? _arg1l : 0;
        return IsTrend((ENUM_ORDER_TYPE)_arg1l);
      case STRAT_COND_SIGNALOPEN: {
        ENUM_ORDER_TYPE _cmd = ArraySize(_args) > 1 ? (ENUM_ORDER_TYPE)_args[0].integer_value : ORDER_TYPE_BUY;
        int _method = ArraySize(_args) > 1 ? (int)_args[1].integer_value : 0;
        float _level = ArraySize(_args) > 2 ? (float)_args[2].double_value : 0;
        return SignalOpen(_cmd, _method, _level);
      }
      case STRAT_COND_TRADE_COND:
        // Args:
        // 1st (i:0) - Trade's enum condition to check.
        // 2rd... (i:1) - Optionally trade's arguments to pass.
        if (arg_size > 0) {
          DataParamEntry _sargs[];
          ArrayResize(_sargs, ArraySize(_args) - 1);
          for (int i = 0; i < ArraySize(_sargs); i++) {
            _sargs[i] = _args[i + 1];
          }
          _result = trade.CheckCondition((ENUM_TRADE_CONDITION)_arg1l, _sargs);
        }
        return _result;
      default:
        GetLogger().Error(StringFormat("Invalid EA condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
        break;
    }
    return _result;
  }
  bool CheckCondition(ENUM_STRATEGY_CONDITION _cond, long _arg1) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    ArrayPushObject(_args, _param1);
    return Strategy::CheckCondition(_cond, _args);
  }
  bool CheckCondition(ENUM_STRATEGY_CONDITION _cond, long _arg1, long _arg2) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    DataParamEntry _param2 = _arg2;
    ArrayPushObject(_args, _param1);
    ArrayPushObject(_args, _param2);
    return Strategy::CheckCondition(_cond, _args);
  }
  bool CheckCondition(ENUM_STRATEGY_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return CheckCondition(_cond, _args);
  }

  /**
   * Execute Strategy action.
   *
   * @param ENUM_STRATEGY_ACTION _action
   *   Strategy action to execute.
   * @param MqlParam _args
   *   Strategy action arguments.
   * @return
   *   Returns true when the action has been executed successfully.
   */
  bool ExecuteAction(ENUM_STRATEGY_ACTION _action, DataParamEntry &_args[]) {
    bool _result = false;
    double arg1d = EMPTY_VALUE;
    double arg2d = EMPTY_VALUE;
    double arg3d = EMPTY_VALUE;
    long arg1i = EMPTY;
    long arg2i = EMPTY;
    long arg3i = EMPTY;
    long arg_size = ArraySize(_args);
    if (arg_size > 0) {
      arg1d = _args[0].type == TYPE_DOUBLE ? _args[0].double_value : EMPTY_VALUE;
      arg1i = _args[0].type == TYPE_INT ? _args[0].integer_value : EMPTY;
      if (arg_size > 1) {
        arg2d = _args[1].type == TYPE_DOUBLE ? _args[1].double_value : EMPTY_VALUE;
        arg2i = _args[1].type == TYPE_INT ? _args[1].integer_value : EMPTY;
      }
      if (arg_size > 2) {
        arg3d = _args[2].type == TYPE_DOUBLE ? _args[2].double_value : EMPTY_VALUE;
        arg3i = _args[2].type == TYPE_INT ? _args[2].integer_value : EMPTY;
      }
    }
    switch (_action) {
      case STRAT_ACTION_DISABLE:
        sparams.Enabled(false);
        return true;
      case STRAT_ACTION_ENABLE:
        sparams.Enabled(true);
        return true;
      case STRAT_ACTION_SUSPEND:
        sparams.Suspended(true);
        return true;
      case STRAT_ACTION_TRADE_EXE:
        // Args:
        // 1st (i:0) - Trade's enum action to execute.
        // 2rd (i:1) - Trade's argument to pass.
        if (arg_size > 0) {
          DataParamEntry _sargs[];
          ArrayResize(_sargs, ArraySize(_args) - 1);
          for (int i = 0; i < ArraySize(_sargs); i++) {
            _sargs[i] = _args[i + 1];
          }
          _result = trade.ExecuteAction((ENUM_TRADE_ACTION)_args[0].integer_value, _sargs);
          /* @fixme
          if (_result) {
            Order *_order = trade.GetOrderLast();
            switch ((ENUM_TRADE_ACTION)_args[0].integer_value) {
              case TRADE_ACTION_ORDERS_CLOSE_BY_TYPE:
                // OnOrderClose();// @todo
                break;
              case TRADE_ACTION_ORDER_OPEN:
                // @fixme: Operation on the structure copy.
                OnOrderOpen(_order.GetParams());
                break;
            }
          }
          */
        }
        return _result;
      case STRAT_ACTION_UNSUSPEND:
        sparams.Suspended(false);
        return true;
      default:
        GetLogger().Error(StringFormat("Invalid Strategy action: %s!", EnumToString(_action), __FUNCTION_LINE__));
        break;
    }
    return _result;
  }
  bool ExecuteAction(ENUM_STRATEGY_ACTION _action, long _arg1) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    ArrayPushObject(_args, _param1);
    return Strategy::ExecuteAction(_action, _args);
  }
  bool ExecuteAction(ENUM_STRATEGY_ACTION _action, long _arg1, long _arg2) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    DataParamEntry _param2 = _arg2;
    ArrayPushObject(_args, _param1);
    ArrayPushObject(_args, _param2);
    return Strategy::ExecuteAction(_action, _args);
  }
  bool ExecuteAction(ENUM_STRATEGY_ACTION _action, long _arg1, long _arg2, long _arg3) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    DataParamEntry _param2 = _arg2;
    DataParamEntry _param3 = _arg3;
    ArrayPushObject(_args, _param1);
    ArrayPushObject(_args, _param2);
    ArrayPushObject(_args, _param3);
    return Strategy::ExecuteAction(_action, _args);
  }
  bool ExecuteAction(ENUM_STRATEGY_ACTION _action) {
    ARRAY(DataParamEntry, _args);
    return Strategy::ExecuteAction(_action, _args);
  }

  /* Printers methods */

  /**
   * Prints strategy's details.
   */
  string const ToString() { return StringFormat("%s: %s", GetName(), sparams.ToString()); }

  /* Virtual methods */

  /**
   * Event on order close.
   */
  virtual void OnOrderClose(ENUM_ORDER_TYPE _cmd) {}

  /**
   * Event on strategy's init.
   */
  virtual void OnInit() {
    SetStops(GetPointer(this), GetPointer(this));
    // trade.SetStrategy(&this); // @fixme
  }

  /**
   * Event on strategy's order open.
   *
   * @param
   *   _oparams Order parameters to update before the open.
   */
  virtual void OnOrderOpen(OrderParams &_oparams) {
    int _index = 0;
    ENUM_TIMEFRAMES _stf = Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF);
    unsigned int _stf_secs = ChartTf::TfToSeconds(_stf);
    if (sparams.order_close_time != 0) {
      long _close_time_arg = sparams.order_close_time > 0 ? sparams.order_close_time * 60
                                                          : (int)round(-sparams.order_close_time * _stf_secs);
      _oparams.Set(ORDER_PARAM_COND_CLOSE, ORDER_COND_LIFETIME_GT_ARG, _index);
      _oparams.Set(ORDER_PARAM_COND_CLOSE_ARG_VALUE, _close_time_arg, _index);
      _index++;
    }
    if (sparams.order_close_loss != 0.0f) {
      float _loss_limit = sparams.order_close_loss;
      _oparams.Set(ORDER_PARAM_COND_CLOSE, ORDER_COND_IN_LOSS, _index);
      _oparams.Set(ORDER_PARAM_COND_CLOSE_ARG_VALUE, _loss_limit, _index);
      _index++;
    }
    if (sparams.order_close_profit != 0.0f) {
      float _profit_limit = sparams.order_close_profit;
      _oparams.Set(ORDER_PARAM_COND_CLOSE, ORDER_COND_IN_PROFIT, _index);
      _oparams.Set(ORDER_PARAM_COND_CLOSE_ARG_VALUE, _profit_limit, _index);
      _index++;
    }
    _oparams.Set(ORDER_PARAM_UPDATE_FREQ, _stf_secs);
  }

  /**
   * Event on new time periods.
   *
   * Example:
   *   unsigned short _periods = (DATETIME_MINUTE | DATETIME_HOUR);
   *   OnPeriod(_periods);
   *
   * @param
   *   _periods unsigned short
   *   List of periods which started. See: ENUM_DATETIME_UNIT.
   */
  virtual void OnPeriod(unsigned int _periods = DATETIME_NONE) {
    if ((_periods & DATETIME_MINUTE) != 0) {
      // New minute started.
#ifndef __optimize__
      if (Terminal::IsRealtime()) {
        logger.Flush();
      }
#endif
    }
    if ((_periods & DATETIME_HOUR) != 0) {
      // New hour started.
    }
    if ((_periods & DATETIME_DAY) != 0) {
      // New day started.
#ifndef __optimize__
      GetLogger().Flush();
#endif
    }
    if ((_periods & DATETIME_WEEK) != 0) {
      // New week started.
    }
    if ((_periods & DATETIME_MONTH) != 0) {
      // New month started.
    }
    if ((_periods & DATETIME_YEAR) != 0) {
      // New year started.
    }
  }

  /**
   * Filters strategy's market tick.
   *
   * @param
   *   _tick Tick to use for filtering.
   *   _method Signal method to filter a tick (bitwise AND operation).
   *
   * @result bool
   *   Returns true when tick should be processed, otherwise false.
   */
  virtual bool TickFilter(const MqlTick &_tick, const int _method) {
    bool _res = _method >= 0;
    bool _val;
    int _method_abs = fabs(_method);
    if (_method_abs != 0) {
      if (METHOD(_method_abs, 0)) {  // 1
        // Process on every minute.
        _val = _tick.time % 60 < last_tick.time % 60;
        _res = _method > 0 ? _res & _val : _res | _val;
        last_tick = _tick;
      }
      if (METHOD(_method_abs, 1)) {  // 2
        // Process low and high ticks of a bar.
        _val = _tick.bid >= trade.GetChart().GetHigh() || _tick.bid <= trade.GetChart().GetLow();
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (METHOD(_method_abs, 2)) {  // 4
        // Process only peak prices of each minute.
        static double _peak_high = _tick.bid, _peak_low = _tick.bid;
        if (_tick.time % 60 < last_tick.time % 60) {
          // Resets peaks each minute.
          _peak_high = _peak_low = _tick.bid;
        } else {
          // Sets new peaks.
          _peak_high = _tick.bid > _peak_high ? _tick.bid : _peak_high;
          _peak_low = _tick.bid < _peak_low ? _tick.bid : _peak_low;
        }
        _val = (_tick.bid == _peak_high) || (_tick.bid == _peak_low);
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (METHOD(_method_abs, 3)) {  // 8
        // Process only unique ticks (avoid duplicates).
        _val = _tick.bid != last_tick.bid && _tick.ask != last_tick.ask;
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (METHOD(_method_abs, 4)) {  // 16
        // Process ticks in the middle of the bar.
        _val = (trade.GetChart().GetBarTime() +
                (ChartTf::TfToSeconds(trade.Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF)) / 2)) == TimeCurrent();
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (METHOD(_method_abs, 5)) {  // 32
        // Process bar open price ticks.
        _val = last_tick.time < trade.GetChart().GetBarTime(); // @todo: Improve performance.
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (METHOD(_method_abs, 6)) {  // 64
        // Process every 10th of the bar.
        _val = TimeCurrent() % (int)(ChartTf::TfToSeconds(trade.Get<ENUM_TIMEFRAMES>(CHART_PARAM_TF)) / 10) == 0;
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (METHOD(_method_abs, 7)) {  // 128
        // Process tick on every 10 seconds.
        _val = _tick.time % 10 < last_tick.time % 10;
        _res = _method > 0 ? _res & _val : _res | _val;
      }
      if (_res) {
        last_tick = _tick;
      }
    }
    return _res;
  }
  virtual bool TickFilter(const MqlTick &_tick) { return TickFilter(_tick, sparams.Get<int>(STRAT_PARAM_TFM)); }

  /**
   * Checks strategy's trade open signal.
   *
   * @param
   *   _cmd Ttype of trade order command.
   *   _method Signal method to open a trade (bitwise AND operation).
   *   _level Signal level to open a trade.
   *   _shift Signal shift relative to the current bar.
   *
   * @result bool
   *   Returns true when trade should be opened, otherwise false.
   */
  virtual bool SignalOpen(ENUM_ORDER_TYPE _cmd, int _method = 0, float _level = 0.0f, int _shift = 0) = NULL;

  /**
   * Returns strength of strategy's open signal.
   *
   * @param
   *   _method Signal method to open a trade (bitwise AND operation).
   *   _level Signal level to open a trade.
   *   _shift Signal shift relative to the current bar.
   *
   * @result float
   *   Returns value strength of strategy's open signal ranging from -1 to 1.
   *   Buy signal is when value is positive.
   *   Sell signal is when value is negative.
   */
  virtual float SignalOpen(int _method = 0, float _level = 0.0f, int _shift = 0) {
    // @todo
    return 0.0f;
  };

  /**
   * Checks strategy's trade's open signal method filter.
   *
   * @param
   *   _cmd    - type of trade order command
   *   _method - method to filter a trade (bitwise AND operation)
   *
   * @result bool
   *   Returns true when trade should be opened, otherwise false.
   */
  virtual bool SignalOpenFilterMethod(ENUM_ORDER_TYPE _cmd, int _method = 0) {
    bool _result = true;
    if (_method != 0) {
      if (METHOD(_method, 0)) _result &= !trade.HasBarOrder(_cmd);           // 1
      if (METHOD(_method, 1)) _result &= IsTrend(_cmd);                      // 2
      if (METHOD(_method, 2)) _result &= trade.IsPivot(_cmd);                // 4
      if (METHOD(_method, 3)) _result &= !trade.HasOrderOppositeType(_cmd);  // 8
      if (METHOD(_method, 4)) _result &= trade.IsPeak(_cmd);                 // 16
      if (METHOD(_method, 5)) _result &= !trade.HasOrderBetter(_cmd);        // 32
      if (METHOD(_method, 6))
        _result &= !trade.CheckCondition(
            TRADE_COND_ACCOUNT, _method > 0 ? ACCOUNT_COND_EQUITY_01PC_LOW : ACCOUNT_COND_EQUITY_01PC_HIGH);  // 64
      // if (METHOD(_method, 5)) _result &= Trade().IsRoundNumber(_cmd);
      // if (METHOD(_method, 6)) _result &= Trade().IsHedging(_cmd);
      _method = _method > 0 ? _method : !_method;
    }
    return _result;
  }

  /**
   * Checks strategy's trade's close signal time filter.
   *
   * @param
   *   _method - method to filter a closing trade (bitwise AND operation)
   *
   * @result bool
   *   Returns true if trade should be closed, otherwise false.
   */
  virtual bool SignalCloseFilterTime(int _method = 0) {
    bool _result = true;
    if (_method != 0) {
      MarketTimeForex _mtf(::TimeGMT());
      _result &= _mtf.CheckHours(_method);         // 0-127
      _method = _method > 0 ? _method : !_method;  // -127-127
    }
    return _result;
  }

  /**
   * Checks strategy's trade's open signal time filter.
   *
   * @param
   *   _method - method to filter a trade (bitwise AND operation)
   *
   * @result bool
   *   Returns true if trade should be opened, otherwise false.
   */
  virtual bool SignalOpenFilterTime(int _method = 0) {
    bool _result = true;
    if (_method != 0) {
      MarketTimeForex _mtf(::TimeGMT());
      _result &= _mtf.CheckHours(_method);         // 0-127
      _method = _method > 0 ? _method : !_method;  // -127-127
    }
    return _result;
  }

  /**
   * Gets strategy's lot size boost for the open signal.
   *
   * @param
   *   _cmd    - type of trade order command
   *   _method - boost method (bitwise AND operation)
   *
   * @result double
   *   Returns lot size multiplier (0.0 = normal, 0.1 = 1/10, 1.0 = normal, 2.0 = 2x).
   *   Range: between 0.0 and (max_risk * 2).
   */
  virtual float SignalOpenBoost(ENUM_ORDER_TYPE _cmd, int _method = 0) {
    float _result = 1.0;
    if (_method != 0) {
      // if (METHOD(_method, 0)) if (Trade().IsTrend(_cmd)) _result *= 1.1;
      // if (METHOD(_method, 1)) if (Trade().IsPivot(_cmd)) _result *= 1.1;
      // if (METHOD(_method, 2)) if (Trade().IsPeakHours(_cmd)) _result *= 1.1;
      // if (METHOD(_method, 3)) if (Trade().IsRoundNumber(_cmd)) _result *= 1.1;
      // if (METHOD(_method, 4)) if (Trade().IsHedging(_cmd)) _result *= 1.1;
      // if (METHOD(_method, 5)) if (Trade().IsPeakBar(_cmd)) _result *= 1.1;
    }
    return _result;
  }

  /**
   * Checks strategy's trade close signal.
   *
   * @param
   *   _cmd    - type of trade order command
   *   _method - signal method to close a trade (bitwise AND operation)
   *   _level  - signal level to close a trade (bitwise AND operation)
   *
   * @result bool
   *   Returns true when trade should be closed, otherwise false.
   */
  virtual bool SignalClose(ENUM_ORDER_TYPE _cmd, int _method = 0, float _level = 0.0f, int _shift = 0) {
    return SignalOpen(Order::NegateOrderType(_cmd), _method, _level, _shift);
  }

  /**
   * Checks strategy's trade close signal additional filter.
   *
   * @param
   *   _cmd    - type of trade order command
   *   _method - signal method to filter a trade (bitwise AND operation)
   *
   * @result bool
   *   Returns true when trade should be closed, otherwise false.
   */
  virtual bool SignalCloseFilter(ENUM_ORDER_TYPE _cmd, int _method = 0, int _shift = 0) {
    bool _result = _method == 0;
    if (_method != 0) {
      if (METHOD(_method, 0)) _result |= _result || !trade.HasBarOrder(_cmd);  // 1
      if (METHOD(_method, 1)) _result |= _result || !IsTrend(_cmd);            // 2
      if (METHOD(_method, 2)) _result |= _result || !trade.IsPivot(_cmd);      // 4
      if (METHOD(_method, 3))
        _result |= _result || Open[_shift] > High[_shift + 1] || Open[_shift] < Low[_shift + 1];  // 8
      if (METHOD(_method, 4)) _result |= _result || trade.IsPeak(_cmd);                           // 16
      if (METHOD(_method, 5)) _result |= _result || trade.HasOrderBetter(_cmd);                   // 32
      if (METHOD(_method, 6))
        _result |=
            _result || trade.CheckCondition(TRADE_COND_ACCOUNT, _method > 0 ? ACCOUNT_COND_EQUITY_01PC_HIGH
                                                                            : ACCOUNT_COND_EQUITY_01PC_LOW);  // 64
      // if (METHOD(_method, 7)) _result |= _result || Trade().IsRoundNumber(_cmd);
      // if (METHOD(_method, 8)) _result |= _result || Trade().IsHedging(_cmd);
      _method = _method > 0 ? _method : !_method;
    }
    return _result;
  }

  /**
   * Gets price stop value.
   *
   * @param
   *   _cmd    - type of trade order command
   *   _mode   - mode for price stop value (ORDER_TYPE_TP or ORDER_TYPE_SL)
   *   _method - method to calculate the price stop
   *   _level  - level value to use for calculation
   *
   * @result bool
   *   Returns current stop loss value when _mode is ORDER_TYPE_SL
   *   and profit take when _mode is ORDER_TYPE_TP.
   */
  virtual float PriceStop(ENUM_ORDER_TYPE _cmd, ENUM_ORDER_TYPE_VALUE _mode, int _method = 0, float _level = 0.0f,
                          short _bars = 4) {
    float _result = 0;
    if (_method == 0) {
      // Ignores calculation when method is 0.
      return (float)_result;
    }
    float _trade_dist = trade.GetTradeDistanceInValue();
    int _count = (int)fmax(fabs(_level), fabs(_method));
    int _direction = Order::OrderDirection(_cmd, _mode);
    Chart *_chart = trade.GetChart();
    IndicatorBase *_indi = GetIndicators().Begin().Value().Ptr();
    StrategyPriceStop _psm(_method);
    _psm.SetChartParams(_chart.GetParams());
    if (Object::IsValid(_indi)) {
      int _ishift = 12;  // @todo: Make it dynamic or as variable.
      float _value = _indi.GetValuePrice<float>(_ishift, 0, _direction > 0 ? PRICE_HIGH : PRICE_LOW);
      _value = _value + (float)Math::ChangeByPct(fabs(_value - _chart.GetCloseOffer(0)), _level) * _direction;
      _psm.SetIndicatorPriceValue(_value);
      /*
      //IndicatorDataEntry _data[];
      if (_indi.CopyEntries(_data, 3, 0)) {
        _psm.SetIndicatorDataEntry(_data);
        _psm.SetIndicatorParams(_indi.GetParams());
      }
      */
      _result = _psm.GetValue(_ishift, _direction, _trade_dist);
    } else {
      int _pshift = _direction > 0 ? _chart.GetHighest(_count) : _chart.GetLowest(_count);
      _result = _psm.GetValue(_pshift, _direction, _trade_dist);
    }
    return (float)_result;
  }

  /**
   * Gets trend strength value.
   *
   * @param
   *   _tf - timeframe to use for trend calculation
   *
   * @result bool
   *   Returns trend strength value from -1 (strong bearish) to +1 (strong bullish).
   *   Value closer to 0 indicates a neutral trend.
   */
  virtual float TrendStrength(ENUM_TIMEFRAMES _tf = PERIOD_D1, int _shift = 1) {
    float _result = 0;
    Chart *_c = trade.GetChart();
    if (_c.IsValidShift(_shift)) {
      ChartEntry _bar1 = _c.GetEntry(_tf, _shift);
      float _range = _bar1.bar.ohlc.GetRange();
      if (_range > 0) {
        float _open = (float)_c.GetOpen(_tf);
        float _pp = _bar1.bar.ohlc.GetPivot();
        _result = 1 / _range * (_open - _pp);
        _result = fmin(1, fmax(-1, _result));
      }
    }
    return _result;
  };

  /* Serializers */

  /**
   * Returns serialized representation of the object instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.PassStruct(THIS_REF, "strat-params", sparams);
    _s.PassStruct(THIS_REF, "strat-results", sresult, SERIALIZER_FIELD_FLAG_DYNAMIC);
    return SerializerNodeObject;
  }
};
#endif  // STRATEGY_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Strategy.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Market.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Condition.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Refs.struct.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: TradeSignal.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: TradeSignal.struct.h
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../SerializerConverter.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Serializer.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../SerializerJson.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes TradeSignal's structs.
 */

// Includes.




// Defines.
#define SIGNAL_CLOSE_BUY_FILTER STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_BUY_FILTER)
#define SIGNAL_CLOSE_BUY_MAIN STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_BUY_MAIN)
#define SIGNAL_CLOSE_BUY_SIGNAL STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_BUY_SIGNAL)
#define SIGNAL_CLOSE_DOWNWARDS STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_DOWNWARDS)
#define SIGNAL_CLOSE_SELL_FILTER STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_SELL_FILTER)
#define SIGNAL_CLOSE_SELL_MAIN STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_SELL_MAIN)
#define SIGNAL_CLOSE_SELL_SIGNAL STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_SELL_SIGNAL)
#define SIGNAL_CLOSE_TIME_FILTER STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_TIME_FILTER)
#define SIGNAL_CLOSE_UPWARDS STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_CLOSE_UPWARDS)
#define SIGNAL_OPEN_BUY_FILTER STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_BUY_FILTER)
#define SIGNAL_OPEN_BUY_MAIN STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_BUY_MAIN)
#define SIGNAL_OPEN_BUY_SIGNAL STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_BUY_SIGNAL)
#define SIGNAL_OPEN_DOWNWARDS STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_DOWNWARDS)
#define SIGNAL_OPEN_SELL_FILTER STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_SELL_FILTER)
#define SIGNAL_OPEN_SELL_MAIN STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_SELL_MAIN)
#define SIGNAL_OPEN_SELL_SIGNAL STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_SELL_SIGNAL)
#define SIGNAL_OPEN_TIME_FILTER STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_TIME_FILTER)
#define SIGNAL_OPEN_UPWARDS STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_OPEN_UPWARDS)

// Structure for a trade signal.
struct TradeSignalEntry {
 protected:
  ENUM_TIMEFRAMES tf;    // Timeframe.
  float strength;        // Signal strength.
  float weight;          // Signal weight.
  long magic_id;         // Magic identifier.
  long timestamp;        // Creation timestamp
  unsigned int signals;  // Store signals (@see: ENUM_TRADE_SIGNAL_FLAG).

 public:
  /* Struct's enumerations */

  // Enumeration for strategy bitwise signal flags.
  enum ENUM_TRADE_SIGNAL_FLAG {
    TRADE_SIGNAL_FLAG_NONE = 0 << 0,
    TRADE_SIGNAL_FLAG_CLOSE_BUY_FILTER = 1 << 0,   // Filter for close buy
    TRADE_SIGNAL_FLAG_CLOSE_BUY_MAIN = 1 << 1,     // Main signal for close buy
    TRADE_SIGNAL_FLAG_CLOSE_SELL_FILTER = 1 << 2,  // Filter for close sell
    TRADE_SIGNAL_FLAG_CLOSE_SELL_MAIN = 1 << 3,    // Main signal for close sell
    TRADE_SIGNAL_FLAG_CLOSE_TIME_FILTER = 1 << 4,  // Time filter to close
    TRADE_SIGNAL_FLAG_EXPIRED = 1 << 5,            // Signal expired
    TRADE_SIGNAL_FLAG_OPEN_BUY_FILTER = 1 << 6,    // Filter for close buy
    TRADE_SIGNAL_FLAG_OPEN_BUY_MAIN = 1 << 7,      // Main signal for close buy
    TRADE_SIGNAL_FLAG_OPEN_SELL_FILTER = 1 << 8,   // Filter for close sell
    TRADE_SIGNAL_FLAG_OPEN_SELL_MAIN = 1 << 9,     // Main signal for close sell
    TRADE_SIGNAL_FLAG_OPEN_TIME_FILTER = 1 << 10,  // Time filter to open
    TRADE_SIGNAL_FLAG_PROCESSED = 1 << 11,         // Signal proceed
    // Pre-defined signal conditions.
    TRADE_SIGNAL_FLAG_CLOSE_BUY_SIGNAL =
        TRADE_SIGNAL_FLAG_CLOSE_BUY_MAIN ^ (TRADE_SIGNAL_FLAG_CLOSE_BUY_FILTER | TRADE_SIGNAL_FLAG_CLOSE_TIME_FILTER),
    TRADE_SIGNAL_FLAG_CLOSE_SELL_SIGNAL =
        TRADE_SIGNAL_FLAG_CLOSE_SELL_MAIN ^ (TRADE_SIGNAL_FLAG_CLOSE_SELL_FILTER | TRADE_SIGNAL_FLAG_CLOSE_TIME_FILTER),
    TRADE_SIGNAL_FLAG_OPEN_BUY_SIGNAL =
        TRADE_SIGNAL_FLAG_OPEN_BUY_MAIN ^ (TRADE_SIGNAL_FLAG_OPEN_BUY_FILTER | TRADE_SIGNAL_FLAG_OPEN_TIME_FILTER),
    TRADE_SIGNAL_FLAG_OPEN_SELL_SIGNAL =
        TRADE_SIGNAL_FLAG_OPEN_SELL_MAIN ^ (TRADE_SIGNAL_FLAG_OPEN_SELL_FILTER | TRADE_SIGNAL_FLAG_OPEN_TIME_FILTER),
    // Pre-defined signal directions.
    TRADE_SIGNAL_FLAG_CLOSE_DOWNWARDS = TRADE_SIGNAL_FLAG_CLOSE_SELL_MAIN & ~TRADE_SIGNAL_FLAG_CLOSE_BUY_MAIN,
    TRADE_SIGNAL_FLAG_CLOSE_UPWARDS = TRADE_SIGNAL_FLAG_CLOSE_BUY_MAIN & ~TRADE_SIGNAL_FLAG_CLOSE_SELL_MAIN,
    TRADE_SIGNAL_FLAG_OPEN_DOWNWARDS = TRADE_SIGNAL_FLAG_OPEN_SELL_MAIN & ~TRADE_SIGNAL_FLAG_OPEN_BUY_MAIN,
    TRADE_SIGNAL_FLAG_OPEN_UPWARDS = TRADE_SIGNAL_FLAG_OPEN_BUY_MAIN & ~TRADE_SIGNAL_FLAG_OPEN_SELL_MAIN,
  };

  // Enumeration for strategy signal properties.
  enum ENUM_TRADE_SIGNAL_PROP {
    TRADE_SIGNAL_PROP_MAGIC_ID,
    TRADE_SIGNAL_PROP_SIGNALS,
    TRADE_SIGNAL_PROP_STRENGTH,
    TRADE_SIGNAL_PROP_TF,
    TRADE_SIGNAL_PROP_TIME,
    TRADE_SIGNAL_PROP_WEIGHT,
  };

  // Enumeration for strategy signal types.
  enum ENUM_TRADE_SIGNAL_OP {
    TRADE_SIGNAL_OP_SELL = -1,    // Signal to sell.
    TRADE_SIGNAL_OP_NEUTRAL = 0,  // Neutral signal.
    TRADE_SIGNAL_OP_BUY = 1,      // Signal to buy.
  };

  /* Constructor */
  TradeSignalEntry(unsigned int _signals = 0, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, long _magic_id = 0,
                   float _strength = 0.0f, float _weight = 0.0f, long _time = 0)
      : magic_id(_magic_id), signals(_signals), strength(_strength), tf(_tf), timestamp(_time), weight(_weight) {}
  TradeSignalEntry(const TradeSignalEntry &_entry) { this = _entry; }
  /* Getters */
  template <typename T>
  T Get(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_PROP) _prop) {
    switch (_prop) {
      case TRADE_SIGNAL_PROP_MAGIC_ID:
        return (T)magic_id;
      case TRADE_SIGNAL_PROP_SIGNALS:
        return (T)signals;
      case TRADE_SIGNAL_PROP_STRENGTH:
        return (T)strength;
      case TRADE_SIGNAL_PROP_TF:
        return (T)tf;
      case TRADE_SIGNAL_PROP_TIME:
        return (T)timestamp;
      case TRADE_SIGNAL_PROP_WEIGHT:
        return (T)weight;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }
  bool Get(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_FLAG) _prop) { return CheckSignals(_prop); }
  /* Setters */
  template <typename T>
  void Set(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_PROP) _prop, T _value) {
    switch (_prop) {
      case TRADE_SIGNAL_PROP_MAGIC_ID:
        magic_id = (long)_value;
        return;
      case TRADE_SIGNAL_PROP_SIGNALS:
        signals = (unsigned int)_value;
        return;
      case TRADE_SIGNAL_PROP_STRENGTH:
        strength = (float)_value;
        return;
      case TRADE_SIGNAL_PROP_TF:
        tf = (ENUM_TIMEFRAMES)_value;
        return;
      case TRADE_SIGNAL_PROP_TIME:
        timestamp = (long)_value;
        return;
      case TRADE_SIGNAL_PROP_WEIGHT:
        weight = (float)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_FLAG) _prop, bool _value) { SetSignal(_prop, _value); }
  /* Signal methods for bitwise operations */
  bool CheckSignals(unsigned int _flags) { return (signals & _flags) != 0; }
  bool CheckSignalsEqual(unsigned int _flags, unsigned int _value) { return (signals & _flags) == _value; }
  bool CheckSignalsExact(unsigned int _flags) { return (signals & _flags) == _flags; }
  unsigned int GetSignals() { return signals; }
  /* Setters */
  void AddSignals(unsigned int _flags) { signals |= _flags; }
  void RemoveSignals(unsigned int _flags) { signals &= ~_flags; }
  void SetSignal(ENUM_TRADE_SIGNAL_FLAG _flag, bool _value = true) {
    if (_value) {
      AddSignals(_flag);
    } else {
      RemoveSignals(_flag);
    }
  }
  void SetSignals(unsigned int _flags) { signals = _flags; }
  // Serializers.
  SERIALIZER_EMPTY_STUB;
  SerializerNodeType Serialize(Serializer &_s) {
    _s.PassEnum(THIS_REF, "tf", tf);
    _s.Pass(THIS_REF, "timestamp", timestamp, SERIALIZER_FIELD_FLAG_DYNAMIC | SERIALIZER_FIELD_FLAG_FEATURE);
    _s.Pass(THIS_REF, "strength", strength, SERIALIZER_FIELD_FLAG_DYNAMIC);
    _s.Pass(THIS_REF, "weight", weight, SERIALIZER_FIELD_FLAG_DYNAMIC);
    int _size = sizeof(int) * 8;
    for (int i = 0; i < _size; i++) {
      int _value = CheckSignals(1 << i) ? 1 : 0;
      _s.Pass(THIS_REF, (string)(i + 1), _value, SERIALIZER_FIELD_FLAG_DYNAMIC | SERIALIZER_FIELD_FLAG_FEATURE);
    }
    return SerializerNodeObject;
  }
  string ToString() {
    // SerializerConverter _stub = SerializerConverter::MakeStubObject<TradeSignalEntry>(SERIALIZER_FLAG_SKIP_HIDDEN);
    return SerializerConverter::FromObject(THIS_REF, SERIALIZER_FLAG_INCLUDE_ALL | SERIALIZER_FLAG_SKIP_HIDDEN)
        .ToString<SerializerJson>(SERIALIZER_JSON_NO_WHITESPACES);
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: TradeSignal.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.


/**
 * @file
 * Implements TradeSignal class.
 */

/**
 * Class to store and manage a trading signal.
 */
class TradeSignal {
 protected:
  TradeSignalEntry signal;

 public:
  /**
   * Class constructor.
   */
  TradeSignal() {}
  TradeSignal(const TradeSignalEntry &_entry) : signal(_entry) {}
  TradeSignal(const TradeSignal &_signal) : signal(_signal.GetSignal()) {}

  /* Getters */

  /**
   * Gets a signal flag state.
   */
  bool Get(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_FLAG) _flag) { return signal.Get(_flag); }

  /**
   * Gets a signal property.
   */
  template <typename TV>
  TV Get(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_PROP) _prop) {
    return signal.Get<TV>(_prop);
  }

  /**
   * Gets a signal entry.
   */
  TradeSignalEntry GetSignal() const { return signal; }

  /* Setters */

  /**
   * Sets a signal flag state.
   */
  void Set(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_FLAG) _prop, bool _value) { signal.Set(_prop, _value); }

  /**
   * Sets a signal property.
   */
  template <typename TV>
  void Set(STRUCT_ENUM(TradeSignalEntry, ENUM_TRADE_SIGNAL_PROP) _prop, TV _value) {
    signal.Set<TV>(_prop, _value);
  }

  /* Signal methods */

  /**
   * Check for signal to close a trade.
   */
  bool ShouldClose(ENUM_ORDER_TYPE _cmd) {
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        return signal.CheckSignalsEqual(SIGNAL_CLOSE_BUY_SIGNAL, SIGNAL_CLOSE_BUY_MAIN);
      case ORDER_TYPE_SELL:
        return signal.CheckSignalsEqual(SIGNAL_CLOSE_SELL_SIGNAL, SIGNAL_CLOSE_SELL_MAIN);
      default:
        break;
    }
    return false;
  }

  /**
   * Check for signal to open a trade.
   */
  bool ShouldOpen(ENUM_ORDER_TYPE _cmd) {
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        return signal.CheckSignalsEqual(SIGNAL_OPEN_BUY_SIGNAL, SIGNAL_OPEN_BUY_MAIN);
      case ORDER_TYPE_SELL:
        return signal.CheckSignalsEqual(SIGNAL_OPEN_SELL_SIGNAL, SIGNAL_OPEN_SELL_MAIN);
      default:
        break;
    }
    return false;
  }

  /**
   * Gets signal's strength to close.
   *
   * @return
   *   Returns strength of signal to close between -1 and 1.
   *   Returns 0 on a neutral signal or when signals are in conflict.
   */
  float GetSignalClose() { return float(int(ShouldClose(ORDER_TYPE_BUY)) - int(ShouldClose(ORDER_TYPE_SELL))); }

  /**
   * Gets signal's close direction.
   *
   * @return
   *   Returns +1 for upwards, -1 for downwards, or 0 for a neutral direction.
   */
  char GetSignalCloseDirection() {
    if (signal.CheckSignals(SIGNAL_CLOSE_UPWARDS)) {
      return 1;
    } else if (signal.CheckSignals(SIGNAL_CLOSE_DOWNWARDS)) {
      return -1;
    }
    return 0;
  }

  /**
   * Gets signal's strength to open.
   *
   * @return
   *   Returns strength of signal to close between -1 and 1.
   *   Returns 0 on a neutral signal or when signals are in conflict.
   */
  float GetSignalOpen() { return float(int(ShouldOpen(ORDER_TYPE_BUY)) - int(ShouldOpen(ORDER_TYPE_SELL))); }

  /**
   * Gets signal's open direction.
   *
   * @return
   *   Returns +1 for upwards, -1 for downwards, or 0 for a neutral direction.
   */
  char GetSignalOpenDirection() {
    if (signal.CheckSignals(SIGNAL_OPEN_UPWARDS)) {
      return 1;
    } else if (signal.CheckSignals(SIGNAL_OPEN_DOWNWARDS)) {
      return -1;
    }
    return 0;
  }

  /* Serializers */

  /**
   * Serializes this class.
   *
   * @return
   *   Returns a JSON serialized instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.PassStruct(THIS_REF, "signal", signal);
    return SerializerNodeObject;
  }

  /**
   * Converts this class into a string.
   *
   * @return
   *   Returns a JSON serialized signal.
   */
  string ToString() { return signal.ToString(); }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: TradeSignal.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: BasicTrade.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Dict.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: SerializerJson.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: SummaryReport.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Account.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Convert.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Order.struct.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: BasicTrade.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */







/**
 * Class to provide a summary report.
 */
class SummaryReport {

  protected:

    // Variables.
    double init_deposit;
    double summary_profit;
    double gross_profit;
    double gross_loss;
    double max_profit;
    double min_profit;
    double con_profit1;
    double con_profit2;
    double con_loss1;
    double con_loss2;
    double max_loss;
    double max_dd;
    double max_dd_pct;
    double rel_dd_pct;
    double rel_dd;
    double expected_payoff;
    double profit_factor;
    double abs_dd;
    int    summary_trades;
    int    profit_trades;
    int    loss_trades;
    int    short_trades;
    int    long_trades;
    int    win_short_trades;
    int    win_long_trades;
    int    con_profit_trades1;
    int    con_profit_trades2;
    int    con_loss_trades1;
    int    con_loss_trades2;
    int    avg_con_wins;
    int    avg_con_losses;

    double init_balance;

  public:

    /**
     * Default constructor.
     */
    SummaryReport() {
      InitVars(Account::AccountBalance());
    }

    /**
     * Constructor to initialize starting balance.
     */
    SummaryReport(double deposit) {
      InitVars(deposit);
    }

    /**
     * Constructor to initialize starting balance.
     */
    void InitVars(double deposit = 0) {
      init_deposit = deposit;
      max_loss = deposit;
      summary_profit = 0.0;
      gross_profit = 0.0;
      gross_loss = 0.0;
      max_profit = 0.0;
      min_profit = 0.0;
      con_profit1 = 0.0;
      con_profit2 = 0.0;
      con_loss1 = 0.0;
      con_loss2 = 0.0;
      max_dd = 0.0;
      max_dd_pct = 0.0;
      rel_dd_pct = 0.0;
      rel_dd = 0.0;
      expected_payoff = 0.0;
      profit_factor = 0.0;
      abs_dd = 0.0;
      summary_trades = 0;
      profit_trades = 0;
      loss_trades = 0;
      short_trades = 0;
      long_trades = 0;
      win_short_trades = 0;
      win_long_trades = 0;
      con_profit_trades1 = 0;
      con_profit_trades2 = 0;
      con_loss_trades1 = 0;
      con_loss_trades2 = 0;
      avg_con_wins = 0;
      avg_con_losses = 0;
    }

    /**
     * Get initial deposit.
     */
    double GetInitDeposit() {
      static double deposit = 0;
      if (deposit > 0) {
        return deposit;
      }
      else if (!Terminal::IsRealtime() && init_deposit > 0) {
        deposit = init_deposit;
      } else {
        deposit = Account::CalcInitDeposit();
      }
      return (deposit);
    }

    /**
     * Calculates summary details.
     */
    void CalculateSummary() {
      int    sequence = 0, profitseqs = 0, loss_seqs = 0;
      double sequential = 0.0, prev_profit = EMPTY_VALUE, dd_pct, drawdown;
      double max_peak = init_deposit, min_peak = init_deposit, balance = init_deposit;
      int    trades_total = TradeHistoryStatic::HistoryOrdersTotal();
      double profit;

      // Initialize summaries.
      InitVars(init_deposit);

      for (int i = 0; i < trades_total; i++) {
        if (!Order::TryOrderSelect(i, SELECT_BY_POS, MODE_HISTORY)) {
          continue;
        }
        int type = Order::OrderType();
        // Initial balance not considered.
        if (i == 0 && type == ACC_OP_BALANCE) continue;
        // Calculate profit.
        profit = OrderStatic::Profit() + OrderStatic::Commission() + Order::OrderSwap();
        balance += profit;
        // Drawdown check.
        if (max_peak < balance) {
          drawdown = max_peak-min_peak;
          if (max_peak != 0.0) {
            dd_pct = drawdown / max_peak * 100.0;
            if (rel_dd_pct < dd_pct) {
              rel_dd_pct = dd_pct;
              rel_dd = drawdown;
            }
          }
          if (max_dd < drawdown) {
            max_dd = drawdown;
            max_dd_pct = max_peak != 0.0 ? max_dd / max_peak * 100.0 : 100.0;
          }
          max_peak = balance;
          min_peak = balance;
        }
        if (min_peak > balance) min_peak = balance;
        if (max_loss > balance) max_loss = balance;
        // Market orders only.
        if (type != ORDER_TYPE_BUY && type != ORDER_TYPE_SELL) continue;
        // Calculate profit in points.
        // profit = (OrderClosePrice() - OrderOpenPrice()) / MarketInfo(OrderSymbol(), MODE_POINT);
        summary_profit += profit;
        summary_trades++;
        if (type == ORDER_TYPE_BUY) {
          long_trades++;
        }
        else if (type == ORDER_TYPE_SELL) {
          short_trades++;
        }
        if (profit < 0) {
          // Loss trades.
          loss_trades++;
          gross_loss += profit;
          if (min_profit > profit) min_profit = profit;
          // Fortune changed.
          if (prev_profit != EMPTY_VALUE && prev_profit >= 0) {
            if (con_profit_trades1 < sequence ||
                (con_profit_trades1 == sequence && con_profit2 < sequential)) {
              con_profit_trades1 = sequence;
              con_profit1 = sequential;
            }
            if (con_profit2 < sequential ||
                (con_profit2 == sequential && con_profit_trades1 < sequence)) {
              con_profit2 = sequential;
              con_profit_trades2 = sequence;
            }
            profitseqs++;
            avg_con_wins += sequence;
            sequence = 0;
            sequential = 0.0;
          }
        } else {
          // Profit trades (profit >= 0).
          profit_trades++;
          if (type == ORDER_TYPE_BUY) win_long_trades++;
          if (type == ORDER_TYPE_SELL) win_short_trades++;
          gross_profit += profit;
          if (max_profit < profit) max_profit = profit;
          // Fortune changed.
          if (prev_profit != EMPTY_VALUE && prev_profit < 0) {
            if (con_loss_trades1 < sequence ||
                (con_loss_trades1 == sequence && con_loss2 > sequential)) {
              con_loss_trades1 = sequence;
              con_loss1 = sequential;
            }
            if (con_loss2 > sequential ||
                (con_loss2 == sequential && con_loss_trades1 < sequence)) {
              con_loss2 = sequential;
              con_loss_trades2 = sequence;
            }
            loss_seqs++;
            avg_con_losses += sequence;
            sequence = 0;
            sequential = 0.0;
          }
        }
        sequence++;
        sequential += profit;
        prev_profit = profit;
      }
      // Final drawdown check.
      drawdown = max_peak - min_peak;
      if (max_peak != 0.0) {
        dd_pct = drawdown / max_peak * 100.0;
        if (rel_dd_pct < dd_pct) {
          rel_dd_pct = dd_pct;
          rel_dd = drawdown;
        }
      }
      if (max_dd < drawdown) {
        max_dd = drawdown;
        max_dd_pct = max_peak != 0 ? max_dd / max_peak * 100.0 : 100.0;
      }
      // Consider last trade.
      if (prev_profit != EMPTY_VALUE) {
        profit = prev_profit;
        if (profit < 0) {
          if (con_loss_trades1 < sequence ||
              (con_loss_trades1 == sequence && con_loss2 > sequential)) {
            con_loss_trades1 = sequence;
            con_loss1 = sequential;
          }
          if (con_loss2 > sequential ||
              (con_loss2 == sequential && con_loss_trades1 < sequence)) {
            con_loss2 = sequential;
            con_loss_trades2 = sequence;
          }
          loss_seqs++;
          avg_con_losses += sequence;
        }
        else {
          if (con_profit_trades1 < sequence ||
              (con_profit_trades1 == sequence && con_profit2 < sequential)) {
            con_profit_trades1 = sequence;
            con_profit1 = sequential;
          }
          if (con_profit2 < sequential ||
              (con_profit2 == sequential && con_profit_trades1 < sequence)) {
            con_profit2 = sequential;
            con_profit_trades2 = sequence;
          }
          profitseqs++;
          avg_con_wins += sequence;
        }
      }
      // Collecting done.
      double dnum, profitkoef = 0.0, losskoef = 0.0, avg_profit = 0.0, avgloss = 0.0;
      // Average consecutive wins and losses.
      dnum = avg_con_wins;
      avg_con_wins = profitseqs > 0 ?  (int) (dnum / profitseqs + 0.5) : 0;
      dnum = avg_con_losses;
      avg_con_losses = loss_seqs > 0 ? (int) (dnum / loss_seqs + 0.5) : 0;
      // Absolute values.
      if (gross_loss < 0.0) gross_loss *=- 1.0;
      if (min_profit < 0.0) min_profit *=- 1.0;
      if (con_loss1 < 0.0)  con_loss1 *=- 1.0;
      if (con_loss2 < 0.0)  con_loss2 *=- 1.0;
      profit_factor = gross_loss > 0.0 ? gross_profit / gross_loss : 0.0;
      // Expected payoff.
      avg_profit = profit_trades > 0 ? gross_profit / profit_trades : 0;
      avgloss = loss_trades > 0 ? gross_loss / loss_trades : 0;
      if (summary_trades > 0) {
        profitkoef = 1.0 * profit_trades / summary_trades;
        losskoef = 1.0 * loss_trades / summary_trades;
        expected_payoff = profitkoef * avg_profit - losskoef * avgloss;
      }
      // Absolute drawdown.
      abs_dd = init_deposit - max_loss;
    }

    /**
     * Return summary report.
     */
    string GetReport(string sep = "\n", string _currency = "") {
      string output = "";
      _currency = _currency != "" ? _currency : AccountInfoString(ACCOUNT_CURRENCY);
      output += StringFormat("Currency pair symbol:                       %s", _Symbol) + sep;
      output += StringFormat("Initial deposit:                            %.2f %s", GetInitDeposit(), _currency) + sep;
      output += StringFormat("Total net profit:                           %.2f %s", summary_profit, _currency) + sep;
      output += StringFormat("Gross profit:                               %.2f %s", gross_profit, _currency) + sep;
      output += StringFormat("Gross loss:                                 %.2f %s", gross_loss, _currency)  + sep;
      output += StringFormat("Absolute drawdown:                          %.2f %s", abs_dd, _currency) + sep;
      output += StringFormat("Maximal drawdown:                           %.1f %s (%.1f%%)", max_dd, _currency, max_dd_pct) + sep;
      output += StringFormat("Relative drawdown:                          (%.1f%%) %.1f %s", rel_dd_pct, rel_dd, _currency) + sep;
      output += StringFormat("Profit factor:                              %.2f", profit_factor) + sep;
      output += StringFormat("Expected payoff:                            %.2f", expected_payoff) + sep;
      output += StringFormat("Trades total                                %d", summary_trades) + sep;
      output += StringFormat("Short positions (won %%):                    %d (%.1f%%)", short_trades, short_trades ? 100.0 * win_short_trades / short_trades : 0) + sep;
      output += StringFormat("Long positions (won %%):                     %d (%.1f%%)", long_trades, long_trades ? 100.0 * win_long_trades / long_trades : 0) + sep;
      output += StringFormat("Profit trades (%% of total):                 %d (%.1f%%)", profit_trades, profit_trades ? 100.0 * profit_trades / summary_trades : 0) + sep;
      output += StringFormat("Loss trades (%% of total):                   %d (%.1f%%)", loss_trades, loss_trades ? 100.0 * loss_trades / summary_trades : 0) + sep;
      output += StringFormat("Largest profit trade:                       %.2f", max_profit) + sep;
      output += StringFormat("Largest loss trade:                         %.2f", -min_profit) + sep;
      output += StringFormat("Average profit trade:                       %.2f", profit_trades ? gross_profit / profit_trades : 0) + sep;
      output += StringFormat("Average loss trade:                         %.2f", loss_trades ? -gross_loss / loss_trades : 0) + sep;
      output += StringFormat("Average consecutive wins:                   %.2f", avg_con_wins) + sep;
      output += StringFormat("Average consecutive losses:                 %.2f", avg_con_losses) + sep;
      output += StringFormat("Maximum consecutive wins (profit in money): %d (%.2f)", con_profit_trades1, con_profit1) + sep;
      output += StringFormat("Maximum consecutive losses (loss in money): %d (%.2f)", con_loss_trades1, -con_loss1) + sep;
      output += StringFormat("Maximal consecutive profit (count of wins): %.2f (%d)", con_profit2, con_profit_trades2) + sep;
      output += StringFormat("Maximal consecutive loss (count of losses): %.2f (%d)", con_loss2, con_loss_trades2) + sep;
      return output;
    }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: SummaryReport.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: EA.enum.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Task.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Action.enum.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: TradeSignalManager.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: TradeSignal.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../DictObject.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: TradeSignalManager.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Implements TradeSignalManager's structures.
 */

// Defines.
#define TSM_PROP_FREQ STRUCT_ENUM(TradeSignalManagerParams, TSM_PARAMS_PROP_FREQ)
#define TSM_PROP_LAST_CHECK STRUCT_ENUM(TradeSignalManagerParams, TSM_PARAMS_PROP_LAST_CHECK)

/**
 * Structure to manage TradeSignalManager parameters.
 */
struct TradeSignalManagerParams {
 protected:
  long last_check;  // Last check.
  short freq;       // Signal process refresh frequency (in sec).

 public:
  /* Struct's enumerations */

  // Enumeration for strategy bitwise signal flags.
  enum ENUM_TSM_PARAMS_PROP {
    TSM_PARAMS_PROP_FREQ = 0,
    TSM_PARAMS_PROP_LAST_CHECK,
  };

  /**
   * Struct constructor.
   */
  TradeSignalManagerParams(short _freq = 10) : freq(_freq), last_check(0) {}

  /**
   * Struct copy constructor.
   */
  TradeSignalManagerParams(TradeSignalManagerParams &_params) { THIS_REF = _params; }

  /* Getters */

  template <typename T>
  T Get(STRUCT_ENUM(TradeSignalManagerParams, ENUM_TSM_PARAMS_PROP) _prop) {
    switch (_prop) {
      case TSM_PARAMS_PROP_FREQ:
        return (T)freq;
      case TSM_PARAMS_PROP_LAST_CHECK:
        return (T)last_check;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }

  /* Setters */

  template <typename T>
  void Set(STRUCT_ENUM(TradeSignalManagerParams, ENUM_TSM_PARAMS_PROP) _prop, T _value) {
    switch (_prop) {
      case TSM_PARAMS_PROP_FREQ:
        freq = (short)_value;
        return;
      case TSM_PARAMS_PROP_LAST_CHECK:
        last_check = (long)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }

  /* Serializers */

  SERIALIZER_EMPTY_STUB;

  /**
   * Serializes this class.
   *
   * @return
   *   Returns a JSON serialized instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.Pass(THIS_REF, "freq", freq);
    return SerializerNodeObject;
  }

  /**
   * Converts this class into a string.
   *
   * @return
   *   Returns a JSON serialized signal.
   */
  string ToString() {
    return SerializerConverter::FromObject(THIS_REF, SERIALIZER_FLAG_SKIP_HIDDEN)
        .ToString<SerializerJson>(SERIALIZER_JSON_NO_WHITESPACES);
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: TradeSignalManager.struct.h
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Implements TradeSignalManager class.
 */

// Includes.




/**
 * Class to store and manage a trading signal.
 */
class TradeSignalManager : Dynamic {
 protected:
  DictObject<int, TradeSignal> signals_active;
  DictObject<int, TradeSignal> signals_expired;
  DictObject<int, TradeSignal> signals_processed;
  TradeSignalManagerParams params;

  /**
   * Init code (called on constructor).
   */
  void Init() {
    signals_active.AddFlags(DICT_FLAG_FILL_HOLES_UNSORTED);
    signals_expired.AddFlags(DICT_FLAG_FILL_HOLES_UNSORTED);
    signals_processed.AddFlags(DICT_FLAG_FILL_HOLES_UNSORTED);
  }

 public:
  /**
   * Default class constructor.
   */
  TradeSignalManager() { Init(); }

  /**
   * Class constructor with parameters.
   */
  TradeSignalManager(TradeSignalManagerParams &_params) : params(_params) { Init(); }

  /* Getters */

  /**
   * Gets a property value.
   */
  template <typename T>
  T Get(STRUCT_ENUM(TradeSignalManagerParams, ENUM_TSM_PARAMS_PROP) _prop) {
    return params.Get<T>(_prop);
  }

  /**
   * Gets an iterator instance.
   *
   */
  DictObjectIterator<int, TradeSignal> GetIterSignalsActive() {
    DictObjectIterator<int, TradeSignal> _iter = signals_active.Begin();
    return _iter;
  }

  /**
   * Gets pointer to active signals.
   *
   */
  DictObject<int, TradeSignal> *GetSignalsActive() { return &signals_active; }

  /**
   * Gets pointer to expired signals.
   *
   */
  DictObject<int, TradeSignal> *GetSignalsExpired() { return &signals_expired; }

  /**
   * Gets pointer to processed signals.
   *
   */
  DictObject<int, TradeSignal> *GetSignalsProcessed() { return &signals_processed; }

  /* Setters */

  /**
   * Sets a property value.
   */
  template <typename T>
  void Set(STRUCT_ENUM(TradeSignalManagerParams, ENUM_TSM_PARAMS_PROP) _prop, T _value) {
    params.Set<T>(_prop, _value);
  }

  /* Signal methods */

  /**
   * Adds new signal.
   *
   */
  void SignalAdd(TradeSignal &_signal) { signals_active.Push(_signal); }

  /**
   * Refresh signals.
   *
   * Move already processed signals or expired to different list.
   *
   */
  void Refresh() {
    for (DictObjectIterator<int, TradeSignal> iter = GetIterSignalsActive(); iter.IsValid(); ++iter) {
      TradeSignal *_signal = iter.Value();
      if (_signal.Get(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_PROCESSED))) {
        signals_active.Unset(iter);
        signals_processed.Push(_signal);
        continue;
      }
      if (_signal.Get(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_EXPIRED))) {
        signals_active.Unset(iter);
        signals_expired.Push(_signal);
        continue;
      }
    }
    Set<long>(TSM_PROP_LAST_CHECK, ::TimeGMT());
  }

  /* State methods */

  /**
   * Checks if signal manager is ready for signal processing based on the frequency param.
   *
   * @param
   *   _update Update last check timestamp when true.
   */
  bool IsReady(bool _update = true) {
    bool _res = Get<long>(TSM_PROP_LAST_CHECK) + Get<short>(TSM_PROP_FREQ) >= ::TimeGMT();
    if (_res) {
      Set<long>(TSM_PROP_LAST_CHECK, ::TimeGMT());
    }
    return _res;
  }

  /* Serializers */

  SERIALIZER_EMPTY_STUB;

  /**
   * Serializes this class.
   *
   * @return
   *   Returns a JSON serialized instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.PassObject(THIS_REF, "signals_active", signals_active);
    return SerializerNodeObject;
  }

  /**
   * Converts this class into a string.
   *
   * @return
   *   Returns a JSON serialized signal.
   */
  string ToString() {
    // SerializerConverter _stub = SerializerConverter::MakeStubObject<TradeSignalManager>(SERIALIZER_FLAG_SKIP_HIDDEN);
    return SerializerConverter::FromObject(THIS_REF, SERIALIZER_FLAG_INCLUDE_ALL | SERIALIZER_FLAG_SKIP_HIDDEN)
        .ToString<SerializerJson>(SERIALIZER_JSON_NO_WHITESPACES);
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: TradeSignalManager.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: EA.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: DateTime.mqh
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Task.struct.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Includes EA's structs.
 */

#ifndef __MQL__
// Allows the preprocessor to include a header file when it is needed.
#pragma once
#endif

// Includes.



/* Defines EA config parameters. */
struct EAParams {
 protected:
  float risk_margin_max;       // Max margin to risk in percentage.
  string author;               // EA's author.
  string desc;                 // EA's description.
  string name;                 // EA's name.
  string symbol;               // Symbol to trade on.
  string ver;                  // EA's version.
  unsigned int flags;          // EA's param flags.
  unsigned int signal_filter;  // EA's signal filter.
  unsigned short data_export;  // Format to export the data.
  unsigned short data_store;   // Type of data to store.
  ENUM_LOG_LEVEL log_level;    // Log verbosity level.
  int chart_info_freq;         // Updates info on chart (in secs, 0 - off).
  TaskEntry task_init;         // Task entry to add and process on EA init.

 public:
  // Defines enumeration for EA params properties.
  enum ENUM_EA_PARAM_PROP {
    EA_PARAM_PROP_NONE = 0,         // None
    EA_PARAM_PROP_AUTHOR,           // Author
    EA_PARAM_PROP_CHART_INFO_FREQ,  // Chart frequency
    EA_PARAM_PROP_DATA_EXPORT,      // Data export
    EA_PARAM_PROP_DATA_STORE,       // Data store
    EA_PARAM_PROP_DESC,             // Description
    EA_PARAM_PROP_FLAGS,            // Flags
    EA_PARAM_PROP_LOG_LEVEL,        // Log level
    EA_PARAM_PROP_NAME,             // Name
    EA_PARAM_PROP_RISK_MARGIN_MAX,  // Maximum margin to risk
    EA_PARAM_PROP_SIGNAL_FILTER,    // Signal filter
    EA_PARAM_PROP_SYMBOL,           // Symbol
    EA_PARAM_PROP_VER,              // Version
  };
  // Defines enumeration for EA params structs.
  enum ENUM_EA_PARAM_STRUCT {
    EA_PARAM_STRUCT_NONE = 0,    // None
    EA_PARAM_STRUCT_TASK_ENTRY,  // Task entry
  };
  // Defines enumeration for strategy signal filters.
  enum ENUM_EA_PARAM_SIGNAL_FILTER {
    EA_PARAM_SIGNAL_FILTER_NONE = 0 << 0,         // None flags.
    EA_PARAM_SIGNAL_FILTER_FIRST = 1 << 0,        // First signal only
    EA_PARAM_SIGNAL_FILTER_OPEN_M_IF_H = 1 << 1,  // Minute-based confirmed by hourly signal
  };

  // Struct special methods.
  EAParams(string _name = __FILE__, ENUM_LOG_LEVEL _ll = V_INFO, unsigned long _magic = 0)
      : author("unknown"),
        data_store(EA_DATA_STORE_NONE),
        flags(EA_PARAM_FLAG_NONE),
        risk_margin_max(5),
        name(_name),
        desc("..."),
        signal_filter(EA_PARAM_SIGNAL_FILTER_NONE),
        symbol(_Symbol),
        ver("v1.00"),
        log_level(_ll),
        chart_info_freq(0) {}
  // Flag methods.
  bool CheckFlag(unsigned int _flag) { return bool(flags & _flag); }
  bool CheckFlagDataStore(unsigned int _flag) { return bool(data_store & _flag); }
  bool CheckSignalFilter(unsigned int _flag) { return bool(signal_filter & _flag); }
  void AddFlags(unsigned int _flags) { flags |= _flags; }
  void RemoveFlags(unsigned int _flags) { flags &= ~_flags; }
  void SetFlag(ENUM_EA_PARAM_FLAGS _flag, bool _value) {
    if (_value) {
      AddFlags(_flag);
    } else {
      RemoveFlags(_flag);
    }
  }
  void SetFlags(unsigned int _flags) { flags = _flags; }
  // Getters.
  template <typename T>
  T Get(unsigned int _param) {
    switch (_param) {
      case EA_PARAM_PROP_AUTHOR:
        return (T)author;
      case EA_PARAM_PROP_CHART_INFO_FREQ:
        return (T)chart_info_freq;
      case EA_PARAM_PROP_DATA_EXPORT:
        return (T)data_export;
      case EA_PARAM_PROP_DATA_STORE:
        return (T)data_store;
      case EA_PARAM_PROP_DESC:
        return (T)desc;
      case EA_PARAM_PROP_LOG_LEVEL:
        return (T)log_level;
      case EA_PARAM_PROP_NAME:
        return (T)name;
      case EA_PARAM_PROP_RISK_MARGIN_MAX:
        return (T)risk_margin_max;
      case EA_PARAM_PROP_SIGNAL_FILTER:
        return (T)signal_filter;
      case EA_PARAM_PROP_SYMBOL:
        return (T)symbol;
      case EA_PARAM_PROP_VER:
        return (T)ver;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }
  template <typename T>
  T GetStruct(unsigned int _param) {
    switch (_param) {
      case EA_PARAM_STRUCT_TASK_ENTRY:
        return (T)task_init;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    T _empty();
    return _empty;
  }
  // Setters.
  template <typename T>
  void Set(STRUCT_ENUM(EAParams, ENUM_EA_PARAM_PROP) _param, T _value) {
    switch (_param) {
      case EA_PARAM_PROP_AUTHOR:
        author = (string)_value;
        return;
      case EA_PARAM_PROP_CHART_INFO_FREQ:
        chart_info_freq = (int)_value;
        return;
      case EA_PARAM_PROP_DATA_EXPORT:
        data_export = (unsigned short)_value;
        return;
      case EA_PARAM_PROP_DATA_STORE:
        data_store = (unsigned short)_value;
        return;
      case EA_PARAM_PROP_DESC:
        desc = (string)_value;
        return;
      case EA_PARAM_PROP_LOG_LEVEL:
        log_level = (ENUM_LOG_LEVEL)_value;
        return;
      case EA_PARAM_PROP_NAME:
        name = (string)_value;
        return;
      case EA_PARAM_PROP_RISK_MARGIN_MAX:
        risk_margin_max = (float)_value;
        return;
      case EA_PARAM_PROP_SIGNAL_FILTER:
        signal_filter = (unsigned int)_value;
        return;
      case EA_PARAM_PROP_SYMBOL:
        symbol = (string)_value;
        return;
      // case EA_PARAM_TASK_ENTRY: SetTaskEntry(_value); return;
      case EA_PARAM_PROP_VER:
        ver = (string)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  // Sets EA's details (name, description, version and author).
  void SetDetails(string _name = "", string _desc = "", string _ver = "", string _author = "") {
    name = _name;
    desc = _desc;
    ver = _ver;
    author = _author;
  }
  void SetTaskEntry(TaskEntry &_task_entry) { task_init = _task_entry; }
  // Printers.
  string ToString(string _dlm = ",") { return StringFormat("%s v%s by %s (%s)", name, ver, author, desc); }
};

/* Defines struct to store results for EA processing. */
struct EAProcessResult {
  unsigned int last_error;               // Last error code.
  unsigned short stg_errored;            // Number of errored strategies.
  unsigned short stg_processed;          // Number of processed strategies.
  unsigned short stg_processed_periods;  // Number of new period processed.
  unsigned short stg_suspended;          // Number of suspended strategies.
  unsigned short tasks_processed;        // Number of tasks processed.
  EAProcessResult() { Reset(); }
  void Reset() {
    stg_errored = stg_processed = stg_suspended = 0;
    ResetError();
  }
  void ResetError() {
    ResetLastError();
    last_error = ERR_NO_ERROR;
  }
  string ToString() { return StringFormat("%d", last_error); }
};

/* Defines EA state variables. */
struct EAState {
 public:                  // @todo: Move to protected.
  DateTime last_updated;  // Last updated.
 protected:
  unsigned int flags;        // Action flags.
  unsigned int new_periods;  // Started periods.
 public:
  /* Struct's enumerations */

  /* Defines EA state flags. */
  enum ENUM_EA_STATE_FLAGS {
    EA_STATE_FLAG_NONE = 0 << 0,           // None flags.
    EA_STATE_FLAG_ACTIVE = 1 << 0,         // Is active (can trade).
    EA_STATE_FLAG_CONNECTED = 1 << 1,      // Indicates connectedness to a trade server.
    EA_STATE_FLAG_ENABLED = 1 << 2,        // Is enabled.
    EA_STATE_FLAG_LIBS_ALLOWED = 1 << 3,   // Indicates the permission to use external libraries (such as DLL).
    EA_STATE_FLAG_ON_INIT = 1 << 4,        // Indicates EA is during initializing procedure (constructor).
    EA_STATE_FLAG_ON_QUIT = 1 << 5,        // Indicates EA is during exiting procedure (deconstructor).
    EA_STATE_FLAG_OPTIMIZATION = 1 << 6,   // Indicates EA runs in optimization mode.
    EA_STATE_FLAG_TESTING = 1 << 7,        // Indicates EA runs in testing mode.
    EA_STATE_FLAG_TRADE_ALLOWED = 1 << 8,  // Indicates the permission to trade on the chart.
    EA_STATE_FLAG_VISUAL_MODE = 1 << 9,    // Indicates EA runs in visual testing mode.
  };

  // Enumeration for strategy signal properties.
  enum ENUM_EA_STATE_PROP {
    EA_STATE_PROP_FLAGS = 1,
    EA_STATE_PROP_LAST_UPDATED,
    EA_STATE_PROP_NEW_PERIODS,
    EA_STATE_PROP_TIMESTAMP,
  };

  /* Constructors */

  // Constructor.
  EAState() { EAState::AddFlags(EA_STATE_FLAG_ACTIVE | EA_STATE_FLAG_ENABLED); }
  // Struct methods.
  /* Getters */
  template <typename T>
  T Get(STRUCT_ENUM(EAState, ENUM_EA_STATE_PROP) _prop) {
    switch (_prop) {
      case EA_STATE_PROP_FLAGS:
        return (T)flags;
      /* @fixme
      case EA_STATE_PROP_LAST_UPDATED:
        return (T)last_updated;
      */
      case EA_STATE_PROP_NEW_PERIODS:
        return (T)new_periods;
    }
    SetUserError(ERR_INVALID_PARAMETER);
    return (T)WRONG_VALUE;
  }
  bool Get(STRUCT_ENUM(EAState, ENUM_EA_STATE_FLAGS) _prop) { return CheckFlag(_prop); }
  /* Setters */
  template <typename T>
  void Set(STRUCT_ENUM(EAState, ENUM_EA_STATE_PROP) _prop, T _value) {
    switch (_prop) {
      case EA_STATE_PROP_FLAGS:
        flags = (unsigned int)_value;
        return;
      /* @fixme
      case EA_STATE_PROP_LAST_UPDATED:
        last_updated = (unsigned int)_value;
        return;
      */
      case EA_STATE_PROP_NEW_PERIODS:
        new_periods = (unsigned int)_value;
        return;
    }
    SetUserError(ERR_INVALID_PARAMETER);
  }
  void Set(STRUCT_ENUM(EAState, ENUM_EA_STATE_FLAGS) _prop, bool _value) { SetFlag(_prop, _value); }
  // Flag methods.
  bool CheckFlag(unsigned int _flag) { return bool(flags & _flag); }
  void AddFlags(unsigned int _flags) { flags |= _flags; }
  void RemoveFlags(unsigned int _flags) { flags &= ~_flags; }
  void SetFlag(ENUM_EA_STATE_FLAGS _flag, bool _value) {
    if (_value) {
      AddFlags(_flag);
    } else {
      RemoveFlags(_flag);
    }
  }
  void SetFlags(unsigned int _flags) { flags = _flags; }
  // State methods.
  bool IsActive() { return CheckFlag(EA_STATE_FLAG_ACTIVE); }
  bool IsConnected() { return CheckFlag(EA_STATE_FLAG_CONNECTED); }
  bool IsEnabled() { return CheckFlag(EA_STATE_FLAG_ENABLED); }
  bool IsLibsAllowed() { return CheckFlag(EA_STATE_FLAG_LIBS_ALLOWED); }
  bool IsOnInit() { return CheckFlag(EA_STATE_FLAG_ON_INIT); }
  bool IsOnQuit() { return CheckFlag(EA_STATE_FLAG_ON_QUIT); }
  bool IsOptimizationMode() { return CheckFlag(EA_STATE_FLAG_OPTIMIZATION); }
  bool IsTestingMode() { return CheckFlag(EA_STATE_FLAG_TESTING); }
  bool IsTradeAllowed() { return CheckFlag(EA_STATE_FLAG_TRADE_ALLOWED); }
  bool IsVisualMode() { return CheckFlag(EA_STATE_FLAG_VISUAL_MODE); }
  // Setters.
  void Enable(bool _state = true) { SetFlag(EA_STATE_FLAG_ENABLED, _state); }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: EA.struct.h
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Terminal.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * @file
 * Implements Expert Advisor class for writing custom trading robots.
 */

// Prevents processing this includes file for the second time.
#ifndef EA_MQH
#define EA_MQH

// Includes.






















class EA {
 protected:
  // Class variables.
  Account *account;
  DictStruct<long, Ref<Strategy>> strats;
  Log logger;
  Terminal terminal;

  // Data variables.
  BufferStruct<ChartEntry> data_chart;
  BufferStruct<SymbolInfoEntry> data_symbol;
  Dict<string, double> ddata;  // Custom user data.
  Dict<string, int> idata;     // Custom user data.
  DictObject<string, Trade> trade;
  DictObject<ENUM_TIMEFRAMES, BufferStruct<IndicatorDataEntry>> data_indi;
  DictObject<ENUM_TIMEFRAMES, BufferStruct<StgEntry>> data_stg;
  DictStruct<int, TaskEntry> tasks;
  EAParams eparams;
  EAProcessResult eresults;
  EAState estate;
  TradeSignalManager tsm;

 public:
  /**
   * Class constructor.
   */
  EA(EAParams &_params) : account(new Account) {
    eparams = _params;
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_ON_INIT), true);
    UpdateStateFlags();
    // Add and process tasks.
    TaskAdd(eparams.GetStruct<TaskEntry>(STRUCT_ENUM(EAParams, EA_PARAM_STRUCT_TASK_ENTRY)));
    ProcessTasks();
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_ON_INIT), false);
    // Initialize a trade instance for the current chart and symbol.
    ChartParams _cparams((ENUM_TIMEFRAMES)_Period, _Symbol);
    TradeParams _tparams;
    Trade _trade(_tparams, _cparams);
    trade.Set(_Symbol, _trade);
    logger.Link(_trade.GetLogger());
  }

  /**
   * Class deconstructor.
   */
  ~EA() {
    // Process tasks on quit.
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_ON_QUIT), true);
    ProcessTasks();
    // Deinitialize classes.
    Object::Delete(account);
  }

  /* Getters */

  /**
   * Gets EA state flag value.
   */
  bool Get(STRUCT_ENUM(EAState, ENUM_EA_STATE_FLAGS) _prop) { return estate.Get(_prop); }

  /**
   * Gets EA parameter value.
   */
  template <typename T>
  T Get(STRUCT_ENUM(EAParams, ENUM_EA_PARAM_PROP) _param) {
    return eparams.Get<T>(_param);
  }

  /**
   * Gets EA state property value.
   */
  template <typename T>
  T Get(STRUCT_ENUM(EAState, ENUM_EA_STATE_PROP) _prop) {
    return estate.Get<T>(_prop);
  }

  /**
   * Gets a Trade's state value.
   */
  template <typename T>
  T Get(ENUM_TRADE_STATE _state, string _symbol = NULL) {
    return trade.GetByKey(_symbol != NULL ? _symbol : _Symbol).Get<T>(_state);
  }

  /**
   * Gets a strategy's signal entry.
   *
   * @param Strategy _strat
   *   Reference to strategy to get the signal from.
   * @param bool _trade_allowed
   *   True if trade is allowed.
   * @param int _shift
   *   Bar shift.
   *
   * @return
   *   Returns TradeSignalEntry struct.
   */
  TradeSignalEntry GetStrategySignalEntry(Strategy *_strat, bool _trade_allowed = true, int _shift = -1) {
    // float _bf = 1.0;
    float _scl = _strat.Get<float>(STRAT_PARAM_SCL);
    float _sol = _strat.Get<float>(STRAT_PARAM_SOL);
    int _scfm = _strat.Get<int>(STRAT_PARAM_SCFM);
    int _scft = _strat.Get<int>(STRAT_PARAM_SCFT);
    int _scm = _strat.Get<int>(STRAT_PARAM_SCM);
    int _sob = _strat.Get<int>(STRAT_PARAM_SOB);
    int _sofm = _strat.Get<int>(STRAT_PARAM_SOFM);
    int _soft = _strat.Get<int>(STRAT_PARAM_SOFT);
    int _som = _strat.Get<int>(STRAT_PARAM_SOM);
    int _ss = _shift >= 0 ? _shift : _strat.Get<int>(STRAT_PARAM_SHIFT);
    unsigned int _signals = 0;
    // sparams.Get<float>(STRAT_PARAM_WEIGHT));
    if (_trade_allowed) {
      // Process boost factor and lot size.
      // sresult.SetBoostFactor(sparams.IsBoosted() ? SignalOpenBoost(ORDER_TYPE_BUY, _sob) : 1.0f);
      // sresult.SetLotSize(sparams.GetLotSizeWithFactor());
      // Process open signals when trade is allowed.
      _signals |= _strat.SignalOpen(ORDER_TYPE_BUY, _som, _sol, _ss) ? SIGNAL_OPEN_BUY_MAIN : 0;
      _signals |= !_strat.SignalOpenFilterMethod(ORDER_TYPE_BUY, _sofm) ? SIGNAL_OPEN_BUY_FILTER : 0;
      _signals |= _strat.SignalOpen(ORDER_TYPE_SELL, _som, _sol, _ss) ? SIGNAL_OPEN_SELL_MAIN : 0;
      _signals |= !_strat.SignalOpenFilterMethod(ORDER_TYPE_SELL, _sofm) ? SIGNAL_OPEN_SELL_FILTER : 0;
      _signals |= !_strat.SignalOpenFilterTime(_soft) ? SIGNAL_OPEN_TIME_FILTER : 0;
    }
    // Process close signals.
    _signals |= _strat.SignalClose(ORDER_TYPE_BUY, _scm, _scl, _ss) ? SIGNAL_CLOSE_BUY_MAIN : 0;
    _signals |= !_strat.SignalCloseFilter(ORDER_TYPE_BUY, _scfm) ? SIGNAL_CLOSE_BUY_FILTER : 0;
    _signals |= _strat.SignalClose(ORDER_TYPE_SELL, _scm, _scl, _ss) ? SIGNAL_CLOSE_SELL_MAIN : 0;
    _signals |= !_strat.SignalCloseFilter(ORDER_TYPE_SELL, _scfm) ? SIGNAL_CLOSE_SELL_FILTER : 0;
    _signals |= !_strat.SignalCloseFilterTime(_scft) ? SIGNAL_CLOSE_TIME_FILTER : 0;
    TradeSignalEntry _sentry(_signals, _strat.Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF), _strat.Get<long>(STRAT_PARAM_ID));
    _sentry.Set(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_PROP_STRENGTH), _strat.SignalOpen(_sofm, _sol, _ss));
    _sentry.Set(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_PROP_TIME), ::TimeGMT());
    return _sentry;
  }

  /* Setters */

  /**
   * Sets an EA parameter value.
   */
  template <typename T>
  void Set(STRUCT_ENUM(EAParams, ENUM_EA_PARAM_PROP) _param, T _value) {
    eparams.Set<T>(_param, _value);
  }

  /**
   * Sets EA state flag value.
   */
  void Set(STRUCT_ENUM(EAState, ENUM_EA_STATE_FLAGS) _prop, bool _value) { estate.Set(_prop, _value); }

  /**
   * Sets an strategy parameter value for all strategies.
   */
  template <typename T>
  void Set(ENUM_STRATEGY_PARAM _param, T _value) {
    for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
      Strategy *_strat = iter.Value().Ptr();
      _strat.Set<T>(_param, _value);
    }
  }

  /**
   * Sets a trade parameter value for all trade instances.
   */
  template <typename T>
  void Set(ENUM_TRADE_PARAM _param, T _value) {
    for (DictObjectIterator<string, Trade> iter = trade.Begin(); iter.IsValid(); ++iter) {
      Trade *_trade = iter.Value();
      _trade.Set<T>(_param, _value);
    }
  }

  /* Processing methods */

  /**
   * Process strategy signals.
   */
  bool ProcessSignals(const MqlTick &_tick, unsigned int _sig_filter = 0, bool _trade_allowed = true) {
    bool _result = true;
    int _last_error = ERR_NO_ERROR;
    ResetLastError();
    for (DictObjectIterator<int, TradeSignal> _iter = tsm.GetIterSignalsActive(); _iter.IsValid(); ++_iter) {
      bool _result_local = true;
      TradeSignal *_signal = _iter.Value();
      if (_signal.Get(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_PROCESSED))) {
        // Ignores already processed signals.
        continue;
      }
      Trade *_trade = trade.GetByKey(_Symbol);
      Strategy *_strat =
          strats.GetByKey(_signal.Get<long>(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_PROP_MAGIC_ID))).Ptr();
      if (_trade.Get<bool>(TRADE_STATE_ORDERS_ACTIVE)) {
        float _sig_close = _signal.GetSignalClose();
        string _comment_close =
            _strat != NULL && _sig_close != 0.0f ? _strat.GetOrderCloseComment() : __FUNCTION_LINE__;
        // Check if we should close the orders.
        if (_sig_close >= 0.5f) {
          // Close signal for buy order.
          _trade.OrdersCloseViaProp2<ENUM_ORDER_PROPERTY_INTEGER, long>(
              ORDER_MAGIC, _signal.Get<long>(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_PROP_MAGIC_ID)), ORDER_TYPE,
              ORDER_TYPE_BUY, MATH_COND_EQ, ORDER_REASON_CLOSED_BY_SIGNAL, _comment_close);
          // Buy orders closed.
          _strat.OnOrderClose(ORDER_TYPE_BUY);
        }
        if (_sig_close <= -0.5f) {
          // Close signal for sell order.
          _trade.OrdersCloseViaProp2<ENUM_ORDER_PROPERTY_INTEGER, long>(
              ORDER_MAGIC, _signal.Get<long>(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_PROP_MAGIC_ID)), ORDER_TYPE,
              ORDER_TYPE_SELL, MATH_COND_EQ, ORDER_REASON_CLOSED_BY_SIGNAL, _comment_close);
          // Sell orders closed.
          _strat.OnOrderClose(ORDER_TYPE_SELL);
        }
      }
      _trade_allowed &= _trade.IsTradeAllowed();
      _trade_allowed &= !_strat.IsSuspended();
      if (_trade_allowed) {
        float _sig_open = _signal.GetSignalOpen();
        unsigned int _sig_f = eparams.Get<unsigned int>(STRUCT_ENUM(EAParams, EA_PARAM_PROP_SIGNAL_FILTER));
        string _comment_open = _strat != NULL && _sig_open != 0.0f ? _strat.GetOrderOpenComment() : __FUNCTION_LINE__;
        // Open orders on signals.
        if (_sig_open >= 0.5f) {
          // Open signal for buy.
          // When H1 or H4 signal filter is enabled, do not open minute-based orders on opposite or neutral signals.
          if (_sig_f == 0) {  // @fixme: || GetSignalOpenFiltered(_signal, _sig_f) >= 0.5f) {
            _strat.Set(TRADE_PARAM_ORDER_COMMENT, _comment_open);
            // Buy order open.
            _result_local &= TradeRequest(ORDER_TYPE_BUY, _Symbol, _strat);
            if (_result_local && eparams.CheckSignalFilter(STRUCT_ENUM(EAParams, EA_PARAM_SIGNAL_FILTER_FIRST))) {
              _signal.Set(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_PROCESSED), true);
              break;
            }
          }
        }
        if (_sig_open <= -0.5f) {
          // Open signal for sell.
          // When H1 or H4 signal filter is enabled, do not open minute-based orders on opposite or neutral signals.
          if (_sig_f == 0) {  // @fixme: || GetSignalOpenFiltered(_signal, _sig_f) <= -0.5f) {
            _strat.Set(TRADE_PARAM_ORDER_COMMENT, _comment_open);
            // Sell order open.
            _result_local &= TradeRequest(ORDER_TYPE_SELL, _Symbol, _strat);
            if (_result_local && eparams.CheckSignalFilter(STRUCT_ENUM(EAParams, EA_PARAM_SIGNAL_FILTER_FIRST))) {
              _signal.Set(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_PROCESSED), true);
              break;
            }
          }
        }
        if (_result_local) {
          _signal.Set(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_FLAG_PROCESSED), true);
        } else {
          _last_error = GetLastError();
          if (_last_error > 0) {
            logger.Warning(StringFormat("Error: %d", _last_error), __FUNCTION_LINE__, _strat.GetName());
            ResetLastError();
          }
          if (_trade.Get<bool>(TRADE_STATE_MONEY_NOT_ENOUGH)) {
            logger.Warning(StringFormat("Suspending strategy.", _last_error), __FUNCTION_LINE__, _strat.GetName());
            _strat.Suspended(true);
          }
        }
      }
      _result &= _result_local;
    }
    _last_error = GetLastError();
    if (_last_error > 0) {
      logger.Warning(StringFormat("Processing signals failed! Code: %d", _last_error), __FUNCTION_LINE__);
    }
    // Refresh signals after processing.
    tsm.Refresh();
    return _result && _last_error == 0;
  }

  /**
   * Process a trade request.
   *
   * @return
   *   Returns true on successful request.
   */
  virtual bool TradeRequest(ENUM_ORDER_TYPE _cmd, string _symbol = NULL, Strategy *_strat = NULL) {
    bool _result = false;
    Trade *_trade = trade.GetByKey(_symbol);
    // Prepare a request.
    MqlTradeRequest _request = _trade.GetTradeOpenRequest(_cmd);
    _request.comment = _strat.GetOrderOpenComment();
    _request.magic = _strat.Get<long>(STRAT_PARAM_ID);
    _request.price = SymbolInfoStatic::GetOpenOffer(_symbol, _cmd);
    _request.volume = fmax(_strat.Get<float>(STRAT_PARAM_LS), SymbolInfoStatic::GetVolumeMin(_symbol));
    _request.volume = _trade.NormalizeLots(_request.volume);
    // Prepare an order parameters.
    OrderParams _oparams;
    _strat.OnOrderOpen(_oparams);
    // Send the request.
    _result = _trade.RequestSend(_request, _oparams);
    return _result;
  }

  /**
   * Process strategy signals on tick event.
   *
   * Note: Call this method for every market tick.
   *
   * @return
   *   Returns struct with the processed results.
   */
  virtual EAProcessResult ProcessTick() {
    if (estate.IsEnabled()) {
      MqlTick _tick = SymbolInfoStatic::GetTick(_Symbol);
      eresults.Reset();
      if (estate.IsActive()) {
        ProcessPeriods();
        // Process all enabled strategies and retrieve their signals.
        for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
          bool _can_trade = true;
          Strategy *_strat = iter.Value().Ptr();
          Trade *_trade = trade.GetByKey(_Symbol);
          if (_strat.IsEnabled()) {
            if (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) >= DATETIME_MINUTE) {
              // Process when new periods started.
              _strat.OnPeriod(estate.Get<unsigned int>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)));
              _strat.ProcessTasks();
              _trade.OnPeriod(estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)));
              eresults.stg_processed_periods++;
            }
            if (_strat.TickFilter(_tick)) {
              _can_trade &= !_strat.IsSuspended();
              _can_trade &=
                  !_strat.CheckCondition(STRAT_COND_TRADE_COND, TRADE_COND_HAS_STATE, TRADE_STATE_TRADE_CANNOT);
              TradeSignalEntry _sentry = GetStrategySignalEntry(_strat, _can_trade, _strat.Get<int>(STRAT_PARAM_SHIFT));
              if (_sentry.Get<uint>(STRUCT_ENUM(TradeSignalEntry, TRADE_SIGNAL_PROP_SIGNALS)) > 0) {
                TradeSignal _signal(_sentry);
                if (_signal.GetSignalClose() != _signal.GetSignalOpen()) {
                  tsm.SignalAdd(_signal);  //, _tick.time);
                }
                StgProcessResult _strat_result = _strat.GetProcessResult();
                eresults.last_error = fmax(eresults.last_error, _strat_result.last_error);
                eresults.stg_errored += (int)_strat_result.last_error > ERR_NO_ERROR;
                eresults.stg_processed++;
              }
            }
          }
        }
        if (tsm.GetSignalsActive().Size() > 0 && tsm.IsReady()) {
          // Process all strategies' signals and trigger trading orders.
          ProcessSignals(_tick, eparams.Get<unsigned int>(STRUCT_ENUM(EAParams, EA_PARAM_PROP_SIGNAL_FILTER)));
        }
        if (eresults.last_error > ERR_NO_ERROR) {
          // On error, print logs.
          logger.Flush();
        }
        if (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) >= DATETIME_MINUTE) {
          // Process data, tasks and trades on new periods.
          ProcessTrades();
        }
      }
      estate.last_updated.Update();
      if (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) >= DATETIME_MINUTE) {
        // Process data and tasks on new periods.
        ProcessData();
        ProcessTasks();
      }
    }
    return eresults;
  }

  /**
   * Process data to store.
   */
  void ProcessData() {
    long _timestamp = estate.last_updated.GetEntry().GetTimestamp();
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_CHART)) {
      ChartEntry _entry = Chart().GetEntry();
      data_chart.Add(_entry, _entry.bar.ohlc.time);
    }
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_INDICATOR)) {
      for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
        Strategy *_strati = iter.Value().Ptr();
        IndicatorBase *_indi = _strati.GetIndicator();
        if (_indi != NULL) {
          ENUM_TIMEFRAMES _itf = _indi.GetParams().tf.GetTf();
          IndicatorDataEntry _ientry = _indi.GetEntry();
          if (!data_indi.KeyExists(_itf)) {
            // Create new timeframe buffer if does not exist.
            BufferStruct<IndicatorDataEntry> *_ide = new BufferStruct<IndicatorDataEntry>;
            data_indi.Set(_itf, _ide);
          }
          // Save entry into data_indi.
          data_indi[_itf].Add(_ientry);
        }
      }
    }
    /*
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_STRATEGY)) {
      for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
        Strategy *_strat = iter.Value().Ptr();
        StgEntry _sentry = _strat.GetEntry();
        ENUM_TIMEFRAMES _stf = iter_tf.Key(); // @fixme
        if (!data_stg.KeyExists(_stf)) {
          // Create new timeframe buffer if does not exist.
          BufferStruct<StgEntry> *_se = new BufferStruct<StgEntry>;
          data_stg.Set(_stf, _se);
        }
        // Save data into data_stg.
        data_stg[_stf].Add(_sentry);
      }
    }
    */
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_SYMBOL)) {
      data_symbol.Add(SymbolInfo().GetEntryLast(), _timestamp);
    }
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_TRADE)) {
      // @todo
    }
  }

  /**
   * Checks for new starting periods.
   */
  unsigned int ProcessPeriods() {
    estate.Set<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS), estate.last_updated.GetStartedPeriods());
    OnPeriod();
    return estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS));
  }

  /**
   * Export data.
   */
  void DataExport(unsigned short _methods) {
    long _timestamp = estate.last_updated.GetEntry().GetTimestamp();
    int _serializer_flags = SERIALIZER_FLAG_SKIP_HIDDEN | SERIALIZER_FLAG_INCLUDE_DEFAULT |
                            SERIALIZER_FLAG_INCLUDE_DYNAMIC | SERIALIZER_FLAG_REUSE_STUB | SERIALIZER_FLAG_REUSE_OBJECT;

    if (eparams.CheckFlagDataStore(EA_DATA_STORE_CHART)) {
      string _key_chart = "Chart";
      _key_chart += StringFormat("-%d-%d", data_chart.GetMin(), data_chart.GetMax());

      SerializerConverter _stub = Serializer::MakeStubObject<BufferStruct<ChartEntry>>(_serializer_flags);
      SerializerConverter _obj = SerializerConverter::FromObject(data_chart, _serializer_flags);

      if ((_methods & EA_DATA_EXPORT_CSV) != 0) {
        _obj.ToFile<SerializerCsv>(_key_chart + ".csv", _serializer_flags, &_stub);
      }
      if ((_methods & EA_DATA_EXPORT_DB) != 0) {
        SerializerSqlite::ConvertToFile(_obj, _key_chart + ".sqlite", "chart", _serializer_flags, &_stub);
      }
      if ((_methods & EA_DATA_EXPORT_JSON) != 0) {
        _obj.ToFile<SerializerJson>(_key_chart + ".json", _serializer_flags, &_stub);
      }

      // Required because of SERIALIZER_FLAG_REUSE_STUB flag.
      _stub.Clean();

      // Required because of SERIALIZER_FLAG_REUSE_OBJECT flag.
      _obj.Clean();
    }
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_INDICATOR)) {
      SerializerConverter _stub = Serializer::MakeStubObject<BufferStruct<IndicatorDataEntry>>(_serializer_flags);

      /*
      for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
        ENUM_TIMEFRAMES _itf = iter_tf.Key(); // @fixme
        if (data_indi.KeyExists(_itf)) {
          BufferStruct<IndicatorDataEntry> _indi_buff = data_indi.GetByKey(_itf);

          SerializerConverter _obj = SerializerConverter::FromObject(_indi_buff, _serializer_flags);

          for (DictStructIterator<long, Ref<Strategy>> iter = strats[_itf].Begin(); iter.IsValid(); ++iter) {
            string _key_indi = "Indicator";
            _key_indi += StringFormat("-%d-%d-%d", _itf, _indi_buff.GetMin(), _indi_buff.GetMax());

            if ((_methods & EA_DATA_EXPORT_CSV) != 0) {
              _obj.ToFile<SerializerCsv>(_key_indi + ".csv", _serializer_flags, &_stub);
            }
            if ((_methods & EA_DATA_EXPORT_DB) != 0) {
              SerializerSqlite::ConvertToFile(_obj, _key_indi + ".sqlite", "indicator", _serializer_flags, &_stub);
            }
            if ((_methods & EA_DATA_EXPORT_JSON) != 0) {
              _obj.ToFile<SerializerJson>(_key_indi + ".json", _serializer_flags, &_stub);
            }
          }  // for

          // Required because of SERIALIZER_FLAG_REUSE_OBJECT flag.
          _obj.Clean();
        }  // if
      }
      */

      // Required because of SERIALIZER_FLAG_REUSE_STUB flag.
      _stub.Clean();
    }
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_STRATEGY)) {
      SerializerConverter _stub = Serializer::MakeStubObject<BufferStruct<StgEntry>>(_serializer_flags);

      /* @fixme
      for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
        ENUM_TIMEFRAMES _stf = iter_tf.Key(); // @fixme
        if (data_stg.KeyExists(_stf)) {
          string _key_stg = StringFormat("Strategy-%d", _stf);
          BufferStruct<StgEntry> _stg_buff = data_stg.GetByKey(_stf);
          SerializerConverter _obj = SerializerConverter::FromObject(_stg_buff, _serializer_flags);

          _key_stg += StringFormat("-%d-%d-%d", _stf, _stg_buff.GetMin(), _stg_buff.GetMax());
          if ((_methods & EA_DATA_EXPORT_CSV) != 0) {
            _obj.ToFile<SerializerCsv>(_key_stg + ".csv", _serializer_flags, &_stub);
          }
          if ((_methods & EA_DATA_EXPORT_DB) != 0) {
            SerializerSqlite::ConvertToFile(_obj, _key_stg + ".sqlite", "strategy", _serializer_flags, &_stub);
          }
          if ((_methods & EA_DATA_EXPORT_JSON) != 0) {
            _obj.ToFile<SerializerJson>(_key_stg + ".json", _serializer_flags, &_stub);
          }

          // Required because of SERIALIZER_FLAG_REUSE_OBJECT flag.
          _obj.Clean();
        }
      }
      */
      // Required because of SERIALIZER_FLAG_REUSE_STUB flag.
      _stub.Clean();
    }
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_SYMBOL)) {
      SerializerConverter _stub = Serializer::MakeStubObject<BufferStruct<SymbolInfoEntry>>(_serializer_flags);
      SerializerConverter _obj = SerializerConverter::FromObject(data_symbol, _serializer_flags);

      string _key_sym = "Symbol";
      _key_sym += StringFormat("-%d-%d", data_symbol.GetMin(), data_symbol.GetMax());
      if ((_methods & EA_DATA_EXPORT_CSV) != 0) {
        _obj.ToFile<SerializerCsv>(_key_sym + ".csv", _serializer_flags, &_stub);
      }
      if ((_methods & EA_DATA_EXPORT_DB) != 0) {
        SerializerSqlite::ConvertToFile(_obj, _key_sym + ".sqlite", "symbol", _serializer_flags, &_stub);
      }
      if ((_methods & EA_DATA_EXPORT_JSON) != 0) {
        _obj.ToFile<SerializerJson>(_key_sym + ".json", _serializer_flags, &_stub);
      }

      // Required because of SERIALIZER_FLAG_REUSE_STUB flag.
      _stub.Clean();

      // Required because of SERIALIZER_FLAG_REUSE_OBJECT flag.
      _obj.Clean();
    }
    if (eparams.CheckFlagDataStore(EA_DATA_STORE_TRADE)) {
      string _key_trade = "Trade";
      // _key_sym += StringFormat("-%d-%d", data_trade.GetMin(), data_trade.GetMax());
      if ((_methods & EA_DATA_EXPORT_CSV) != 0) {
        // @todo
        // SerializerConverter _stub_trade =
        // Serializer::MakeStubObject<BufferStruct<TradeEntry>>(SERIALIZER_FLAG_SKIP_HIDDEN);
        // SerializerConverter::FromObject(data_trade, SERIALIZER_FLAG_SKIP_HIDDEN).ToFile<SerializerCsv>(_key + ".csv",
        // SERIALIZER_FLAG_SKIP_HIDDEN, &_stub_trade);
      }
      if ((_methods & EA_DATA_EXPORT_DB) != 0) {
        // @todo: Use Database class.
      }
      if ((_methods & EA_DATA_EXPORT_JSON) != 0) {
        // @todo
        // SerializerConverter _stub_trade =
        // Serializer::MakeStubObject<BufferStruct<TradeEntry>>(SERIALIZER_FLAG_SKIP_HIDDEN);
        // SerializerConverter::FromObject(data_trade, SERIALIZER_FLAG_SKIP_HIDDEN).ToFile<SerializerJson>(_key +
        // ".json", SERIALIZER_FLAG_SKIP_HIDDEN, &_stub_trade);
      }
    }
  }

  /**
   * Export data using default methods.
   */
  void DataExport() { DataExport(eparams.Get<unsigned short>(STRUCT_ENUM(EAParams, EA_PARAM_PROP_DATA_EXPORT))); }

  /* Signal methods */

  /**
   * Returns signal open value after filtering.
   *
   * @return
   *   Returns 1 when buy signal exists, -1 for sell, otherwise 0 for neutral signal.
   */
  /* @fixme: Convert into TradeSignal format.
  float GetSignalOpenFiltered(StrategySignal &_signal, unsigned int _sf) {
    float _result = _signal.GetSignalOpen();
    ENUM_TIMEFRAMES _sig_tf = _signal.Get<ENUM_TIMEFRAMES>(STRUCT_ENUM(StrategySignal, STRATEGY_SIGNAL_PROP_TF));
    if (ChartTf::TfToHours(_sig_tf) < 1 && bool(_sf & STRUCT_ENUM(EAParams, EA_PARAM_SIGNAL_FILTER_OPEN_M_IF_H))) {
      _result = 0;
      long _tfts[4];
      _tfts[0] = ChartStatic::iTime(_Symbol, PERIOD_H1);
      _tfts[1] = ChartStatic::iTime(_Symbol, PERIOD_H4);
      _tfts[2] = ChartStatic::iTime(_Symbol, PERIOD_H1, 1);
      _tfts[3] = ChartStatic::iTime(_Symbol, PERIOD_H4, 1);
      for (int i = 0; i < ArraySize(_tfts); i++) {
        DictStruct<short, StrategySignal> _ds = strat_signals.GetByKey(_tfts[i]);
        for (DictStructIterator<short, StrategySignal> _dsi = _ds.Begin(); _dsi.IsValid(); ++_dsi) {
          StrategySignal _dsss = _dsi.Value();
          ENUM_TIMEFRAMES _dsss_tf = _dsss.Get<ENUM_TIMEFRAMES>(STRUCT_ENUM(StrategySignal, STRATEGY_SIGNAL_PROP_TF));
          if (ChartTf::TfToHours(_dsss_tf) >= 1) {
            _result = _dsss.GetSignalOpen();
            if (_result != 0) {
              return _result;
            }
          }
        }
      }
    }
    return _result;
  }
  */

  /* Tasks */

  /**
   * Add task.
   */
  bool TaskAdd(TaskEntry &_entry) {
    bool _result = false;
    if (_entry.IsValid()) {
      switch (_entry.GetConditionType()) {
        case COND_TYPE_ACCOUNT:
          _entry.SetConditionObject(account);
          break;
        case COND_TYPE_EA:
          _entry.SetConditionObject(THIS_PTR);
          break;
        case COND_TYPE_TRADE:
          _entry.SetConditionObject(trade.GetByKey(_Symbol));
          break;
      }
      switch (_entry.GetActionType()) {
        case ACTION_TYPE_EA:
          _entry.SetActionObject(THIS_PTR);
          break;
        case ACTION_TYPE_TRADE:
          _entry.SetActionObject(trade.GetByKey(_Symbol));
          break;
      }
      _result |= tasks.Push(_entry);
    }
    return _result;
  }

  /**
   * Process EA tasks.
   */
  unsigned int ProcessTasks() {
    unsigned int _counter = 0;
    for (DictStructIterator<int, TaskEntry> iter = tasks.Begin(); iter.IsValid(); ++iter) {
      bool _is_processed = false;
      TaskEntry _entry = iter.Value();
      _is_processed = _is_processed || Task::Process(_entry);
      // _entry.last_process = TimeCurrent();
      _counter += (unsigned short)_is_processed;
    }
    return _counter;
  }

  /* Strategy methods */

  /**
   * Adds strategy to specific timeframe.
   *
   * @param
   *   _tf - timeframe to add the strategy.
   *   _magic_no - unique order identified
   *
   * @return
   *   Returns true if the strategy has been initialized correctly, otherwise false.
   */
  template <typename SClass>
  bool StrategyAdd(ENUM_TIMEFRAMES _tf, long _magic_no = 0, int _type = 0) {
    bool _result = true;
    _magic_no = _magic_no > 0 ? _magic_no : rand();
    Ref<Strategy> _strat = ((SClass *)NULL).Init(_tf);
    _strat.Ptr().Set<long>(STRAT_PARAM_ID, _magic_no);
    _strat.Ptr().Set<ENUM_TIMEFRAMES>(STRAT_PARAM_TF, _tf);
    _strat.Ptr().Set<int>(STRAT_PARAM_TYPE, _type);
    _strat.Ptr().OnInit();
    if (!strats.KeyExists(_magic_no)) {
      _result &= strats.Set(_magic_no, _strat);
    } else {
      logger.Error("Strategy adding conflict!", __FUNCTION_LINE__);
      DebugBreak();
    }
    OnStrategyAdd(_strat.Ptr());
    return _result;
  }

  /**
   * Adds strategy to multiple timeframes.
   *
   * @param
   *   _tfs - timeframes to add strategy (using bitwise operation).
   *   _sid - strategy ID
   *   _init_magic - initial order identified
   *
   * Note:
   *   Final magic number is going to be increased by timeframe index value.
   *
   * @see: ENUM_TIMEFRAMES_INDEX
   *
   * @return
   *   Returns true if all strategies has been initialized correctly, otherwise false.
   */
  template <typename SClass>
  bool StrategyAdd(unsigned int _tfs, long _init_magic = 0, int _type = 0) {
    bool _result = true;
    for (int _tfi = 0; _tfi < sizeof(int) * 8; ++_tfi) {
      if ((_tfs & (1 << _tfi)) != 0) {
        _result &= StrategyAdd<SClass>(ChartTf::IndexToTf((ENUM_TIMEFRAMES_INDEX)_tfi), _init_magic + _tfi, _type);
      }
    }
    return _result;
  }

  /**
   * Loads existing trades for the given strategy.
   */
  bool StrategyLoadTrades(Strategy *_strat) {
    Trade *_trade = trade.GetByKey(_Symbol);
    return _trade.OrdersLoadByMagic(_strat.Get<long>(STRAT_PARAM_ID));
  }

  /* Trade methods */

  /**
   * Process open trades.
   *
   * @return
   *   Returns true on success, otherwise false.
   */
  bool ProcessTrades() {
    bool _result = true;
    ResetLastError();
    for (DictObjectIterator<string, Trade> titer = trade.Begin(); titer.IsValid(); ++titer) {
      Trade *_trade = titer.Value();
      if (_trade.Get<bool>(TRADE_STATE_ORDERS_ACTIVE)) {
        for (DictStructIterator<long, Ref<Order>> oiter = _trade.GetOrdersActive().Begin(); oiter.IsValid(); ++oiter) {
          bool _sl_valid = false, _tp_valid = false;
          double _sl_new = 0, _tp_new = 0;
          Order *_order = oiter.Value().Ptr();
          if (!_order.ShouldUpdate()) {
            continue;
          }
          _order.ProcessConditions();
          if (_order.IsClosed()) {
            _trade.OrderMoveToHistory(_order);
            continue;
          }
          ENUM_ORDER_TYPE _otype = _order.Get<ENUM_ORDER_TYPE>(ORDER_TYPE);
          Strategy *_strat = strats.GetByKey(_order.Get<ulong>(ORDER_MAGIC)).Ptr();
          Strategy *_strat_sl = _strat.GetStratSl();
          Strategy *_strat_tp = _strat.GetStratTp();
          if (_strat_sl != NULL || _strat_tp != NULL) {
            float _olots = _order.Get<float>(ORDER_VOLUME_CURRENT);
            float _trisk = _trade.Get<float>(TRADE_PARAM_RISK_MARGIN);
            if (_strat_sl != NULL) {
              float _psl = _strat_sl.Get<float>(STRAT_PARAM_PSL);
              float _sl_max = _trade.GetMaxSLTP(_otype, _olots, ORDER_TYPE_SL, _trisk);
              int _psm = _strat_sl.Get<int>(STRAT_PARAM_PSM);
              _sl_new = _strat_sl.PriceStop(_otype, ORDER_TYPE_SL, _psm, _psl);
              _sl_new = _trade.GetSaferSLTP(_sl_new, _sl_max, _otype, ORDER_TYPE_SL);
              _sl_new = _trade.NormalizeSL(_sl_new, _otype);
              _sl_valid = _trade.IsValidOrderSL(_sl_new, _otype, _order.Get<double>(ORDER_SL), _psm > 0);
              _sl_new = _sl_valid ? _sl_new : _order.Get<double>(ORDER_SL);
            }
            if (_strat_tp != NULL) {
              float _ppl = _strat_tp.Get<float>(STRAT_PARAM_PPL);
              float _tp_max = _trade.GetMaxSLTP(_otype, _olots, ORDER_TYPE_TP, _trisk);
              int _ppm = _strat_tp.Get<int>(STRAT_PARAM_PPM);
              _tp_new = _strat_tp.PriceStop(_otype, ORDER_TYPE_TP, _ppm, _ppl);
              _tp_new = _trade.GetSaferSLTP(_tp_new, _tp_max, _otype, ORDER_TYPE_TP);
              _tp_new = _trade.NormalizeTP(_tp_new, _otype);
              _tp_valid = _trade.IsValidOrderTP(_tp_new, _otype, _order.Get<double>(ORDER_TP), _ppm > 0);
              _tp_new = _tp_valid ? _tp_new : _order.Get<double>(ORDER_TP);
            }
          }
          if (_sl_valid || _tp_valid) {
            _result &= _order.OrderModify(_sl_new, _tp_new);
            if (_result) {
              _order.Set(ORDER_PROP_TIME_LAST_UPDATE, TimeCurrent());
            }
          }
        }
      }
    }
    return _result && _LastError == ERR_NO_ERROR;
  }

  /* Update methods */

  /**
   * Update EA state flags.
   */
  void UpdateStateFlags() {
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_CONNECTED), GetTerminal().IsConnected());
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_LIBS_ALLOWED), GetTerminal().IsLibrariesAllowed());
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_OPTIMIZATION), GetTerminal().IsOptimization());
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_TESTING), GetTerminal().IsTesting());
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_TRADE_ALLOWED), GetTerminal().IsTradeAllowed());
    estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_VISUAL_MODE), GetTerminal().IsVisualMode());
  }

  /**
   * Updates info on chart.
   */
  bool UpdateInfoOnChart() {
    bool _result = false;
    if (eparams.Get<int>(STRUCT_ENUM(EAParams, EA_PARAM_PROP_CHART_INFO_FREQ)) > 0) {
      static datetime _last_update = 0;
      if (_last_update + eparams.Get<int>(STRUCT_ENUM(EAParams, EA_PARAM_PROP_CHART_INFO_FREQ)) < TimeCurrent()) {
        _last_update = TimeCurrent();
        // @todo
        _result = true;
      }
    }
    return _result;
  }

  /**
   * Updates strategy lot size.
   */
  bool UpdateLotSize() {
    bool _result = false;
    if (eparams.CheckFlag(EA_PARAM_FLAG_LOTSIZE_AUTO)) {
      // Auto calculate lot size for all strategies.
      Trade *_trade = trade.GetByKey(_Symbol);
      _result &= _trade.ExecuteAction(TRADE_ACTION_CALC_LOT_SIZE);
      Set(STRAT_PARAM_LS, _trade.Get<float>(TRADE_PARAM_LOT_SIZE));
    }
    return _result;
  }

  /* Conditions and actions */

  /**
   * Checks for EA condition.
   *
   * @param ENUM_EA_CONDITION _cond
   *   EA condition.
   * @return
   *   Returns true when the condition is met.
   */
  bool CheckCondition(ENUM_EA_CONDITION _cond, DataParamEntry &_args[]) {
    bool _result = false;
    switch (_cond) {
      case EA_COND_IS_ACTIVE:
        return estate.IsActive();
      case EA_COND_IS_ENABLED:
        return estate.IsEnabled();
      case EA_COND_IS_NOT_CONNECTED:
        estate.Set(STRUCT_ENUM(EAState, EA_STATE_FLAG_CONNECTED), GetTerminal().IsConnected());
        return !estate.IsConnected();
      case EA_COND_ON_NEW_MINUTE:  // On new minute.
        return (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_MINUTE) != 0;
      case EA_COND_ON_NEW_HOUR:  // On new hour.
        return (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_HOUR) != 0;
      case EA_COND_ON_NEW_DAY:  // On new day.
        return (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_DAY) != 0;
      case EA_COND_ON_NEW_WEEK:  // On new week.
        return (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_WEEK) != 0;
      case EA_COND_ON_NEW_MONTH:  // On new month.
        return (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_MONTH) != 0;
      case EA_COND_ON_NEW_YEAR:  // On new year.
        return (estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_YEAR) != 0;
      case EA_COND_ON_INIT:
        return estate.IsOnInit();
      case EA_COND_ON_QUIT:
        return estate.IsOnQuit();
      default:
        logger.Error(StringFormat("Invalid EA condition: %s!", EnumToString(_cond), __FUNCTION_LINE__));
        break;
    }
    return _result;
  }
  bool CheckCondition(ENUM_EA_CONDITION _cond) {
    ARRAY(DataParamEntry, _args);
    return EA::CheckCondition(_cond, _args);
  }

  /**
   * Execute EA action.
   *
   * @param ENUM_EA_ACTION _action
   *   EA action to execute.
   * @return
   *   Returns true when the action has been executed successfully.
   */
  bool ExecuteAction(ENUM_EA_ACTION _action, DataParamEntry &_args[]) {
    bool _result = false;
    long arg_size = ArraySize(_args);
    switch (_action) {
      case EA_ACTION_DISABLE:
        estate.Enable(false);
        return true;
      case EA_ACTION_ENABLE:
        estate.Enable();
        return true;
      case EA_ACTION_EXPORT_DATA:
        DataExport();
        return true;
      case EA_ACTION_STRATS_EXE_ACTION:
        // Args:
        // 1st (i:0) - Strategy's enum action to execute.
        // 2nd (i:1) - Strategy's argument to pass.
        for (DictStructIterator<long, Ref<Strategy>> iter_strat = strats.Begin(); iter_strat.IsValid(); ++iter_strat) {
          DataParamEntry _sargs[];
          ArrayResize(_sargs, ArraySize(_args) - 1);
          for (int i = 0; i < ArraySize(_sargs); i++) {
            _sargs[i] = _args[i + 1];
          }
          Strategy *_strat = iter_strat.Value().Ptr();
          _result &= _strat.ExecuteAction((ENUM_STRATEGY_ACTION)_args[0].integer_value, _sargs);
        }
        return _result;
      case EA_ACTION_TASKS_CLEAN:
        // @todo
        return tasks.Size() == 0;
      default:
        logger.Error(StringFormat("Invalid EA action: %s!", EnumToString(_action), __FUNCTION_LINE__));
        return false;
    }
    return _result;
  }
  bool ExecuteAction(ENUM_EA_ACTION _action) {
    ARRAY(DataParamEntry, _args);
    return EA::ExecuteAction(_action, _args);
  }
  bool ExecuteAction(ENUM_EA_ACTION _action, long _arg1) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    ArrayPushObject(_args, _param1);
    return EA::ExecuteAction(_action, _args);
  }
  bool ExecuteAction(ENUM_EA_ACTION _action, long _arg1, long _arg2) {
    ARRAY(DataParamEntry, _args);
    DataParamEntry _param1 = _arg1;
    DataParamEntry _param2 = _arg2;
    ArrayPushObject(_args, _param1);
    ArrayPushObject(_args, _param2);
    return EA::ExecuteAction(_action, _args);
  }

  /* Getters */

  /**
   * Gets strategy based on the property value.
   *
   * @return
   *   Returns first found strategy instance on success.
   *   Otherwise, it returns NULL.
   */
  template <typename T>
  Strategy *GetStrategyViaProp(ENUM_STRATEGY_PARAM _prop, T _value, ENUM_MATH_CONDITION _op = MATH_COND_EQ) {
    for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
      Strategy *_strat = iter.Value().Ptr();
      if (Math::Compare(_strat.Get<T>(_prop), _value, _op)) {
        return _strat;
      }
    }
    return NULL;
  }

  /**
   * Gets strategy based on the two property values.
   *
   * @return
   *   Returns first found strategy instance on success.
   *   Otherwise, it returns NULL.
   */
  template <typename T1, typename T2>
  Strategy *GetStrategyViaProp2(ENUM_STRATEGY_PARAM _prop1, T1 _value1, ENUM_STRATEGY_PARAM _prop2, T2 _value2,
                                ENUM_MATH_CONDITION _op = MATH_COND_EQ) {
    for (DictStructIterator<long, Ref<Strategy>> iter = strats.Begin(); iter.IsValid(); ++iter) {
      Strategy *_strat = iter.Value().Ptr();
      if (Math::Compare(_strat.Get<T1>(_prop1), _value1, _op) && Math::Compare(_strat.Get<T2>(_prop2), _value2, _op)) {
        return _strat;
      }
    }
    return NULL;
  }

  /**
   * Returns pointer to Market object.
   */
  Terminal *GetTerminal() { return GetPointer(terminal); }

  /**
   * Gets EA's name.
   */
  EAParams GetParams() const { return eparams; }

  /**
   * Gets DictStruct reference to strategies.
   */
  DictStruct<long, Ref<Strategy>> *GetStrategies() { return GetPointer(strats); }

  /**
   * Gets EA state.
   */
  EAState GetState() { return estate; }

  /* Class getters */

  /**
   * Gets pointer to account details.
   */
  Account *Account() { return account; }

  /**
   * Gets pointer to log instance.
   */
  Log *GetLogger() { return GetPointer(logger); }

  /**
   * Gets reference to strategies.
   */
  DictStruct<long, Ref<Strategy>> *Strategies() { return &strats; }

  /* Setters */

  /* Virtual methods */

  /**
   * Executed when new time is started (like each minute).
   */
  virtual void OnPeriod() {
    if ((estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_MINUTE) != 0) {
      // New minute started.
#ifndef __optimize__
      if (Terminal::IsRealtime()) {
        logger.Flush();
      }
#endif
    }
    if ((estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_HOUR) != 0) {
      // New hour started.
      tsm.Refresh();
    }
    if ((estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_DAY) != 0) {
      // New day started.
      UpdateLotSize();
#ifndef __optimize__
      logger.Flush();
#endif
    }
    if ((estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_WEEK) != 0) {
      // New week started.
    }
    if ((estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_MONTH) != 0) {
      // New month started.
    }
    if ((estate.Get<uint>(STRUCT_ENUM(EAState, EA_STATE_PROP_NEW_PERIODS)) & DATETIME_YEAR) != 0) {
      // New year started.
    }
  }

  /**
   * Executed on strategy being added.
   *
   * @param _strat Strategy instance.
   * @see StrategyAdd()
   *
   */
  virtual void OnStrategyAdd(Strategy *_strat) {
    // Sets margin risk.
    float _margin_risk = eparams.Get<float>(STRUCT_ENUM(EAParams, EA_PARAM_PROP_RISK_MARGIN_MAX));
    _strat.Set<float>(TRADE_PARAM_RISK_MARGIN, _margin_risk);
    // Link a logger instance.
    logger.Link(_strat.GetLogger());
    // Load existing strategy trades.
    StrategyLoadTrades(_strat);
  }

  /* Printer methods */

  /**
   * Returns EA data in textual representation.
   */
  string ToString(string _dlm = "; ") {
    string _output = "";
    _output += eparams.ToString() + _dlm;
    //_output += StringFormat("Strategies: %d", strats.Size());
    return _output;
  }

  /* Serializers */

  /**
   * Returns serialized representation of the object instance.
   */
  SerializerNodeType Serialize(Serializer &_s) {
    _s.Pass(THIS_REF, "account", account, SERIALIZER_FIELD_FLAG_DYNAMIC);

    for (DictStructIterator<long, Ref<Strategy>> _iter = GetStrategies().Begin(); _iter.IsValid(); ++_iter) {
      Strategy *_strat = _iter.Value().Ptr();
      // @fixme: GH-422
      // _s.PassWriteOnly(this, "strat:" + _strat.GetName(), _strat);
      string _sname = _strat.GetName();  // + "@" + Chart::TfToString(_strat.GetTf()); // @todo
      string _sparams = _strat.GetParams().ToString();
      string _sresults = _strat.GetProcessResult().ToString();
      _s.Pass(THIS_REF, "strat:params:" + _sname, _sparams);
      _s.Pass(THIS_REF, "strat:results:" + _sname, _sresults);
    }
    _s.PassObject(THIS_REF, "trade", trade);
    _s.PassObject(THIS_REF, "tsm", tsm);
    return SerializerNodeObject;
  }
};
#endif  // EA_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: EA.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: define.h
////////////////////////////////////////////////////////////
/**
 * @file
 * Defines conditional compilation directives.
 *
 * Uncomment a line to activate the feature.
 */

#ifdef __MQL4__
#define STG_AC_INDI_FILE "\\Indicators\\Accelerator.ex4"
#else
#define STG_AC_INDI_FILE "\\Indicators\\Examples\\Accelerator.ex5"
#endif

//#define __config__  // Loads params from the config files.
//#define __debug__        // Enables debugging.
#define __input__  // Enables input parameters.
//#define __optimize__     // Enables optimization mode.
//#define __resource__  // Enables resources.

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: define.h
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Stg_MA_Cross_Timeframe.mqh
////////////////////////////////////////////////////////////
/**
 * @file
 * Implements MA Cross Timeframe strategy.
 */

enum ENUM_STG_MA_CROSS_TIMEFRAME_TYPE {
  STG_MA_CROSS_TIMEFRAME_TYPE_0_NONE = 0,     // (None)
  STG_MA_CROSS_TIMEFRAME_TYPE_AMA,            // AMA: Adaptive Moving Average
  STG_MA_CROSS_TIMEFRAME_TYPE_DEMA,           // DEMA: Double Exponential Moving Average
  STG_MA_CROSS_TIMEFRAME_TYPE_FRAMA,          // FrAMA: Fractal Adaptive Moving Average
  STG_MA_CROSS_TIMEFRAME_TYPE_ICHIMOKU,       // Ichimoku
  STG_MA_CROSS_TIMEFRAME_TYPE_MA,             // MA: Moving Average
  STG_MA_CROSS_TIMEFRAME_TYPE_PRICE_CHANNEL,  // Price Channel
  STG_MA_CROSS_TIMEFRAME_TYPE_SAR,            // SAR: Parabolic Stop and Reverse
  STG_MA_CROSS_TIMEFRAME_TYPE_TEMA,           // TEMA: Triple Exponential Moving Average
  STG_MA_CROSS_TIMEFRAME_TYPE_VIDYA,          // VIDYA: Variable Index Dynamic Average
};

// User params.
INPUT_GROUP("MA Cross Timeframe strategy: main strategy params");
INPUT ENUM_STG_MA_CROSS_TIMEFRAME_TYPE MA_Cross_Timeframe_Type = STG_MA_CROSS_TIMEFRAME_TYPE_MA;  // Indicator MA type
INPUT ENUM_TIMEFRAMES MA_Cross_Timeframe_Timeframe = PERIOD_H6;  // MA timeframe to cross
INPUT_GROUP("MA Cross Timeframe strategy: strategy params");
INPUT float MA_Cross_Timeframe_LotSize = 0;                // Lot size
INPUT int MA_Cross_Timeframe_SignalOpenMethod = 0;         // Signal open method (-127-127)
INPUT float MA_Cross_Timeframe_SignalOpenLevel = 0.0f;     // Signal open level
INPUT int MA_Cross_Timeframe_SignalOpenFilterMethod = 32;  // Signal open filter method
INPUT int MA_Cross_Timeframe_SignalOpenFilterTime = 3;     // Signal open filter time
INPUT int MA_Cross_Timeframe_SignalOpenBoostMethod = 0;    // Signal open boost method
INPUT int MA_Cross_Timeframe_SignalCloseMethod = 0;        // Signal close method (-127-127)
INPUT int MA_Cross_Timeframe_SignalCloseFilter = 0;        // Signal close filter (-127-127)
INPUT float MA_Cross_Timeframe_SignalCloseLevel = 0.0f;    // Signal close level
INPUT int MA_Cross_Timeframe_PriceStopMethod = 1;          // Price stop method (0-127)
INPUT float MA_Cross_Timeframe_PriceStopLevel = 2;         // Price stop level
INPUT int MA_Cross_Timeframe_TickFilterMethod = 32;        // Tick filter method
INPUT float MA_Cross_Timeframe_MaxSpread = 4.0;            // Max spread to trade (pips)
INPUT short MA_Cross_Timeframe_Shift = 0;                  // Shift
INPUT float MA_Cross_Timeframe_OrderCloseLoss = 80;        // Order close loss
INPUT float MA_Cross_Timeframe_OrderCloseProfit = 80;      // Order close profit
INPUT int MA_Cross_Timeframe_OrderCloseTime = -30;         // Order close time in mins (>0) or bars (<0)
INPUT_GROUP("MA Cross Timeframe strategy: AMA indicator params");
INPUT int MA_Cross_Timeframe_Indi_AMA_InpPeriodAMA = 20;                              // AMA period
INPUT int MA_Cross_Timeframe_Indi_AMA_InpFastPeriodEMA = 4;                           // Fast EMA period
INPUT int MA_Cross_Timeframe_Indi_AMA_InpSlowPeriodEMA = 30;                          // Slow EMA period
INPUT int MA_Cross_Timeframe_Indi_AMA_InpShiftAMA = 4;                                // AMA shift
INPUT int MA_Cross_Timeframe_Indi_AMA_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_AMA_SourceType = IDATA_BUILTIN;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: DEMA indicator params");
INPUT int MA_Cross_Timeframe_Indi_DEMA_Period = 25;                                    // Period
INPUT int MA_Cross_Timeframe_Indi_DEMA_MA_Shift = 6;                                   // MA Shift
INPUT ENUM_APPLIED_PRICE MA_Cross_Timeframe_Indi_DEMA_Applied_Price = PRICE_TYPICAL;   // Applied Price
INPUT int MA_Cross_Timeframe_Indi_DEMA_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_DEMA_SourceType = IDATA_BUILTIN;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: FrAMA indicator params");
INPUT int MA_Cross_Timeframe_Indi_FrAMA_Period = 10;                                    // Period
INPUT ENUM_APPLIED_PRICE MA_Cross_Timeframe_Indi_FrAMA_Applied_Price = PRICE_MEDIAN;    // Applied Price
INPUT int MA_Cross_Timeframe_Indi_FrAMA_MA_Shift = 0;                                   // MA Shift
INPUT int MA_Cross_Timeframe_Indi_FrAMA_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_FrAMA_SourceType = IDATA_BUILTIN;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: Ichimoku indicator params");
// INPUT ENUM_ICHIMOKU_LINE MA_Cross_Timeframe_Indi_Ichimoku_MA_Line = LINE_TENKANSEN; // Ichimoku line for MA
INPUT int MA_Cross_Timeframe_Indi_Ichimoku_Period_Tenkan_Sen = 30;                         // Period Tenkan Sen
INPUT int MA_Cross_Timeframe_Indi_Ichimoku_Period_Kijun_Sen = 10;                          // Period Kijun Sen
INPUT int MA_Cross_Timeframe_Indi_Ichimoku_Period_Senkou_Span_B = 30;                      // Period Senkou Span B
INPUT int MA_Cross_Timeframe_Indi_Ichimoku_Shift = 1;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_Ichimoku_SourceType = IDATA_BUILTIN;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: MA indicator params");
INPUT int MA_Cross_Timeframe_Indi_MA_Period = 26;                                    // Period
INPUT int MA_Cross_Timeframe_Indi_MA_MA_Shift = 0;                                   // MA Shift
INPUT ENUM_MA_METHOD MA_Cross_Timeframe_Indi_MA_Method = MODE_LWMA;                  // MA Method
INPUT ENUM_APPLIED_PRICE MA_Cross_Timeframe_Indi_MA_Applied_Price = PRICE_WEIGHTED;  // Applied Price
INPUT int MA_Cross_Timeframe_Indi_MA_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_MA_SourceType = IDATA_BUILTIN;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: Price Channel indicator params");
INPUT int MA_Cross_Timeframe_Indi_PriceChannel_Period = 26;                                    // Period
INPUT int MA_Cross_Timeframe_Indi_PriceChannel_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_PriceChannel_SourceType = IDATA_ICUSTOM;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: SAR indicator params");
INPUT float MA_Cross_Timeframe_Indi_SAR_Step = 0.04f;                                 // Step
INPUT float MA_Cross_Timeframe_Indi_SAR_Maximum_Stop = 0.4f;                          // Maximum stop
INPUT int MA_Cross_Timeframe_Indi_SAR_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_SAR_SourceType = IDATA_ICUSTOM;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: TEMA indicator params");
INPUT int MA_Cross_Timeframe_Indi_TEMA_Period = 10;                                    // Period
INPUT int MA_Cross_Timeframe_Indi_TEMA_MA_Shift = 0;                                   // MA Shift
INPUT ENUM_APPLIED_PRICE MA_Cross_Timeframe_Indi_TEMA_Applied_Price = PRICE_WEIGHTED;  // Applied Price
INPUT int MA_Cross_Timeframe_Indi_TEMA_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_TEMA_SourceType = IDATA_BUILTIN;  // Source type
INPUT_GROUP("MA Cross Timeframe strategy: VIDYA indicator params");
INPUT int MA_Cross_Timeframe_Indi_VIDYA_Period = 30;                                    // Period
INPUT int MA_Cross_Timeframe_Indi_VIDYA_MA_Period = 20;                                 // MA Period
INPUT int MA_Cross_Timeframe_Indi_VIDYA_MA_Shift = 1;                                   // MA Shift
INPUT ENUM_APPLIED_PRICE MA_Cross_Timeframe_Indi_VIDYA_Applied_Price = PRICE_WEIGHTED;  // Applied Price
INPUT int MA_Cross_Timeframe_Indi_VIDYA_Shift = 0;                                      // Shift
INPUT ENUM_IDATA_SOURCE_TYPE MA_Cross_Timeframe_Indi_VIDYA_SourceType = IDATA_BUILTIN;  // Source type

// Structs.

// Defines struct with default user strategy values.
struct Stg_MA_Cross_Timeframe_Params_Defaults : StgParams {
  Stg_MA_Cross_Timeframe_Params_Defaults()
      : StgParams(::MA_Cross_Timeframe_SignalOpenMethod, ::MA_Cross_Timeframe_SignalOpenFilterMethod,
                  ::MA_Cross_Timeframe_SignalOpenLevel, ::MA_Cross_Timeframe_SignalOpenBoostMethod,
                  ::MA_Cross_Timeframe_SignalCloseMethod, ::MA_Cross_Timeframe_SignalCloseFilter,
                  ::MA_Cross_Timeframe_SignalCloseLevel, ::MA_Cross_Timeframe_PriceStopMethod,
                  ::MA_Cross_Timeframe_PriceStopLevel, ::MA_Cross_Timeframe_TickFilterMethod,
                  ::MA_Cross_Timeframe_MaxSpread, ::MA_Cross_Timeframe_Shift) {
    Set(STRAT_PARAM_LS, MA_Cross_Timeframe_LotSize);
    Set(STRAT_PARAM_OCL, MA_Cross_Timeframe_OrderCloseLoss);
    Set(STRAT_PARAM_OCP, MA_Cross_Timeframe_OrderCloseProfit);
    Set(STRAT_PARAM_OCT, MA_Cross_Timeframe_OrderCloseTime);
    Set(STRAT_PARAM_SOFT, MA_Cross_Timeframe_SignalOpenFilterTime);
  }
};

class Stg_MA_Cross_Timeframe : public Strategy {
 protected:
  Stg_MA_Cross_Timeframe_Params_Defaults ssparams;

 public:
  Stg_MA_Cross_Timeframe(StgParams &_sparams, TradeParams &_tparams, ChartParams &_cparams, string _name = "")
      : Strategy(_sparams, _tparams, _cparams, _name) {}

  static Stg_MA_Cross_Timeframe *Init(ENUM_TIMEFRAMES _tf = NULL, EA *_ea = NULL) {
    // Initialize strategy initial values.
    Stg_MA_Cross_Timeframe_Params_Defaults stg_ma_cross_timeframe_defaults;
    StgParams _stg_params(stg_ma_cross_timeframe_defaults);
    // Initialize Strategy instance.
    ChartParams _cparams(_tf, _Symbol);
    TradeParams _tparams;
    Strategy *_strat = new Stg_MA_Cross_Timeframe(_stg_params, _tparams, _cparams, "MA Cross Timeframe");
    return _strat;
  }

  /**
   * Event on strategy's init.
   */
  void OnInit() {
    // Initialize indicators.
    switch (MA_Cross_Timeframe_Type) {
      case STG_MA_CROSS_TIMEFRAME_TYPE_AMA:  // AMA
      {
        IndiAMAParams _indi_params(
            ::MA_Cross_Timeframe_Indi_AMA_InpPeriodAMA, ::MA_Cross_Timeframe_Indi_AMA_InpFastPeriodEMA,
            ::MA_Cross_Timeframe_Indi_AMA_InpSlowPeriodEMA, ::MA_Cross_Timeframe_Indi_AMA_InpShiftAMA, PRICE_TYPICAL,
            ::MA_Cross_Timeframe_Indi_AMA_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_AMA_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_AMA(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_AMA(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_DEMA:  // DEMA
      {
        IndiDEIndiMAParams _indi_params(::MA_Cross_Timeframe_Indi_DEMA_Period, ::MA_Cross_Timeframe_Indi_DEMA_MA_Shift,
                                        ::MA_Cross_Timeframe_Indi_DEMA_Applied_Price,
                                        ::MA_Cross_Timeframe_Indi_DEMA_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_DEMA_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_DEMA(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_DEMA(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_FRAMA:  // FrAMA
      {
        IndiFrAIndiMAParams _indi_params(
            ::MA_Cross_Timeframe_Indi_FrAMA_Period, ::MA_Cross_Timeframe_Indi_FrAMA_MA_Shift,
            ::MA_Cross_Timeframe_Indi_FrAMA_Applied_Price, ::MA_Cross_Timeframe_Indi_FrAMA_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_FrAMA_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_FrAMA(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_FrAMA(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_ICHIMOKU:  // Ichimoku
      {
        IndiIchimokuParams _indi_params(
            ::MA_Cross_Timeframe_Indi_Ichimoku_Period_Tenkan_Sen, ::MA_Cross_Timeframe_Indi_Ichimoku_Period_Kijun_Sen,
            ::MA_Cross_Timeframe_Indi_Ichimoku_Period_Senkou_Span_B, ::MA_Cross_Timeframe_Indi_Ichimoku_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_Ichimoku_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_Ichimoku(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_Ichimoku(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_MA:  // MA
      {
        IndiMAParams _indi_params(::MA_Cross_Timeframe_Indi_MA_Period, ::MA_Cross_Timeframe_Indi_MA_MA_Shift,
                                  ::MA_Cross_Timeframe_Indi_MA_Method, ::MA_Cross_Timeframe_Indi_MA_Applied_Price,
                                  ::MA_Cross_Timeframe_Indi_MA_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_MA_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_MA(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_MA(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_PRICE_CHANNEL:  // Price Channel
      {
        IndiPriceChannelParams _indi_params(::MA_Cross_Timeframe_Indi_PriceChannel_Period,
                                            ::MA_Cross_Timeframe_Indi_PriceChannel_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_PriceChannel_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_PriceChannel(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_PriceChannel(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_SAR:  // SAR
      {
        IndiSARParams _indi_params(::MA_Cross_Timeframe_Indi_SAR_Step, ::MA_Cross_Timeframe_Indi_SAR_Maximum_Stop,
                                   ::MA_Cross_Timeframe_Indi_SAR_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_SAR_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_SAR(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_SAR(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_TEMA:  // TEMA
      {
        IndiTEMAParams _indi_params(::MA_Cross_Timeframe_Indi_TEMA_Period, ::MA_Cross_Timeframe_Indi_TEMA_MA_Shift,
                                    ::MA_Cross_Timeframe_Indi_TEMA_Applied_Price, ::MA_Cross_Timeframe_Indi_TEMA_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_TEMA_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_TEMA(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_TEMA(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_VIDYA:  // VIDYA
      {
        IndiVIDYAParams _indi_params(::MA_Cross_Timeframe_Indi_VIDYA_Period, ::MA_Cross_Timeframe_Indi_VIDYA_MA_Period,
                                     ::MA_Cross_Timeframe_Indi_VIDYA_MA_Shift,
                                     ::MA_Cross_Timeframe_Indi_VIDYA_Applied_Price,
                                     ::MA_Cross_Timeframe_Indi_VIDYA_Shift);
        _indi_params.SetDataSourceType(::MA_Cross_Timeframe_Indi_VIDYA_SourceType);
        _indi_params.SetTf(Get<ENUM_TIMEFRAMES>(STRAT_PARAM_TF));
        SetIndicator(new Indi_VIDYA(_indi_params), ::MA_Cross_Timeframe_Type);
        _indi_params.SetTf(::MA_Cross_Timeframe_Timeframe);
        SetIndicator(new Indi_VIDYA(_indi_params), ::MA_Cross_Timeframe_Type + 1);
        break;
      }
      case STG_MA_CROSS_TIMEFRAME_TYPE_0_NONE:  // (None)
      default:
        break;
    }
  }

  /**
   * Check strategy's opening signal.
   */
  bool SignalOpen(ENUM_ORDER_TYPE _cmd, int _method = 0, float _level = 0.0f, int _shift = 0) {
    IndicatorBase *_indi1 = GetIndicator(::MA_Cross_Timeframe_Type);
    IndicatorBase *_indi2 = GetIndicator(::MA_Cross_Timeframe_Type + 1);
    // uint _ishift = _indi1.GetParams().GetShift(); // @todo: Convert into Get().
    // uint _ishift = _indi2.GetParams().GetShift(); // @todo: Convert into Get().
    // bool _result = _indi.GetFlag(INDI_ENTRY_FLAG_IS_VALID, _shift); // @fixme
    bool _result = true;
    uint _ishift = _shift;
    if (!_result) {
      // Returns false when indicator data is not valid.
      return false;
    }
    // float _level_pips = (float)(_level * _chart.GetPipSize());
    double _value1 = _indi1[_shift][0];
    double _value2 = _indi2[_shift][0];
    switch (_cmd) {
      case ORDER_TYPE_BUY:
        // Buy signal.
        _result &= _indi1.IsIncreasing(1, 0, _shift);
        _result &= _indi1[_ishift][0] > _indi2[_ishift][0];
        _result &= _indi1[_ishift + 1][0] < _indi2[_ishift + 1][0];
        //_result &= Math::ChangeInPct(_indi1[_ishift + 1][0], _indi1[_ishift][0], true) > _level;
        if (_result && _method != 0) {
          if (METHOD(_method, 0)) _result &= _indi1[_ishift][0] < _indi1[_ishift + 3][0];
          if (METHOD(_method, 1)) _result &= _indi2[_ishift][0] < _indi2[_ishift + 3][0];
          if (METHOD(_method, 2))
            _result &= fmax4(_indi1[_ishift][0], _indi1[_ishift + 1][0], _indi1[_ishift + 2][0],
                             _indi1[_ishift + 3][0]) == _indi1[_ishift][0];
          if (METHOD(_method, 3))
            _result &= fmax4(_indi2[_ishift][0], _indi2[_ishift + 1][0], _indi2[_ishift + 2][0],
                             _indi2[_ishift + 3][0]) == _indi2[_ishift][0];
        }
        break;
      case ORDER_TYPE_SELL:
        // Sell signal.
        _result &= _indi1.IsDecreasing(1, 0, _ishift);
        _result &= _indi1[_ishift][0] < _indi2[_ishift][0];
        _result &= _indi1[_ishift + 1][0] > _indi2[_ishift + 1][0];
        //_result &= Math::ChangeInPct(_indi1[_ishift + 1][0], _indi1[_ishift][0], true) < _level;
        if (_result && _method != 0) {
          if (METHOD(_method, 0)) _result &= _indi1[_ishift][0] > _indi1[_ishift + 3][0];
          if (METHOD(_method, 1)) _result &= _indi2[_ishift][0] > _indi2[_ishift + 3][0];
          if (METHOD(_method, 2))
            _result &= fmin4(_indi1[_ishift][0], _indi1[_ishift + 1][0], _indi1[_ishift + 2][0],
                             _indi1[_ishift + 3][0]) == _indi1[_ishift][0];
          if (METHOD(_method, 3))
            _result &= fmin4(_indi2[_ishift][0], _indi2[_ishift + 1][0], _indi2[_ishift + 2][0],
                             _indi2[_ishift + 3][0]) == _indi2[_ishift][0];
        }
        break;
    }
    return _result;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Stg_MA_Cross_Timeframe.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_SAR.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.


#ifndef __MQL4__
// Defines global functions (for MQL4 backward compability).
double iSAR(string _symbol, int _tf, double _step, double _max, int _shift) {
  ResetLastError();
  return Indi_SAR::iSAR(_symbol, (ENUM_TIMEFRAMES)_tf, _step, _max, _shift);
}
#endif

// Structs.
struct IndiSARParams : IndicatorParams {
  double step;
  double max;
  // Struct constructors.
  IndiSARParams(double _step = 0.02, double _max = 0.2, int _shift = 0)
      : step(_step), max(_max), IndicatorParams(INDI_SAR, 1, TYPE_DOUBLE) {
    shift = _shift;
    SetDataValueRange(IDATA_RANGE_PRICE);  // @fixit It draws single dot for each bar!
    SetCustomIndicatorName("Examples\\ParabolicSAR");
  };
  IndiSARParams(IndiSARParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Parabolic Stop and Reverse system indicator.
 */
class Indi_SAR : public Indicator<IndiSARParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_SAR(IndiSARParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiSARParams>(_p, _indi_src) {}
  Indi_SAR(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_SAR, _tf, _shift) {}

  /**
   * Returns the indicator value.
   *
   * @docs
   * - https://docs.mql4.com/indicators/isar
   * - https://www.mql5.com/en/docs/indicators/isar
   */
  static double iSAR(string _symbol = NULL, ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, double _step = 0.02,
                     double _max = 0.2, int _shift = 0, IndicatorBase *_obj = NULL) {
#ifdef __MQL4__
    return ::iSAR(_symbol, _tf, _step, _max, _shift);
#else  // __MQL5__
    int _handle = Object::IsValid(_obj) ? _obj.Get<int>(IndicatorState::INDICATOR_STATE_PROP_HANDLE) : NULL;
    double _res[];
    if (_handle == NULL || _handle == INVALID_HANDLE) {
      if ((_handle = ::iSAR(_symbol, _tf, _step, _max)) == INVALID_HANDLE) {
        SetUserError(ERR_USER_INVALID_HANDLE);
        return EMPTY_VALUE;
      } else if (Object::IsValid(_obj)) {
        _obj.SetHandle(_handle);
      }
    }
    if (Terminal::IsVisualMode()) {
      // To avoid error 4806 (ERR_INDICATOR_DATA_NOT_FOUND),
      // we check the number of calculated data only in visual mode.
      int _bars_calc = BarsCalculated(_handle);
      if (GetLastError() > 0) {
        return EMPTY_VALUE;
      } else if (_bars_calc <= 2) {
        SetUserError(ERR_USER_INVALID_BUFF_NUM);
        return EMPTY_VALUE;
      }
    }
    if (CopyBuffer(_handle, 0, _shift, 1, _res) < 0) {
      return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;
    }
    return _res[0];
#endif
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_SAR::iSAR(GetSymbol(), GetTf(), GetStep(), GetMax(), _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/ GetStep(),
                         GetMax() /*]*/, _mode, _ishift);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /* Getters */

  /**
   * Get step of price increment.
   */
  double GetStep() { return iparams.step; }

  /**
   * Get the maximum step.
   */
  double GetMax() { return iparams.max; }

  /* Setters */

  /**
   * Set step of price increment (usually 0.02).
   */
  void SetStep(double _step) {
    istate.is_changed = true;
    iparams.step = _step;
  }

  /**
   * Set the maximum step (usually 0.2).
   */
  void SetMax(double _max) {
    istate.is_changed = true;
    iparams.max = _max;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_SAR.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_Ichimoku.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.


#ifndef __MQL4__
// Defines global functions (for MQL4 backward compability).
double iIchimoku(string _symbol, int _tf, int _ts, int _ks, int _ssb, int _mode, int _shift) {
  ResetLastError();
  return Indi_Ichimoku::iIchimoku(_symbol, (ENUM_TIMEFRAMES)_tf, _ts, _ks, _ssb, _mode, _shift);
}
#endif

#ifndef __MQLBUILD__
// Indicator constants.
// @docs
// - https://www.mql5.com/en/docs/constants/indicatorconstants/lines
// Identifiers of indicator lines permissible when copying values of iIchimoku().
#define TENKANSEN_LINE 0    // Tenkan-sen line.
#define KIJUNSEN_LINE 1     // Kijun-sen line.
#define SENKOUSPANA_LINE 2  // Senkou Span A line.
#define SENKOUSPANB_LINE 3  // Senkou Span B line.
#define CHIKOUSPAN_LINE 4   // Chikou Span line.
#endif

// Enums.
// Ichimoku Kinko Hyo identifiers used in Ichimoku indicator.
enum ENUM_ICHIMOKU_LINE {
#ifdef __MQL4__
  LINE_TENKANSEN = MODE_TENKANSEN,      // Tenkan-sen line.
  LINE_KIJUNSEN = MODE_KIJUNSEN,        // Kijun-sen line.
  LINE_SENKOUSPANA = MODE_SENKOUSPANA,  // Senkou Span A line.
  LINE_SENKOUSPANB = MODE_SENKOUSPANB,  // Senkou Span B line.
  LINE_CHIKOUSPAN = MODE_CHIKOUSPAN,    // Chikou Span line.
#else
  LINE_TENKANSEN = TENKANSEN_LINE,      // Tenkan-sen line.
  LINE_KIJUNSEN = KIJUNSEN_LINE,        // Kijun-sen line.
  LINE_SENKOUSPANA = SENKOUSPANA_LINE,  // Senkou Span A line.
  LINE_SENKOUSPANB = SENKOUSPANB_LINE,  // Senkou Span B line.
  LINE_CHIKOUSPAN = CHIKOUSPAN_LINE,    // Chikou Span line.
#endif
  FINAL_ICHIMOKU_LINE_ENTRY,
};

// Structs.
struct IndiIchimokuParams : IndicatorParams {
  unsigned int tenkan_sen;
  unsigned int kijun_sen;
  unsigned int senkou_span_b;
  // Struct constructors.
  IndiIchimokuParams(unsigned int _ts = 9, unsigned int _ks = 26, unsigned int _ss_b = 52, int _shift = 0)
      : tenkan_sen(_ts),
        kijun_sen(_ks),
        senkou_span_b(_ss_b),
        IndicatorParams(INDI_ICHIMOKU, FINAL_ICHIMOKU_LINE_ENTRY, TYPE_DOUBLE) {
    shift = _shift;
    SetDataValueRange(IDATA_RANGE_PRICE);  // @fixit Not sure if not mixed.
    SetCustomIndicatorName("Examples\\Ichimoku");
  };
  IndiIchimokuParams(IndiIchimokuParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Ichimoku Kinko Hyo indicator.
 */
class Indi_Ichimoku : public Indicator<IndiIchimokuParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_Ichimoku(IndiIchimokuParams &_p, IndicatorBase *_indi_src = NULL)
      : Indicator<IndiIchimokuParams>(_p, _indi_src) {}
  Indi_Ichimoku(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_ICHIMOKU, _tf, _shift) {}

  /**
   * Returns the indicator value.
   *
   * @param
   * _mode int
   * - MT4: 1 - MODE_TENKANSEN, 2 - MODE_KIJUNSEN, 3 - MODE_SENKOUSPANA, 4 - MODE_SENKOUSPANB, 5 - MODE_CHIKOUSPAN
   * - MT5: 0 - TENKANSEN_LINE, 1 - KIJUNSEN_LINE, 2 - SENKOUSPANA_LINE, 3 - SENKOUSPANB_LINE, 4 - CHIKOUSPAN_LINE
   * @docs
   * - https://docs.mql4.com/indicators/iichimoku
   * - https://www.mql5.com/en/docs/indicators/iichimoku
   */
  static double iIchimoku(string _symbol, ENUM_TIMEFRAMES _tf, int _tenkan_sen, int _kijun_sen, int _senkou_span_b,
                          int _mode, int _shift = 0, IndicatorBase *_obj = NULL) {
#ifdef __MQL4__
    return ::iIchimoku(_symbol, _tf, _tenkan_sen, _kijun_sen, _senkou_span_b, _mode, _shift);
#else  // __MQL5__
    int _handle = Object::IsValid(_obj) ? _obj.Get<int>(IndicatorState::INDICATOR_STATE_PROP_HANDLE) : NULL;
    double _res[];
    if (_handle == NULL || _handle == INVALID_HANDLE) {
      if ((_handle = ::iIchimoku(_symbol, _tf, _tenkan_sen, _kijun_sen, _senkou_span_b)) == INVALID_HANDLE) {
        SetUserError(ERR_USER_INVALID_HANDLE);
        return EMPTY_VALUE;
      } else if (Object::IsValid(_obj)) {
        _obj.SetHandle(_handle);
      }
    }
    if (Terminal::IsVisualMode()) {
      // To avoid error 4806 (ERR_INDICATOR_DATA_NOT_FOUND),
      // we check the number of calculated data only in visual mode.
      int _bars_calc = BarsCalculated(_handle);
      if (GetLastError() > 0) {
        return EMPTY_VALUE;
      } else if (_bars_calc <= 2) {
        SetUserError(ERR_USER_INVALID_BUFF_NUM);
        return EMPTY_VALUE;
      }
    }
    if (CopyBuffer(_handle, _mode, _shift, 1, _res) < 0) {
      return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;
    }
    return _res[0];
#endif
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_Ichimoku::iIchimoku(GetSymbol(), GetTf(), GetTenkanSen(), GetKijunSen(), GetSenkouSpanB(), _mode,
                                          _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/ GetTenkanSen(),
                         GetKijunSen(), GetSenkouSpanB() /*]*/, _mode, _ishift);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /**
   * Alters indicator's struct value.
   */
  virtual void GetEntryAlter(IndicatorDataEntry &_entry, int _shift = -1) {
    Indicator<IndiIchimokuParams>::GetEntryAlter(_entry);
#ifdef __MQL4__
    // In MQL4 value of LINE_TENKANSEN is 1 (not 0 as in MQL5),
    // so we are duplicating it.
    _entry.values[0] = GetEntryValue(LINE_TENKANSEN, _shift);
#endif
    _entry.values[(int)LINE_CHIKOUSPAN] = GetEntryValue(LINE_CHIKOUSPAN, _shift + 26);
  }

  /**
   * Checks if indicator entry values are valid.
   */
  virtual bool IsValidEntry(IndicatorDataEntry &_entry) {
    return Indicator<IndiIchimokuParams>::IsValidEntry(_entry) && _entry.IsGt<double>(0);
  }

  /* Getters */

  /**
   * Get period of Tenkan-sen line.
   */
  unsigned int GetTenkanSen() { return iparams.tenkan_sen; }

  /**
   * Get period of Kijun-sen line.
   */
  unsigned int GetKijunSen() { return iparams.kijun_sen; }

  /**
   * Get period of Senkou Span B line.
   */
  unsigned int GetSenkouSpanB() { return iparams.senkou_span_b; }

  /* Setters */

  /**
   * Set period of Tenkan-sen line.
   */
  void SetTenkanSen(unsigned int _tenkan_sen) {
    istate.is_changed = true;
    iparams.tenkan_sen = _tenkan_sen;
  }

  /**
   * Set period of Kijun-sen line.
   */
  void SetKijunSen(unsigned int _kijun_sen) {
    istate.is_changed = true;
    iparams.kijun_sen = _kijun_sen;
  }

  /**
   * Set period of Senkou Span B line.
   */
  void SetSenkouSpanB(unsigned int _senkou_span_b) {
    istate.is_changed = true;
    iparams.senkou_span_b = _senkou_span_b;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_Ichimoku.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_PriceChannel.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_ZigZag.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.all.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.



// Enums.
// Indicator mode identifiers used in ZigZag indicator.
enum ENUM_ZIGZAG_LINE { ZIGZAG_BUFFER = 0, ZIGZAG_HIGHMAP = 1, ZIGZAG_LOWMAP = 2, FINAL_ZIGZAG_LINE_ENTRY };

// Structs.
struct IndiZigZagParams : IndicatorParams {
  unsigned int depth;
  unsigned int deviation;
  unsigned int backstep;
  // Struct constructors.
  IndiZigZagParams(unsigned int _depth = 12, unsigned int _deviation = 5, unsigned int _backstep = 3, int _shift = 0)
      : depth(_depth),
        deviation(_deviation),
        backstep(_backstep),
        IndicatorParams(INDI_ZIGZAG, FINAL_ZIGZAG_LINE_ENTRY, TYPE_DOUBLE) {
    shift = _shift;
    SetCustomIndicatorName("Examples\\ZigZag");
    SetDataValueRange(IDATA_RANGE_PRICE);  // @fixit Draws lines between lowest and highest prices!
  };
  IndiZigZagParams(IndiZigZagParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

enum EnSearchMode {
  Extremum = 0,  // searching for the first extremum
  Peak = 1,      // searching for the next ZigZag peak
  Bottom = -1    // searching for the next ZigZag bottom
};

/**
 * Implements ZigZag indicator.
 */
class Indi_ZigZag : public Indicator<IndiZigZagParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_ZigZag(IndiZigZagParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiZigZagParams>(_p, _indi_src) {}
  Indi_ZigZag(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_ZIGZAG, _tf, _shift) {}

  /**
   * Returns value for ZigZag indicator.
   */
  static double iCustomZigZag(string _symbol, ENUM_TIMEFRAMES _tf, string _name, int _depth, int _deviation,
                              int _backstep, ENUM_ZIGZAG_LINE _mode = 0, int _shift = 0, IndicatorBase *_obj = NULL) {
#ifdef __MQL5__
    int _handle = Object::IsValid(_obj) ? _obj.Get<int>(IndicatorState::INDICATOR_STATE_PROP_HANDLE) : NULL;
    double _res[];
    if (_handle == NULL || _handle == INVALID_HANDLE) {
      if ((_handle = ::iCustom(_symbol, _tf, _name, _depth, _deviation, _backstep)) == INVALID_HANDLE) {
        SetUserError(ERR_USER_INVALID_HANDLE);
        return EMPTY_VALUE;
      } else if (Object::IsValid(_obj)) {
        _obj.SetHandle(_handle);
      }
    }
    if (Terminal::IsVisualMode()) {
      // To avoid error 4806 (ERR_INDICATOR_DATA_NOT_FOUND),
      // we check the number of calculated data only in visual mode.
      int _bars_calc = BarsCalculated(_handle);
      if (GetLastError() > 0) {
        return EMPTY_VALUE;
      } else if (_bars_calc <= 2) {
        SetUserError(ERR_USER_INVALID_BUFF_NUM);
        return EMPTY_VALUE;
      }
    }
    if (CopyBuffer(_handle, _mode, _shift, 1, _res) < 0) {
      return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;
    }
    return _res[0];
#else
    return ::iCustom(_symbol, _tf, _name, _depth, _deviation, _backstep, _mode, _shift);
#endif
  }

  /**
   * Returns value for ZigZag indicator.
   */
  static double iZigZag(string _symbol, ENUM_TIMEFRAMES _tf, int _depth, int _deviation, int _backstep,
                        ENUM_ZIGZAG_LINE _mode = 0, int _shift = 0, Indi_ZigZag *_obj = NULL) {
    INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_LONG(_symbol, _tf,
                                                       Util::MakeKey("Indi_ZigZag", _depth, _deviation, _backstep));
    return iZigZagOnArray(INDICATOR_CALCULATE_POPULATED_PARAMS_LONG, _depth, _deviation, _backstep, _mode, _shift,
                          _cache);
  }

  /**
   * Calculates ZigZag on the array of values.
   */
  static double iZigZagOnArray(INDICATOR_CALCULATE_PARAMS_LONG, int _depth, int _deviation, int _backstep, int _mode,
                               int _shift, IndicatorCalculateCache<double> *_cache, bool _recalculate = false) {
    _cache.SetPriceBuffer(_open, _high, _low, _close);

    if (!_cache.HasBuffers()) {
      _cache.AddBuffer<NativeValueStorage<double>>(1 + 2);
    }

    if (_recalculate) {
      _cache.ResetPrevCalculated();
    }

    _cache.SetPrevCalculated(Indi_ZigZag::Calculate(INDICATOR_CALCULATE_GET_PARAMS_LONG, _cache.GetBuffer<double>(0),
                                                    _cache.GetBuffer<double>(1), _cache.GetBuffer<double>(2), _depth,
                                                    _deviation, _backstep));

    return _cache.GetTailValue<double>(_mode, _shift);
  }

  /**
   * OnCalculate() method for ZigZag indicator.
   */
  static int Calculate(INDICATOR_CALCULATE_METHOD_PARAMS_LONG, ValueStorage<double> &ZigZagBuffer,
                       ValueStorage<double> &HighMapBuffer, ValueStorage<double> &LowMapBuffer, int InpDepth,
                       int InpDeviation, int InpBackstep) {
    int ExtRecalc = 3;

    if (rates_total < 100) return (0);
    //---
    int i = 0;
    int start = 0, extreme_counter = 0, extreme_search = Extremum;
    int shift = 0, back = 0, last_high_pos = 0, last_low_pos = 0;
    double val = 0, res = 0;
    double curlow = 0, curhigh = 0, last_high = 0, last_low = 0;
    // Initializing.
    if (prev_calculated == 0) {
      ArrayInitialize(ZigZagBuffer, 0.0);
      ArrayInitialize(HighMapBuffer, 0.0);
      ArrayInitialize(LowMapBuffer, 0.0);
      start = InpDepth;
    }

    // ZigZag was already calculated before.
    if (prev_calculated > 0) {
      i = rates_total - 1;
      // Searching for the third extremum from the last uncompleted bar.
      while (extreme_counter < ExtRecalc && i > rates_total - 100) {
        res = ZigZagBuffer[i].Get();
        if (res != 0.0) extreme_counter++;
        i--;
      }
      i++;
      start = i;

      // What type of extremum we search for.
      if (LowMapBuffer[i] != 0.0) {
        curlow = LowMapBuffer[i].Get();
        extreme_search = Peak;
      } else {
        curhigh = HighMapBuffer[i].Get();
        extreme_search = Bottom;
      }
      // Clear indicator values.
      for (i = start + 1; i < rates_total && !IsStopped(); i++) {
        ZigZagBuffer[i] = 0.0;
        LowMapBuffer[i] = 0.0;
        HighMapBuffer[i] = 0.0;
      }
    }

    // Searching for high and low extremes.
    for (shift = start; shift < rates_total && !IsStopped(); shift++) {
      // Low.
      val = low[Lowest(low, InpDepth, shift)].Get();
      if (val == last_low) {
        val = 0.0;
      } else {
        last_low = val;
        if ((low[shift] - val) > InpDeviation * _Point) {
          val = 0.0;
        } else {
          for (back = 1; back <= InpBackstep; back++) {
            res = LowMapBuffer[shift - back].Get();
            if ((res != 0) && (res > val)) LowMapBuffer[shift - back] = 0.0;
          }
        }
      }
      LowMapBuffer[shift] = (low[shift] == val) ? val : 0.0;
      // High.
      val = high[Highest(high, InpDepth, shift)].Get();
      if (val == last_high) {
        val = 0.0;
      } else {
        last_high = val;
        if ((val - high[shift].Get()) > InpDeviation * _Point) {
          val = 0.0;
        } else {
          for (back = 1; back <= InpBackstep; back++) {
            res = HighMapBuffer[shift - back].Get();
            if ((res != 0) && (res < val)) HighMapBuffer[shift - back] = 0.0;
          }
        }
      }
      HighMapBuffer[shift] = (high[shift] == val) ? val : 0.0;
    }

    // Set last values.
    if (extreme_search == 0) {
      // Undefined values.
      last_low = 0.0;
      last_high = 0.0;
    } else {
      last_low = curlow;
      last_high = curhigh;
    }

    // Final selection of extreme points for ZigZag.
    for (shift = start; shift < rates_total && !IsStopped(); shift++) {
      res = 0.0;
      switch (extreme_search) {
        case Extremum:
          if (last_low == 0.0 && last_high == 0.0) {
            if (HighMapBuffer[shift] != 0) {
              last_high = high[shift].Get();
              last_high_pos = shift;
              extreme_search = Bottom;
              ZigZagBuffer[shift] = last_high;
              res = 1;
            }
            if (LowMapBuffer[shift] != 0.0) {
              last_low = low[shift].Get();
              last_low_pos = shift;
              extreme_search = Peak;
              ZigZagBuffer[shift] = last_low;
              res = 1;
            }
          }
          break;
        case Peak:
          if (LowMapBuffer[shift] != 0.0 && LowMapBuffer[shift] < last_low && HighMapBuffer[shift] == 0.0) {
            ZigZagBuffer[last_low_pos] = 0.0;
            last_low_pos = shift;
            last_low = LowMapBuffer[shift].Get();
            ZigZagBuffer[shift] = last_low;
            res = 1;
          }
          if (HighMapBuffer[shift] != 0.0 && LowMapBuffer[shift] == 0.0) {
            last_high = HighMapBuffer[shift].Get();
            last_high_pos = shift;
            ZigZagBuffer[shift] = last_high;
            extreme_search = Bottom;
            res = 1;
          }
          break;
        case Bottom:
          if (HighMapBuffer[shift] != 0.0 && HighMapBuffer[shift] > last_high && LowMapBuffer[shift] == 0.0) {
            ZigZagBuffer[last_high_pos] = 0.0;
            last_high_pos = shift;
            last_high = HighMapBuffer[shift].Get();
            ZigZagBuffer[shift] = last_high;
          }
          if (LowMapBuffer[shift] != 0.0 && HighMapBuffer[shift] == 0.0) {
            last_low = LowMapBuffer[shift].Get();
            last_low_pos = shift;
            ZigZagBuffer[shift] = last_low;
            extreme_search = Peak;
          }
          break;
        default:
          return (rates_total);
      }
    }

    // Return value of prev_calculated for next call.
    return (rates_total);
  }

  /**
   * Search for the index of the highest bar.
   */
  static int Highest(ValueStorage<double> &array, const int depth, const int start) {
    if (start < 0) return (0);

    double max = array[start].Get();
    int index = start;
    // Start searching.
    for (int i = start - 1; i > start - depth && i >= 0; i--) {
      if (array[i] > max) {
        index = i;
        max = array[i].Get();
      }
    }
    // Return index of the highest bar.
    return index;
  }

  /**
   * Search for the index of the lowest bar.
   */
  static int Lowest(ValueStorage<double> &array, const int depth, const int start) {
    if (start < 0) return (0);

    double min = array[start].Get();
    int index = start;
    // Start searching.
    for (int i = start - 1; i > start - depth && i >= 0; i--) {
      if (array[i] < min) {
        index = i;
        min = array[i].Get();
      }
    }
    // Return index of the lowest bar.
    return index;
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_ZigZag::iZigZag(GetSymbol(), GetTf(), GetDepth(), GetDeviation(), GetBackstep(),
                                      (ENUM_ZIGZAG_LINE)_mode, _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = Indi_ZigZag::iCustomZigZag(GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), GetDepth(),
                                            GetDeviation(), GetBackstep(), (ENUM_ZIGZAG_LINE)_mode, _ishift, THIS_PTR);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /**
   * Checks if indicator entry values are valid.
   */
  virtual bool IsValidEntry(IndicatorDataEntry &_entry) { return !_entry.HasValue<double>(EMPTY_VALUE); }

  /* Getters */

  /**
   * Get depth.
   */
  unsigned int GetDepth() { return iparams.depth; }

  /**
   * Get deviation.
   */
  unsigned int GetDeviation() { return iparams.deviation; }

  /**
   * Get backstep.
   */
  unsigned int GetBackstep() { return iparams.backstep; }

  /* Setters */

  /**
   * Set depth.
   */
  void SetDepth(unsigned int _depth) {
    istate.is_changed = true;
    iparams.depth = _depth;
  }

  /**
   * Set deviation.
   */
  void SetDeviation(unsigned int _deviation) {
    istate.is_changed = true;
    iparams.deviation = _deviation;
  }

  /**
   * Set backstep.
   */
  void SetBackstep(unsigned int _backstep) {
    istate.is_changed = true;
    iparams.backstep = _backstep;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_ZigZag.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../BufferStruct.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.




// Structs.
struct IndiPriceChannelParams : IndicatorParams {
  unsigned int period;
  // Struct constructor.
  IndiPriceChannelParams(unsigned int _period = 22, int _shift = 0)
      : IndicatorParams(INDI_PRICE_CHANNEL, 3, TYPE_DOUBLE) {
    period = _period;
    SetDataValueRange(IDATA_RANGE_MIXED);
    SetCustomIndicatorName("Examples\\Price_Channel");
    shift = _shift;
  };
  IndiPriceChannelParams(IndiPriceChannelParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Bill Williams' Accelerator/Decelerator oscillator.
 */
class Indi_PriceChannel : public Indicator<IndiPriceChannelParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_PriceChannel(IndiPriceChannelParams &_p, IndicatorBase *_indi_src = NULL)
      : Indicator<IndiPriceChannelParams>(_p, _indi_src){};
  Indi_PriceChannel(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0)
      : Indicator(INDI_PRICE_CHANNEL, _tf, _shift){};

  /**
   * Returns value for Price Channel indicator.
   */
  static double iPriceChannel(string _symbol, ENUM_TIMEFRAMES _tf, int _period, int _mode = 0, int _shift = 0,
                              IndicatorBase *_obj = NULL) {
    INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_LONG(_symbol, _tf, Util::MakeKey("Indi_PriceChannel", _period));
    return iPriceChannelOnArray(INDICATOR_CALCULATE_POPULATED_PARAMS_LONG, _period, _mode, _shift, _cache);
  }

  /**
   * Calculates Price Channel on the array of values.
   */
  static double iPriceChannelOnArray(INDICATOR_CALCULATE_PARAMS_LONG, int _period, int _mode, int _shift,
                                     IndicatorCalculateCache<double> *_cache, bool _recalculate = false) {
    _cache.SetPriceBuffer(_open, _high, _low, _close);

    if (!_cache.HasBuffers()) {
      _cache.AddBuffer<NativeValueStorage<double>>(3);
    }

    if (_recalculate) {
      _cache.ResetPrevCalculated();
    }

    _cache.SetPrevCalculated(Indi_PriceChannel::Calculate(INDICATOR_CALCULATE_GET_PARAMS_LONG,
                                                          _cache.GetBuffer<double>(0), _cache.GetBuffer<double>(1),
                                                          _cache.GetBuffer<double>(2), _period));

    return _cache.GetTailValue<double>(_mode, _shift);
  }

  /**
   * OnCalculate() method for Price Channel indicator.
   */
  static int Calculate(INDICATOR_CALCULATE_METHOD_PARAMS_LONG, ValueStorage<double> &ExtHighBuffer,
                       ValueStorage<double> &ExtLowBuffer, ValueStorage<double> &ExtMiddBuffer, int InpChannelPeriod) {
    if (rates_total < InpChannelPeriod) return (0);

    int start = prev_calculated == 0 ? InpChannelPeriod : prev_calculated - 1;
    for (int i = start; i < rates_total && !IsStopped(); i++) {
      ExtHighBuffer[i] = Indi_ZigZag::Highest(high, InpChannelPeriod, i);
      ExtLowBuffer[i] = Indi_ZigZag::Lowest(low, InpChannelPeriod, i);
      ExtMiddBuffer[i] = (ExtHighBuffer[i] + ExtLowBuffer[i]) / 2.0;
    }
    // Returns new prev_calculated.
    return rates_total;
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_PriceChannel::iPriceChannel(GetSymbol(), GetTf(), GetPeriod(), _mode, _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/ GetPeriod() /*]*/,
                         0, _ishift);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /* Getters */

  /**
   * Get period.
   */
  unsigned int GetPeriod() { return iparams.period; }

  /* Setters */

  /**
   * Set period.
   */
  void SetPeriod(unsigned int _period) {
    istate.is_changed = true;
    iparams.period = _period;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_PriceChannel.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_VIDYA.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.price.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../BufferStruct.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.




// Structs.
struct IndiVIDYAParams : IndicatorParams {
  unsigned int cmo_period;
  unsigned int ma_period;
  unsigned int vidya_shift;
  ENUM_APPLIED_PRICE applied_price;

  // Struct constructor.
  IndiVIDYAParams(unsigned int _cmo_period = 9, unsigned int _ma_period = 14, unsigned int _vidya_shift = 0,
                  ENUM_APPLIED_PRICE _ap = PRICE_CLOSE, int _shift = 0)
      : IndicatorParams(INDI_VIDYA, 1, TYPE_DOUBLE) {
    applied_price = _ap;
    cmo_period = _cmo_period;
    ma_period = _ma_period;
    SetDataValueRange(IDATA_RANGE_MIXED);
    SetCustomIndicatorName("Examples\\VIDYA");
    shift = _shift;
    vidya_shift = _vidya_shift;
  };
  IndiVIDYAParams(IndiVIDYAParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Variable Index Dynamic Average indicator.
 */
class Indi_VIDYA : public Indicator<IndiVIDYAParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_VIDYA(IndiVIDYAParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiVIDYAParams>(_p, _indi_src){};
  Indi_VIDYA(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_VIDYA, _tf, _shift){};

  /**
   * Built-in version of iVIDyA.
   */
  static double iVIDyA(string _symbol, ENUM_TIMEFRAMES _tf, int _cmo_period, int _ema_period, int _ma_shift,
                       ENUM_APPLIED_PRICE _ap, int _mode = 0, int _shift = 0, IndicatorBase *_obj = NULL) {
#ifdef __MQL5__
    INDICATOR_BUILTIN_CALL_AND_RETURN(::iVIDyA(_symbol, _tf, _cmo_period, _ema_period, _ma_shift, _ap), _mode, _shift);
#else
    INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_SHORT(
        _symbol, _tf, _ap, Util::MakeKey("Indi_VIDYA", _cmo_period, _ema_period, _ma_shift, (int)_ap));
    return iVIDyAOnArray(INDICATOR_CALCULATE_POPULATED_PARAMS_SHORT, _cmo_period, _ema_period, _ma_shift, _mode, _shift,
                         _cache);
#endif
  }

  /**
   * Calculates iVIDyA on the array of values.
   */
  static double iVIDyAOnArray(INDICATOR_CALCULATE_PARAMS_SHORT, int _cmo_period, int _ema_period, int _ma_shift,
                              int _mode, int _shift, IndicatorCalculateCache<double> *_cache,
                              bool _recalculate = false) {
    _cache.SetPriceBuffer(_price);

    if (!_cache.HasBuffers()) {
      _cache.AddBuffer<NativeValueStorage<double>>(1);
    }

    if (_recalculate) {
      _cache.ResetPrevCalculated();
    }

    _cache.SetPrevCalculated(Indi_VIDYA::Calculate(INDICATOR_CALCULATE_GET_PARAMS_SHORT, _cache.GetBuffer<double>(0),
                                                   _cmo_period, _ema_period, _ma_shift));

    return _cache.GetTailValue<double>(_mode, _shift);
  }

  /**
   * OnCalculate() method for VIDyA indicator.
   *
   * Note that InpShift is used for drawing only and thus is unused.
   */
  static int Calculate(INDICATOR_CALCULATE_METHOD_PARAMS_SHORT, ValueStorage<double> &VIDYA_Buffer, int InpPeriodCMO,
                       int InpPeriodEMA, int InpShift) {
    double ExtF = 2.0 / (1.0 + InpPeriodEMA);

    if (rates_total < InpPeriodEMA + InpPeriodCMO - 1) return (0);
    //---
    int i, start;
    if (prev_calculated < InpPeriodEMA + InpPeriodCMO - 1) {
      start = InpPeriodEMA + InpPeriodCMO - 1;
      for (i = 0; i < start; i++) VIDYA_Buffer[i] = price[i];
    } else
      start = prev_calculated - 1;
    // Main cycle.
    for (i = start; i < rates_total && !IsStopped(); i++) {
      double mul_CMO = MathAbs(CalculateCMO(i, InpPeriodCMO, price));
      // Calculate VIDYA.
      VIDYA_Buffer[i] = price[i] * ExtF * mul_CMO + VIDYA_Buffer[i - 1] * (1 - ExtF * mul_CMO);
    }
    // OnCalculate done. Return new prev_calculated.
    return (rates_total);
  }

  /**
   * Chande Momentum Oscillator.
   */
  static double CalculateCMO(int pos, const int period, ValueStorage<double> &price) {
    double res = 0.0;
    double sum_up = 0.0, sum_down = 0.0;
    if (pos >= period && pos < ArraySize(price)) {
      for (int i = 0; i < period; i++) {
        double diff = price[pos - i] - price[pos - i - 1];
        if (diff > 0.0)
          sum_up += diff;
        else
          sum_down += (-diff);
      }
      if (sum_up + sum_down != 0.0) res = (sum_up - sum_down) / (sum_up + sum_down);
    }
    return (res);
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_VIDYA::iVIDyA(GetSymbol(), GetTf(), /*[*/ GetCMOPeriod(), GetMAPeriod(), GetVIDYAShift(),
                                    GetAppliedPrice() /*]*/, 0, _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/
                         GetCMOPeriod(), GetMAPeriod(),
                         GetVIDYAShift()
                         /*]*/,
                         0, _ishift);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /* Getters */

  /**
   * Get CMO period.
   */
  unsigned int GetCMOPeriod() { return iparams.cmo_period; }

  /**
   * Get MA period.
   */
  unsigned int GetMAPeriod() { return iparams.ma_period; }

  /**
   * Get VIDYA shift.
   */
  unsigned int GetVIDYAShift() { return iparams.vidya_shift; }

  /**
   * Get applied price.
   */
  ENUM_APPLIED_PRICE GetAppliedPrice() { return iparams.applied_price; }

  /* Setters */

  /**
   * Set CMO period.
   */
  void SetCMOPeriod(unsigned int _cmo_period) {
    istate.is_changed = true;
    iparams.cmo_period = _cmo_period;
  }

  /**
   * Set MA period.
   */
  void SetMAPeriod(unsigned int _ma_period) {
    istate.is_changed = true;
    iparams.ma_period = _ma_period;
  }

  /**
   * Set VIDYA shift.
   */
  void SetVIDYAShift(unsigned int _vidya_shift) {
    istate.is_changed = true;
    iparams.vidya_shift = _vidya_shift;
  }

  /**
   * Set applied price.
   */
  void SetAppliedPrice(ENUM_APPLIED_PRICE _applied_price) {
    istate.is_changed = true;
    iparams.applied_price = _applied_price;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_VIDYA.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Strategy.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_FractalAdaptiveMA.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../BufferStruct.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.all.h
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.




// Structs.
struct IndiFrAIndiMAParams : IndicatorParams {
  unsigned int frama_shift;
  unsigned int period;
  ENUM_APPLIED_PRICE applied_price;

  // Struct constructor.
  IndiFrAIndiMAParams(int _period = 14, int _frama_shift = 0, ENUM_APPLIED_PRICE _ap = PRICE_CLOSE, int _shift = 0)
      : IndicatorParams(INDI_FRAMA, 1, TYPE_DOUBLE) {
    frama_shift = _frama_shift;
    SetDataValueRange(IDATA_RANGE_MIXED);
    SetCustomIndicatorName("Examples\\FrAMA");
    applied_price = _ap;
    period = _period;
    shift = _shift;
  };
  IndiFrAIndiMAParams(IndiFrAIndiMAParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Bill Williams' Accelerator/Decelerator oscillator.
 */
class Indi_FrAMA : public Indicator<IndiFrAIndiMAParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_FrAMA(IndiFrAIndiMAParams &_p, IndicatorBase *_indi_src = NULL)
      : Indicator<IndiFrAIndiMAParams>(_p, _indi_src){};
  Indi_FrAMA(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_FRAMA, _tf, _shift){};

  /**
   * Built-in version of FrAMA.
   */
  static double iFrAMA(string _symbol, ENUM_TIMEFRAMES _tf, int _ma_period, int _ma_shift, ENUM_APPLIED_PRICE _ap,
                       int _mode = 0, int _shift = 0, IndicatorBase *_obj = NULL) {
#ifdef __MQL5__
    INDICATOR_BUILTIN_CALL_AND_RETURN(::iFrAMA(_symbol, _tf, _ma_period, _ma_shift, _ap), _mode, _shift);
#else
    INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_LONG(_symbol, _tf,
                                                       Util::MakeKey("Indi_FrAMA", _ma_period, _ma_shift, (int)_ap));
    return iFrAMAOnArray(INDICATOR_CALCULATE_POPULATED_PARAMS_LONG, _ma_period, _ma_shift, _mode, _shift, _ap, _cache);
#endif
  }

  /**
   * Calculates FrAMA on the array of values.
   */
  static double iFrAMAOnArray(INDICATOR_CALCULATE_PARAMS_LONG, int _ma_period, int _ma_shift, int _mode, int _shift,
                              ENUM_APPLIED_PRICE _ap, IndicatorCalculateCache<double> *_cache,
                              bool _recalculate = false) {
    _cache.SetPriceBuffer(_open, _high, _low, _close);

    if (!_cache.HasBuffers()) {
      _cache.AddBuffer<NativeValueStorage<double>>(1);
    }

    if (_recalculate) {
      _cache.ResetPrevCalculated();
    }

    _cache.SetPrevCalculated(Indi_FrAMA::Calculate(INDICATOR_CALCULATE_GET_PARAMS_LONG, _cache.GetBuffer<double>(0),
                                                   _ma_period, _ma_shift, _ap));

    return _cache.GetTailValue<double>(_mode, _shift);
  }

  static int Calculate(INDICATOR_CALCULATE_METHOD_PARAMS_LONG, ValueStorage<double> &FrAmaBuffer, int InpPeriodFrAMA,
                       int InpShift, ENUM_APPLIED_PRICE InpAppliedPrice) {
    if (rates_total < 2 * InpPeriodFrAMA) return (0);

    int start, i;
    // Start calculations.
    if (prev_calculated == 0) {
      start = 2 * InpPeriodFrAMA - 1;
      for (i = 0; i <= start; i++)
        FrAmaBuffer[i] = PriceValueStorage::GetApplied(open, high, low, close, i, InpAppliedPrice);
    } else
      start = prev_calculated - 1;

    // Main cycle.
    double math_log_2 = MathLog(2.0);
    for (i = start; i < rates_total && !IsStopped(); i++) {
      double hi1 = high[iHighest(high, InpPeriodFrAMA, rates_total - i - 1)].Get();
      double lo1 = low[iLowest(low, InpPeriodFrAMA, rates_total - i - 1)].Get();
      double hi2 = high[iHighest(high, InpPeriodFrAMA, rates_total - i + InpPeriodFrAMA - 1)].Get();
      double lo2 = low[iLowest(low, InpPeriodFrAMA, rates_total - i + InpPeriodFrAMA - 1)].Get();
      double hi3 = high[iHighest(high, 2 * InpPeriodFrAMA, rates_total - i - 1)].Get();
      double lo3 = low[iLowest(low, 2 * InpPeriodFrAMA, rates_total - i - 1)].Get();
      double n1 = (hi1 - lo1) / InpPeriodFrAMA;
      double n2 = (hi2 - lo2) / InpPeriodFrAMA;
      double n3 = (hi3 - lo3) / (2 * InpPeriodFrAMA);
      double d = (MathLog(n1 + n2) - MathLog(n3)) / math_log_2;
      double alfa = MathExp(-4.6 * (d - 1.0));
      double _iprice = PriceValueStorage::GetApplied(open, high, low, close, i, InpAppliedPrice);

      FrAmaBuffer[i] = alfa * _iprice + (1 - alfa) * FrAmaBuffer[i - 1].Get();
    }

    // OnCalculate done. Return new prev_calculated.
    return (rates_total);
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_FrAMA::iFrAMA(GetSymbol(), GetTf(), /*[*/ GetPeriod(), GetFRAMAShift(), GetAppliedPrice() /*]*/,
                                    _mode, _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/ GetPeriod(),
                         GetFRAMAShift() /*]*/, 0, _ishift);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /* Getters */

  /**
   * Get period.
   */
  unsigned int GetPeriod() { return iparams.period; }

  /**
   * Get FRAMA shift.
   */
  unsigned int GetFRAMAShift() { return iparams.frama_shift; }

  /**
   * Get applied price.
   */
  ENUM_APPLIED_PRICE GetAppliedPrice() { return iparams.applied_price; }

  /* Setters */

  /**
   * Set period value.
   */
  void SetPeriod(unsigned int _period) {
    istate.is_changed = true;
    iparams.period = _period;
  }

  /**
   * Set FRAMA shift.
   */
  void SetFRAMAShift(unsigned int _frama_shift) {
    istate.is_changed = true;
    iparams.frama_shift = _frama_shift;
  }

  /**
   * Set applied price.
   */
  void SetAppliedPrice(ENUM_APPLIED_PRICE _applied_price) {
    istate.is_changed = true;
    iparams.applied_price = _applied_price;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_FractalAdaptiveMA.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_TEMA.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.price.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../BufferStruct.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_MA.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/Singleton.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Dict.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Refs.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../String.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../DictObject.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef INDI_MA_MQH
#define INDI_MA_MQH

// Includes.








#ifndef __MQL4__
// Defines global functions (for MQL4 backward compability).
double iMA(string _symbol, int _tf, int _ma_period, int _ma_shift, int _ma_method, int _ap, int _shift) {
  ResetLastError();
  return Indi_MA::iMA(_symbol, (ENUM_TIMEFRAMES)_tf, _ma_period, _ma_shift, (ENUM_MA_METHOD)_ma_method,
                      (ENUM_APPLIED_PRICE)_ap, _shift);
}
double iMAOnArray(double &_arr[], int _total, int _period, int _ma_shift, int _ma_method, int _shift,
                  IndicatorCalculateCache<double> *_cache = NULL) {
  ResetLastError();
  return Indi_MA::iMAOnArray(_arr, _total, _period, _ma_shift, _ma_method, _shift, _cache);
}
#endif

// Structs.
struct IndiMAParams : IndicatorParams {
  unsigned int period;
  unsigned int ma_shift;
  ENUM_MA_METHOD ma_method;
  ENUM_APPLIED_PRICE applied_array;
  // Struct constructors.
  IndiMAParams(unsigned int _period = 13, int _ma_shift = 10, ENUM_MA_METHOD _ma_method = MODE_SMA,
               ENUM_APPLIED_PRICE _ap = PRICE_OPEN, int _shift = 0)
      : period(_period),
        ma_shift(_ma_shift),
        ma_method(_ma_method),
        applied_array(_ap),
        IndicatorParams(INDI_MA, 1, TYPE_DOUBLE) {
    shift = _shift;
    SetDataValueRange(IDATA_RANGE_PRICE);
    SetCustomIndicatorName("Examples\\Moving Average");
  };
  IndiMAParams(IndiMAParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Moving Average indicator.
 */
class Indi_MA : public Indicator<IndiMAParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_MA(IndiMAParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiMAParams>(_p, _indi_src) {}
  Indi_MA(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_MA, _tf, _shift) {}

  /**
   * Returns the indicator value.
   *
   * @docs
   * - https://docs.mql4.com/indicators/ima
   * - https://www.mql5.com/en/docs/indicators/ima
   */
  static double iMA(string _symbol, ENUM_TIMEFRAMES _tf, unsigned int _ma_period, unsigned int _ma_shift,
                    ENUM_MA_METHOD _ma_method, ENUM_APPLIED_PRICE _applied_array, int _shift = 0,
                    IndicatorBase *_obj = NULL) {
#ifdef __MQL4__
    return ::iMA(_symbol, _tf, _ma_period, _ma_shift, _ma_method, _applied_array, _shift);
#else  // __MQL5__
    int _handle = Object::IsValid(_obj) ? _obj.Get<int>(IndicatorState::INDICATOR_STATE_PROP_HANDLE) : NULL;
    double _res[];
    if (_handle == NULL || _handle == INVALID_HANDLE) {
      if ((_handle = ::iMA(_symbol, _tf, _ma_period, _ma_shift, _ma_method, _applied_array)) == INVALID_HANDLE) {
        SetUserError(ERR_USER_INVALID_HANDLE);
        return EMPTY_VALUE;
      } else if (Object::IsValid(_obj)) {
        _obj.SetHandle(_handle);
      }
    }
    if (Terminal::IsVisualMode()) {
      // To avoid error 4806 (ERR_INDICATOR_DATA_NOT_FOUND),
      // we check the number of calculated data only in visual mode.
      int _bars_calc = BarsCalculated(_handle);
      if (GetLastError() > 0) {
        return EMPTY_VALUE;
      } else if (_bars_calc <= 2) {
        SetUserError(ERR_USER_INVALID_BUFF_NUM);
        return EMPTY_VALUE;
      }
    }
    if (CopyBuffer(_handle, 0, _shift, 1, _res) < 0) {
      return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;
    }
    return _res[0];
#endif
  }

  /**
   * Calculates MA on another indicator.
   */
  static double iMAOnIndicator(IndicatorCalculateCache<double> *cache, IndicatorBase *_indi, int indi_mode,
                               string symbol, ENUM_TIMEFRAMES tf, unsigned int ma_period, unsigned int ma_shift,
                               ENUM_MA_METHOD ma_method,  // (MT4/MT5): MODE_SMA, MODE_EMA, MODE_SMMA, MODE_LWMA
                               int shift = 0) {
    return iMAOnArray(_indi.GetValueStorage(indi_mode), 0, ma_period, ma_shift, ma_method, shift, cache);
  }

  /**
   * Calculates MA on the array of values. Cache is optional.
   */
  static double iMAOnArray(double &price[], int total, int ma_period, int ma_shift, int ma_method, int shift,
                           IndicatorCalculateCache<double> *cache = NULL) {
#ifdef __MQL4__
    return ::iMAOnArray(price, total, ma_period, ma_shift, ma_method, shift);
#else
    // We're reusing the same native array for each consecutive calculation.
    NativeValueStorage<double> *_array_storage = Singleton<NativeValueStorage<double>>::Get();
    _array_storage.SetData(price);

    return iMAOnArray((ValueStorage<double> *)_array_storage, total, ma_period, ma_shift, ma_method, shift, cache);
#endif
  }

  /**
   * Calculates MA on the array of values.
   */
  static double iMAOnArray(ValueStorage<double> &price, int total, int ma_period, int ma_shift, int ma_method,
                           int shift, IndicatorCalculateCache<double> *_cache = NULL, bool recalculate = false) {
    if (_cache != NULL) {
      _cache.SetPriceBuffer(price);

      if (!_cache.HasBuffers()) {
        _cache.AddBuffer<NativeValueStorage<double>>();
      }

      if (recalculate) {
        _cache.ResetPrevCalculated();
      }

      _cache.SetPrevCalculated(
          Indi_MA::Calculate(INDICATOR_CALCULATE_GET_PARAMS_SHORT, _cache.GetBuffer<double>(0), ma_method, ma_period));

      // Returns value from the first calculation buffer.
      // Returns first value for as-series array or last value for non-as-series array.
      return _cache.GetTailValue<double>(0, shift + ma_shift);
    }

    double buf[], arr[], _result, pr, _array;
    int pos, i, k, weight;
    double sum, lsum;
    if (total == 0) total = ArraySize(price);
    if (total > 0 && total < ma_period) return (0);
    if (shift > total - ma_period - ma_shift) return (0);
    bool _was_series = ArrayGetAsSeries(price);
    ArraySetAsSeries(price, true);
    switch (ma_method) {
      case MODE_SMA:
        total = ArrayCopy(arr, price, 0, shift + ma_shift, ma_period);
        if (ArrayResize(buf, total) < 0) return (0);
        sum = 0;
        pos = total - 1;
        for (i = 1; i < ma_period; i++, pos--) sum += arr[pos];
        while (pos >= 0) {
          sum += arr[pos];
          buf[pos] = sum / ma_period;
          sum -= arr[pos + ma_period - 1];
          pos--;
        }
        _result = buf[0];
        break;
      case MODE_EMA:
        if (ArrayResize(buf, total) < 0) return (0);
        pr = 2.0 / (ma_period + 1);
        pos = total - 2;
        while (pos >= 0) {
          if (pos == total - 2) buf[pos + 1] = price[pos + 1].Get();
          buf[pos] = price[pos] * pr + buf[pos + 1] * (1 - pr);
          pos--;
        }
        _result = buf[0];
        break;
      case MODE_SMMA:
        if (ArrayResize(buf, total) < 0) return (0);
        sum = 0;
        pos = total - ma_period;
        while (pos >= 0) {
          if (pos == total - ma_period) {
            for (i = 0, k = pos; i < ma_period; i++, k++) {
              sum += price[k].Get();
              buf[k] = 0;
            }
          } else
            sum = buf[pos + 1] * (ma_period - 1) + price[pos].Get();
          buf[pos] = sum / ma_period;
          pos--;
        }
        _result = buf[0];
        break;
      case MODE_LWMA:
        if (ArrayResize(buf, total) < 0) return (0);
        sum = 0.0;
        lsum = 0.0;
        weight = 0;
        pos = total - 1;
        for (i = 1; i <= ma_period; i++, pos--) {
          _array = price[pos].Get();
          sum += _array * i;
          lsum += _array;
          weight += i;
        }
        pos++;
        i = pos + ma_period;
        while (pos >= 0) {
          buf[pos] = sum / weight;
          if (pos == 0) break;
          pos--;
          i--;
          _array = price[pos].Get();
          sum = sum - lsum + _array * ma_period;
          lsum -= price[i].Get();
          lsum += _array;
        }
        _result = buf[0];
        break;
      default:
        _result = 0;
    }
    ArraySetAsSeries(price, _was_series);
    return _result;
  }

  /**
   * Calculates Simple Moving Average (SMA). The same as in "Example Moving Average" indicator.
   */
  static void CalculateSimpleMA(int rates_total, int prev_calculated, int begin, ValueStorage<double> &price,
                                ValueStorage<double> &ExtLineBuffer, int _ma_period) {
    int i, start;
    // First calculation or number of bars was changed.
    if (prev_calculated == 0) {
      start = _ma_period + begin;
      // Set empty value for first start bars.
      for (i = 0; i < start - 1; i++) ExtLineBuffer[i] = 0.0;
      // Calculate first visible value.
      double first_value = 0;
      for (i = begin; i < start; i++) first_value += price[i].Get();
      first_value /= _ma_period;
      ExtLineBuffer[start - 1] = first_value;
    } else
      start = prev_calculated - 1;
    // Main loop.
    for (i = start; i < rates_total && !IsStopped(); i++) {
      ExtLineBuffer[i] = ExtLineBuffer[i - 1] + (price[i] - price[i - _ma_period]) / _ma_period;
    }
  }

  /**
   * Calculates Exponential Moving Average (EMA). The same as in "Example Moving Average" indicator.
   */
  static void CalculateEMA(int rates_total, int prev_calculated, int begin, ValueStorage<double> &price,
                           ValueStorage<double> &ExtLineBuffer, int _ma_period) {
    int i, limit;
    double SmoothFactor = 2.0 / (1.0 + _ma_period);
    // First calculation or number of bars was changed.
    if (prev_calculated == 0) {
      limit = _ma_period + begin;
      ExtLineBuffer[begin] = price[begin];
      for (i = begin + 1; i < limit; i++) {
        ExtLineBuffer[i] = price[i] * SmoothFactor + ExtLineBuffer[i - 1] * (1.0 - SmoothFactor);
      }
    } else
      limit = prev_calculated - 1;
    // Main loop.
    for (i = limit; i < rates_total && !IsStopped(); i++) {
      ExtLineBuffer[i] = price[i] * SmoothFactor + ExtLineBuffer[i - 1] * (1.0 - SmoothFactor);
    }
  }

  /**
   * Calculates Linearly Weighted Moving Average (LWMA). The same as in "Example Moving Average" indicator.
   */
  static void CalculateLWMA(int rates_total, int prev_calculated, int begin, ValueStorage<double> &price,
                            ValueStorage<double> &ExtLineBuffer, int _ma_period) {
    int i, limit;
    static int weightsum;
    double sum;
    // First calculation or number of bars was changed.
    if (prev_calculated == 0) {
      weightsum = 0;
      limit = _ma_period + begin;
      // Set empty value for first limit bars.
      for (i = 0; i < limit; i++) ExtLineBuffer[i] = 0.0;
      // Calculate first visible value.
      double firstValue = 0;
      for (i = begin; i < limit; i++) {
        int k = i - begin + 1;
        weightsum += k;
        firstValue += k * price[i].Get();
      }
      firstValue /= (double)weightsum;
      ExtLineBuffer[limit - 1] = firstValue;
    } else
      limit = prev_calculated - 1;
    // Main loop.
    for (i = limit; i < rates_total && !IsStopped(); i++) {
      sum = 0;
      for (int j = 0; j < _ma_period; j++) sum += (_ma_period - j) * price[i - j].Get();
      ExtLineBuffer[i] = sum / weightsum;
    }
    //---
  }

  /**
   * Calculates Smoothed Moving Average (SMMA). The same as in "Example Moving Average" indicator.
   */
  static void CalculateSmoothedMA(int rates_total, int prev_calculated, int begin, ValueStorage<double> &price,
                                  ValueStorage<double> &ExtLineBuffer, int _ma_period) {
    int i, limit;
    // First calculation or number of bars was changed.
    if (prev_calculated == 0) {
      limit = _ma_period + begin;
      // Set empty value for first limit bars.
      for (i = 0; i < limit - 1; i++) ExtLineBuffer[i] = 0.0;
      // Calculate first visible value.
      double firstValue = 0;
      for (i = begin; i < limit; i++) firstValue += price[i].Get();
      firstValue /= _ma_period;
      ExtLineBuffer[limit - 1] = firstValue;
    } else
      limit = prev_calculated - 1;
    // Main loop.
    for (i = limit; i < rates_total && !IsStopped(); i++)
      ExtLineBuffer[i] = (ExtLineBuffer[i - 1] * (_ma_period - 1) + price[i].Get()) / _ma_period;
    //---
  }

  static double ExponentialMA(const int position, const int period, const double prev_value,
                              ValueStorage<double> &price) {
    double result = 0.0;
    // Check period.
    if (period > 0) {
      double pr = 2.0 / (period + 1.0);
      result = price[position] * pr + prev_value * (1 - pr);
    }

    return (result);
  }

  static int ExponentialMAOnBuffer(const int rates_total, const int prev_calculated, const int begin, const int period,
                                   ValueStorage<double> &price, ValueStorage<double> &buffer) {
    if (period <= 1 || period > (rates_total - begin)) return (0);

    bool as_series_array = ArrayGetAsSeries(price);
    bool as_series_buffer = ArrayGetAsSeries(buffer);

    ArraySetAsSeries(price, false);
    ArraySetAsSeries(buffer, false);

    int start_position, i;
    double smooth_factor = 2.0 / (1.0 + period);

    if (prev_calculated == 0) {
      // First calculation or number of bars was changed.
      // Set empty value for first bars.
      for (i = 0; i < begin; i++) buffer[i] = 0.0;
      // Calculate first visible value.
      start_position = period + begin;
      buffer[begin] = price[begin];

      for (i = begin + 1; i < start_position; i++)
        buffer[i] = price[i] * smooth_factor + buffer[i - 1] * (1.0 - smooth_factor);
    } else
      start_position = prev_calculated - 1;

    for (i = start_position; i < rates_total; i++)
      buffer[i] = price[i] * smooth_factor + buffer[i - 1] * (1.0 - smooth_factor);

    ArraySetAsSeries(price, as_series_array);
    ArraySetAsSeries(buffer, as_series_buffer);

    return (rates_total);
  }

  static int SimpleMAOnBuffer(const int rates_total, const int prev_calculated, const int begin, const int period,
                              ValueStorage<double> &price, ValueStorage<double> &buffer) {
    int i;
    // Check period.
    if (period <= 1 || period > (rates_total - begin)) return (0);
    // Save as_series flags.
    bool as_series_price = ArrayGetAsSeries(price);
    bool as_series_buffer = ArrayGetAsSeries(buffer);

    ArraySetAsSeries(price, false);
    ArraySetAsSeries(buffer, false);
    // Calculate start position.
    int start_position;

    if (prev_calculated == 0) {
      // First calculation or number of bars was changed.
      // Set empty value for first bars.
      start_position = period + begin;

      for (i = 0; i < start_position - 1; i++) buffer[i] = 0.0;
      // Calculate first visible value.
      double first_value = 0;

      for (i = begin; i < start_position; i++) first_value += price[i].Get();

      buffer[start_position - 1] = first_value / period;
    } else
      start_position = prev_calculated - 1;
    // Main loop.
    for (i = start_position; i < rates_total; i++) buffer[i] = buffer[i - 1] + (price[i] - price[i - period]) / period;
    // Restore as_series flags.
    ArraySetAsSeries(price, as_series_price);
    ArraySetAsSeries(buffer, as_series_buffer);
    return (rates_total);
  }

  static int LinearWeightedMAOnBuffer(const int rates_total, const int prev_calculated, const int begin,
                                      const int period, ValueStorage<double> &price, ValueStorage<double> &buffer) {
    // Check period.
    if (period <= 1 || period > (rates_total - begin)) return (0);
    // Save as_series flags.
    bool as_series_price = ArrayGetAsSeries(price);
    bool as_series_buffer = ArrayGetAsSeries(buffer);

    ArraySetAsSeries(price, false);
    ArraySetAsSeries(buffer, false);
    // Calculate start position.
    int i, start_position;

    if (prev_calculated <= period + begin + 2) {
      // First calculation or number of bars was changed.
      // Set empty value for first bars.
      start_position = period + begin;

      for (i = 0; i < start_position; i++) buffer[i] = 0.0;
    } else
      start_position = prev_calculated - 2;
    // Calculate first visible value.
    double sum = 0.0, lsum = 0.0;
    int l, weight = 0;

    for (i = start_position - period, l = 1; i < start_position; i++, l++) {
      sum += price[i] * l;
      lsum += price[i].Get();
      weight += l;
    }
    buffer[start_position - 1] = sum / weight;
    // Main loop.
    for (i = start_position; i < rates_total; i++) {
      sum = sum - lsum + price[i] * period;
      lsum = lsum - price[i - period].Get() + price[i].Get();
      buffer[i] = sum / weight;
    }
    // Restore as_series flags.
    ArraySetAsSeries(price, as_series_price);
    ArraySetAsSeries(buffer, as_series_buffer);
    return (rates_total);
  }

  static int LinearWeightedMAOnBuffer(const int rates_total, const int prev_calculated, const int begin,
                                      const int period, ValueStorage<double> &price, ValueStorage<double> &buffer,
                                      int &weight_sum) {
    int i, k;

    // Check period.
    if (period <= 1 || period > (rates_total - begin)) return (0);
    // Save as_series flags.
    bool as_series_price = ArrayGetAsSeries(price);
    bool as_series_buffer = ArrayGetAsSeries(buffer);

    ArraySetAsSeries(price, false);
    ArraySetAsSeries(buffer, false);
    // Calculate start position.
    int start_position;

    if (prev_calculated == 0) {
      // First calculation or number of bars was changed.
      // Set empty value for first bars.
      start_position = period + begin;

      for (i = 0; i < start_position; i++) buffer[i] = 0.0;
      // Calculate first visible value.
      double first_value = 0;
      int wsum = 0;

      for (i = begin, k = 1; i < start_position; i++, k++) {
        first_value += k * price[i].Get();
        wsum += k;
      }

      buffer[start_position - 1] = first_value / wsum;
      weight_sum = wsum;
    } else
      start_position = prev_calculated - 1;
    // Main loop.
    for (i = start_position; i < rates_total; i++) {
      double sum = 0;

      for (int j = 0; j < period; j++) sum += (period - j) * price[i - j].Get();

      buffer[i] = sum / weight_sum;
    }
    // Restore as_series flags.
    ArraySetAsSeries(price, as_series_price);
    ArraySetAsSeries(buffer, as_series_buffer);
    return (rates_total);
  }

  static int SmoothedMAOnBuffer(const int rates_total, const int prev_calculated, const int begin, const int period,
                                ValueStorage<double> &price, ValueStorage<double> &buffer) {
    int i;
    // Check period.
    if (period <= 1 || period > (rates_total - begin)) return (0);
    // Save as_series flags.
    bool as_series_price = ArrayGetAsSeries(price);
    bool as_series_buffer = ArrayGetAsSeries(buffer);

    ArraySetAsSeries(price, false);
    ArraySetAsSeries(buffer, false);
    // Calculate start position.
    int start_position;

    if (prev_calculated == 0) {
      // First calculation or number of bars was changed.
      // Set empty value for first bars.
      start_position = period + begin;

      for (i = 0; i < start_position - 1; i++) buffer[i] = 0.0;
      // Calculate first visible value.
      double first_value = 0;

      for (i = begin; i < start_position; i++) first_value += price[i].Get();

      buffer[start_position - 1] = first_value / period;
    } else
      start_position = prev_calculated - 1;
    // Main loop.
    for (i = start_position; i < rates_total; i++) buffer[i] = (buffer[i - 1] * (period - 1) + price[i].Get()) / period;
    // Restore as_series flags.
    ArraySetAsSeries(price, as_series_price);
    ArraySetAsSeries(buffer, as_series_buffer);
    return (rates_total);
  }

  /**
   * Calculates Moving Average. The same as in "Example Moving Average" indicator.
   */
  static int Calculate(const int rates_total, const int prev_calculated, const int begin, ValueStorage<double> &price,
                       ValueStorage<double> &ExtLineBuffer, int _ma_method, int _ma_period) {
    // Check for bars count.
    if (rates_total < _ma_period - 1 + begin) {
      // Not enough bars for calculation.
      return (0);
    }
    if (prev_calculated == 0) {
      // First calculation or number of bars was changed.
      ArrayInitialize(ExtLineBuffer, (double)0);
    }

    // Calculation.
    switch (_ma_method) {
      case MODE_EMA:
        CalculateEMA(rates_total, prev_calculated, begin, price, ExtLineBuffer, _ma_period);
        break;
      case MODE_LWMA:
        CalculateLWMA(rates_total, prev_calculated, begin, price, ExtLineBuffer, _ma_period);
        break;
      case MODE_SMMA:
        CalculateSmoothedMA(rates_total, prev_calculated, begin, price, ExtLineBuffer, _ma_period);
        break;
      case MODE_SMA:
        CalculateSimpleMA(rates_total, prev_calculated, begin, price, ExtLineBuffer, _ma_period);
        break;
    }
    // Return value of prev_calculated for next call.
    return (rates_total);
  }

  static double SimpleMA(const int position, const int period, const double &price[]) {
    double result = 0.0;
    for (int i = 0; i < period; i++) {
      result += price[i];
    }
    result /= period;
    return result;
  }

  static double SimpleMA(const int position, const int period, ValueStorage<double> &price) {
    double result = 0.0;
    for (int i = 0; i < period; i++) {
      result += price[i].Get();
    }
    result /= period;
    return result;
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_MA::iMA(GetSymbol(), GetTf(), GetPeriod(), GetMAShift(), GetMAMethod(), GetAppliedPrice(),
                              _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.custom_indi_name, /* [ */ GetPeriod(),
                         GetMAShift(), GetMAMethod(), GetAppliedPrice() /* ] */, 0, _ishift);
        break;
      case IDATA_INDICATOR:
        // Calculating MA value from specified indicator.
        _value = Indi_MA::iMAOnIndicator(GetCache(), GetDataSource(), GetDataSourceMode(), GetSymbol(), GetTf(),
                                         GetPeriod(), GetMAShift(), GetMAMethod(), _ishift);
        break;
    }
    return _value;
  }

  /**
   * Returns reusable indicator.
   */
  static Indi_MA *GetCached(string _symbol, ENUM_TIMEFRAMES _tf, int _period, int _ma_shift, ENUM_MA_METHOD _ma_method,
                            ENUM_APPLIED_PRICE _ap) {
    Indi_MA *_ptr;
    string _key = Util::MakeKey(_symbol, (int)_tf, _period, _ma_shift, (int)_ma_method, (int)_ap);
    if (!Objects<Indi_MA>::TryGet(_key, _ptr)) {
      IndiMAParams _p(_period, _ma_shift, _ma_method, _ap);
      _ptr = Objects<Indi_MA>::Set(_key, new Indi_MA(_p));
      _ptr.SetSymbol(_symbol);
    }
    return _ptr;
  }

  /* Getters */

  /**
   * Get period value.
   *
   * Averaging period for the calculation of the moving average.
   */
  unsigned int GetPeriod() { return iparams.period; }

  /**
   * Get MA shift value.
   *
   * Indicators line offset relate to the chart by timeframe.
   */
  unsigned int GetMAShift() { return iparams.ma_shift; }

  /**
   * Set MA method (smoothing type).
   */
  ENUM_MA_METHOD GetMAMethod() { return iparams.ma_method; }

  /**
   * Get applied price value.
   *
   * The desired price base for calculations.
   */
  ENUM_APPLIED_PRICE GetAppliedPrice() { return iparams.applied_array; }

  /* Setters */

  /**
   * Set period value.
   *
   * Averaging period for the calculation of the moving average.
   */
  void SetPeriod(unsigned int _period) {
    istate.is_changed = true;
    iparams.period = _period;
  }

  /**
   * Set MA shift value.
   */
  void SetMAShift(int _ma_shift) {
    istate.is_changed = true;
    iparams.ma_shift = _ma_shift;
  }

  /**
   * Set MA method.
   *
   * Indicators line offset relate to the chart by timeframe.
   */
  void SetMAMethod(ENUM_MA_METHOD _ma_method) {
    istate.is_changed = true;
    iparams.ma_method = _ma_method;
  }

  /**
   * Set applied price value.
   *
   * The desired price base for calculations.
   * @docs
   * - https://docs.mql4.com/constants/indicatorconstants/prices#enum_applied_price_enum
   * - https://www.mql5.com/en/docs/constants/indicatorconstants/prices#enum_applied_price_enum
   */
  void SetAppliedPrice(ENUM_APPLIED_PRICE _applied_array) {
    istate.is_changed = true;
    iparams.applied_array = _applied_array;
  }
};
#endif  // INDI_MA_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_MA.mqh
////////////////////////////////////////////////////////////
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.





// Structs.
struct IndiTEMAParams : IndicatorParams {
  unsigned int period;
  unsigned int tema_shift;
  ENUM_APPLIED_PRICE applied_price;
  // Struct constructor.
  IndiTEMAParams(int _period = 14, int _tema_shift = 0, ENUM_APPLIED_PRICE _ap = PRICE_CLOSE, int _shift = 0)
      : IndicatorParams(INDI_TEMA, 1, TYPE_DOUBLE) {
    applied_price = _ap;
    SetDataValueRange(IDATA_RANGE_MIXED);
    SetCustomIndicatorName("Examples\\TEMA");
    period = _period;
    shift = _shift;
    tema_shift = _tema_shift;
  };
  IndiTEMAParams(IndiTEMAParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Triple Exponential Moving Average indicator.
 */
class Indi_TEMA : public Indicator<IndiTEMAParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_TEMA(IndiTEMAParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiTEMAParams>(_p, _indi_src){};
  Indi_TEMA(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_TEMA, _tf, _shift){};

  /**
   * Built-in version of TEMA.
   */
  static double iTEMA(string _symbol, ENUM_TIMEFRAMES _tf, int _ma_period, int _ma_shift, ENUM_APPLIED_PRICE _ap,
                      int _mode = 0, int _shift = 0, Indi_TEMA *_obj = NULL) {
#ifdef __MQL5__
    INDICATOR_BUILTIN_CALL_AND_RETURN(::iTEMA(_symbol, _tf, _ma_period, _ma_shift, _ap), _mode, _shift);
#else
    INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_SHORT(_symbol, _tf, _ap,
                                                        Util::MakeKey("Indi_TEMA", _ma_period, _ma_shift, (int)_ap));
    return iTEMAOnArray(INDICATOR_CALCULATE_POPULATED_PARAMS_SHORT, _ma_period, _ma_shift, _mode, _shift, _cache);
#endif
  }

  /**
   * Calculates iTEMA on the array of values.
   */
  static double iTEMAOnArray(INDICATOR_CALCULATE_PARAMS_SHORT, int _ma_period, int _ma_shift, int _mode, int _shift,
                             IndicatorCalculateCache<double> *_cache, bool _recalculate = false) {
    _cache.SetPriceBuffer(_price);

    if (!_cache.HasBuffers()) {
      _cache.AddBuffer<NativeValueStorage<double>>(4);
    }

    if (_recalculate) {
      _cache.ResetPrevCalculated();
    }

    _cache.SetPrevCalculated(Indi_TEMA::Calculate(INDICATOR_CALCULATE_GET_PARAMS_SHORT, _cache.GetBuffer<double>(0),
                                                  _cache.GetBuffer<double>(1), _cache.GetBuffer<double>(2),
                                                  _cache.GetBuffer<double>(3), _ma_period, _ma_shift));

    return _cache.GetTailValue<double>(_mode, _shift);
  }

  /**
   * OnCalculate() method for TEMA indicator.
   *
   * Note that InpShift is used for drawing only and thus is unused.
   */
  static int Calculate(INDICATOR_CALCULATE_METHOD_PARAMS_SHORT, ValueStorage<double> &TemaBuffer,
                       ValueStorage<double> &Ema, ValueStorage<double> &EmaOfEma, ValueStorage<double> &EmaOfEmaOfEma,
                       int InpPeriodEMA, int InpShift) {
    if (rates_total < 3 * InpPeriodEMA - 3) return (0);
    //---
    int start;
    if (prev_calculated == 0)
      start = 0;
    else
      start = prev_calculated - 1;
    // Calculate EMA.
    Indi_MA::ExponentialMAOnBuffer(rates_total, prev_calculated, 0, InpPeriodEMA, price, Ema);
    // Calculate EMA on EMA array.
    Indi_MA::ExponentialMAOnBuffer(rates_total, prev_calculated, InpPeriodEMA - 1, InpPeriodEMA, Ema, EmaOfEma);
    // Calculate EMA on EMA array on EMA array.
    Indi_MA::ExponentialMAOnBuffer(rates_total, prev_calculated, 2 * InpPeriodEMA - 2, InpPeriodEMA, EmaOfEma,
                                   EmaOfEmaOfEma);
    // Calculate TEMA.
    for (int i = start; i < rates_total && !IsStopped(); i++)
      TemaBuffer[i] = 3 * Ema[i].Get() - 3 * EmaOfEma[i].Get() + EmaOfEmaOfEma[i].Get();
    // OnCalculate done. Return new prev_calculated.
    return (rates_total);
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_TEMA::iTEMA(GetSymbol(), GetTf(), /*[*/ GetPeriod(), GetTEMAShift(), GetAppliedPrice() /*]*/, 0,
                                  _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/ GetPeriod(),
                         GetTEMAShift() /*]*/, 0, _ishift);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
        break;
    }
    return _value;
  }

  /**
   * Checks if indicator entry values are valid.
   */
  virtual bool IsValidEntry(IndicatorDataEntry &_entry) {
    return !_entry.HasValue<double>(NULL) && !_entry.HasValue<double>(EMPTY_VALUE);
  }

  /* Getters */

  /**
   * Get period.
   */
  unsigned int GetPeriod() { return iparams.period; }

  /**
   * Get TEMA shift.
   */
  unsigned int GetTEMAShift() { return iparams.tema_shift; }

  /**
   * Get applied price.
   */
  ENUM_APPLIED_PRICE GetAppliedPrice() { return iparams.applied_price; }

  /* Setters */

  /**
   * Set period value.
   */
  void SetPeriod(unsigned int _period) {
    istate.is_changed = true;
    iparams.period = _period;
  }

  /**
   * Set TEMA shift.
   */
  void SetTEMAShift(unsigned int _tema_shift) {
    istate.is_changed = true;
    iparams.tema_shift = _tema_shift;
  }

  /**
   * Set applied price.
   */
  void SetAppliedPrice(ENUM_APPLIED_PRICE _applied_price) {
    istate.is_changed = true;
    iparams.applied_price = _applied_price;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_TEMA.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indi_MA.mqh

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_AMA.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../BufferStruct.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.price.h

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_Price.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../../BufferStruct.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../../Storage/Objects.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.




// Structs.
struct PriceIndiParams : IndicatorParams {
  ENUM_APPLIED_PRICE ap;
  // Struct constructor.
  PriceIndiParams(ENUM_APPLIED_PRICE _ap = PRICE_TYPICAL, int _shift = 0)
      : ap(_ap), IndicatorParams(INDI_PRICE, 1, TYPE_DOUBLE) {
    SetShift(_shift);
  };
  PriceIndiParams(PriceIndiParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
  // Getters.
  ENUM_APPLIED_PRICE GetAppliedPrice() { return ap; }
  // Setters.
  void SetAppliedPrice(ENUM_APPLIED_PRICE _ap) { ap = _ap; }
};

/**
 * Price Indicator.
 */
class Indi_Price : public Indicator<PriceIndiParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_Price(PriceIndiParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<PriceIndiParams>(_p, _indi_src){};
  Indi_Price(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_PRICE, _tf, _shift){};

  /**
   * Checks whether indicator has a valid value for a given shift.
   */
  virtual bool HasValidEntry(int _shift = 0) { return GetBarTime(_shift) != 0; }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    return ChartStatic::iPrice(iparams.GetAppliedPrice(), GetSymbol(), GetTf(), _ishift);
  }

  /**
   * Returns already cached version of Indi_Price for a given parameters.
   */
  static Indi_Price *GetCached(string _symbol, ENUM_APPLIED_PRICE _ap, ENUM_TIMEFRAMES _tf, int _shift) {
    String _cache_key;
    _cache_key.Add(_symbol);
    _cache_key.Add((int)_ap);
    _cache_key.Add((int)_tf);
    _cache_key.Add(_shift);
    string _key = _cache_key.ToString();
    Indi_Price *_indi_price;
    if (!Objects<Indi_Price>::TryGet(_key, _indi_price)) {
      PriceIndiParams _indi_price_params(_ap, _shift);
      _indi_price_params.SetTf(_tf);
      _indi_price = Objects<Indi_Price>::Set(_key, new Indi_Price(_indi_price_params));
      _indi_price.SetSymbol(_symbol);
    }
    return _indi_price;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_Price.mqh
////////////////////////////////////////////////////////////
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Includes.






// Structs.
struct IndiAMAParams : IndicatorParams {
  unsigned int period;
  unsigned int fast_period;
  unsigned int slow_period;
  unsigned int ama_shift;
  ENUM_APPLIED_PRICE applied_price;
  // Struct constructor.
  IndiAMAParams(int _period = 10, int _fast_period = 2, int _slow_period = 30, int _ama_shift = 0,
                ENUM_APPLIED_PRICE _ap = PRICE_TYPICAL, int _shift = 0)
      : period(_period),
        fast_period(_fast_period),
        slow_period(_slow_period),
        ama_shift(_ama_shift),
        applied_price(_ap),
        IndicatorParams(INDI_AMA, 1, TYPE_DOUBLE) {
    SetDataValueRange(IDATA_RANGE_PRICE);
    SetShift(_shift);
    switch (idstype) {
      case IDATA_ICUSTOM:
        if (custom_indi_name == "") {
          SetCustomIndicatorName("Examples\\AMA");
        }
        break;
    }
  };
  IndiAMAParams(IndiAMAParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the AMA indicator.
 */
class Indi_AMA : public Indicator<IndiAMAParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_AMA(IndiAMAParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiAMAParams>(_p, _indi_src){};
  Indi_AMA(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_AMA, _tf, _shift){};

  /**
   * Built-in version of AMA.
   */
  static double iAMA(string _symbol, ENUM_TIMEFRAMES _tf, int _ama_period, int _fast_ema_period, int _slow_ema_period,
                     int _ama_shift, ENUM_APPLIED_PRICE _ap, int _mode = 0, int _shift = 0,
                     IndicatorBase *_obj = NULL) {
#ifdef __MQL5__
    INDICATOR_BUILTIN_CALL_AND_RETURN(
        ::iAMA(_symbol, _tf, _ama_period, _fast_ema_period, _slow_ema_period, _ama_shift, _ap), _mode, _shift);
#else
    INDICATOR_CALCULATE_POPULATE_PARAMS_AND_CACHE_SHORT(
        _symbol, _tf, _ap,
        Util::MakeKey("INDI_AMA", _ama_period, _fast_ema_period, _slow_ema_period, _ama_shift, (int)_ap));
    return iAMAOnArray(INDICATOR_CALCULATE_POPULATED_PARAMS_SHORT, _ama_period, _fast_ema_period, _slow_ema_period,
                       _ama_shift, _mode, _shift, _cache);
#endif
  }

  /**
   * Calculates AMA on the array of values.
   */
  static double iAMAOnArray(INDICATOR_CALCULATE_PARAMS_SHORT, int _ama_period, int _fast_ema_period,
                            int _slow_ema_period, int _ama_shift, int _mode, int _shift,
                            IndicatorCalculateCache<double> *_cache, bool _recalculate = false) {
    _cache.SetPriceBuffer(_price);

    if (!_cache.HasBuffers()) {
      _cache.AddBuffer<NativeValueStorage<double>>(1);
    }

    if (_recalculate) {
      _cache.ResetPrevCalculated();
    }

    _cache.SetPrevCalculated(Indi_AMA::Calculate(INDICATOR_CALCULATE_GET_PARAMS_SHORT, _cache.GetBuffer<double>(0),
                                                 _ama_period, _fast_ema_period, _slow_ema_period, _ama_shift));

    return _cache.GetTailValue<double>(_mode, _shift);
  }

  /**
   * OnInit() method for AMA indicator.
   */
  static void CalculateInit(int InpPeriodAMA, int InpFastPeriodEMA, int InpSlowPeriodEMA, int InpShiftAMA,
                            double &ExtFastSC, double &ExtSlowSC, int &ExtPeriodAMA, int &ExtSlowPeriodEMA,
                            int &ExtFastPeriodEMA) {
    // Check for input values.
    if (InpPeriodAMA <= 0) {
      ExtPeriodAMA = 10;
      PrintFormat(
          "Input parameter InpPeriodAMA has incorrect value (%d). Indicator will use value %d for calculations.",
          InpPeriodAMA, ExtPeriodAMA);
    } else
      ExtPeriodAMA = InpPeriodAMA;
    if (InpSlowPeriodEMA <= 0) {
      ExtSlowPeriodEMA = 30;
      PrintFormat(
          "Input parameter InpSlowPeriodEMA has incorrect value (%d). Indicator will use value %d for calculations.",
          InpSlowPeriodEMA, ExtSlowPeriodEMA);
    } else
      ExtSlowPeriodEMA = InpSlowPeriodEMA;
    if (InpFastPeriodEMA <= 0) {
      ExtFastPeriodEMA = 2;
      PrintFormat(
          "Input parameter InpFastPeriodEMA has incorrect value (%d). Indicator will use value %d for calculations.",
          InpFastPeriodEMA, ExtFastPeriodEMA);
    } else
      ExtFastPeriodEMA = InpFastPeriodEMA;

    // Calculate ExtFastSC & ExtSlowSC.
    ExtFastSC = 2.0 / (ExtFastPeriodEMA + 1.0);
    ExtSlowSC = 2.0 / (ExtSlowPeriodEMA + 1.0);
  }

  /**
   * OnCalculate() method for AMA indicator.
   */
  static int Calculate(INDICATOR_CALCULATE_METHOD_PARAMS_SHORT, ValueStorage<double> &ExtAMABuffer, int InpPeriodAMA,
                       int InpFastPeriodEMA, int InpSlowPeriodEMA, int InpShiftAMA) {
    double ExtFastSC;
    double ExtSlowSC;
    int ExtPeriodAMA;
    int ExtSlowPeriodEMA;
    int ExtFastPeriodEMA;

    CalculateInit(InpPeriodAMA, InpFastPeriodEMA, InpSlowPeriodEMA, InpShiftAMA, ExtFastSC, ExtSlowSC, ExtPeriodAMA,
                  ExtSlowPeriodEMA, ExtFastPeriodEMA);

    int i;
    // Check for rates count.
    if (rates_total < ExtPeriodAMA + begin) return (0);
    // Draw begin may be corrected.
    if (begin != 0) PlotIndexSetInteger(0, PLOT_DRAW_BEGIN, ExtPeriodAMA + begin);
    // Detect position.
    int pos = prev_calculated - 1;
    // First calculations.
    if (pos < ExtPeriodAMA + begin) {
      pos = ExtPeriodAMA + begin;
      for (i = 0; i < pos - 1; i++) ExtAMABuffer[i] = 0.0;

      ExtAMABuffer[pos - 1] = price[pos - 1];
    }
    // Main cycle.
    for (i = pos; i < rates_total && !IsStopped(); i++) {
      // Calculate SSC.
      double currentSSC = (CalculateER(i, price, ExtPeriodAMA) * (ExtFastSC - ExtSlowSC)) + ExtSlowSC;
      // Calculate AMA.
      double prevAMA = ExtAMABuffer[i - 1].Get();

      ExtAMABuffer[i] = MathPow(currentSSC, 2) * (price[i] - prevAMA) + prevAMA;
    }
    // Return value of prev_calculated for next call.
    return (rates_total);
  }

  /**
   * Calculate ER value
   */
  static double CalculateER(const int pos, ValueStorage<double> &price, int ExtPeriodAMA) {
    double signal = MathAbs(price[pos] - price[pos - ExtPeriodAMA]);
    double noise = 0.0;
    for (int delta = 0; delta < ExtPeriodAMA; delta++) noise += MathAbs(price[pos - delta] - price[pos - delta - 1]);
    if (noise != 0.0) return (signal / noise);
    return (0.0);
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();
    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        _value = Indi_AMA::iAMA(GetSymbol(), GetTf(), /*[*/ GetPeriod(), GetFastPeriod(), GetSlowPeriod(),
                                GetAMAShift(), GetAppliedPrice() /*]*/, _mode, _ishift, THIS_PTR);
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.GetCustomIndicatorName(), /*[*/ GetPeriod(),
                         GetFastPeriod(), GetSlowPeriod(), GetAMAShift() /*]*/, _mode, _ishift);

        break;
      case IDATA_INDICATOR:
        // @todo
        SetUserError(ERR_INVALID_PARAMETER);
        break;
      default:
        SetUserError(ERR_INVALID_PARAMETER);
    }
    return _value;
  }

  /* Getters */

  /**
   * Get AMA shift.
   */
  unsigned int GetAMAShift() { return iparams.ama_shift; }

  /**
   * Get period.
   */
  unsigned int GetPeriod() { return iparams.period; }

  /**
   * Get fast period.
   */
  unsigned int GetFastPeriod() { return iparams.fast_period; }

  /**
   * Get slow period.
   */
  unsigned int GetSlowPeriod() { return iparams.slow_period; }

  /**
   * Get applied price.
   */
  ENUM_APPLIED_PRICE GetAppliedPrice() { return iparams.applied_price; }

  /* Setters */

  /**
   * Set AMA shift.
   */
  void SetAMAShift(unsigned int _ama_shift) {
    istate.is_changed = true;
    iparams.ama_shift = _ama_shift;
  }

  /**
   * Set period value.
   */
  void SetPeriod(unsigned int _period) {
    istate.is_changed = true;
    iparams.period = _period;
  }

  /**
   * Set fast period.
   */
  void SetFastPeriod(unsigned int _fast_period) {
    istate.is_changed = true;
    iparams.fast_period = _fast_period;
  }

  /**
   * Set slow period.
   */
  void SetSlowPeriod(unsigned int _slow_period) {
    istate.is_changed = true;
    iparams.slow_period = _slow_period;
  }

  /**
   * Set applied price.
   */
  void SetAppliedPrice(ENUM_APPLIED_PRICE _applied_price) {
    istate.is_changed = true;
    iparams.applied_price = _applied_price;
  }
};

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_AMA.mqh
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// üìÑ ÿ®ÿØÿßŸäÿ©: Indi_DEMA.mqh
////////////////////////////////////////////////////////////
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indi_MA.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/ValueStorage.h
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Storage/Objects.h
// ‚úÖ ÿ™ŸÖ ÿ™ÿ∂ŸÖŸäŸÜŸá ŸÖÿ≥ÿ®ŸÇÿßŸã: Indi_Price.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Dict.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Refs.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../String.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../DictObject.mqh
// ‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÖŸÑŸÅ: ../Indicator.mqh
//+------------------------------------------------------------------+
//|                                                EA31337 framework |
//|                                 Copyright 2016-2021, EA31337 Ltd |
//|                                       https://github.com/EA31337 |
//+------------------------------------------------------------------+

/*
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// Prevents processing this includes file for the second time.
#ifndef INDI_DEMA_MQH
#define INDI_DEMA_MQH

// Includes.










// Structs.
struct IndiDEIndiMAParams : IndicatorParams {
  int ma_shift;
  unsigned int period;
  ENUM_APPLIED_PRICE applied_price;
  // Struct constructors.
  IndiDEIndiMAParams(unsigned int _period = 14, int _ma_shift = 0, ENUM_APPLIED_PRICE _ap = PRICE_CLOSE, int _shift = 0)
      : period(_period), ma_shift(_ma_shift), applied_price(_ap), IndicatorParams(INDI_DEMA, 1, TYPE_DOUBLE) {
    SetCustomIndicatorName("Examples\\DEMA");
    SetDataValueRange(IDATA_RANGE_PRICE);
    SetShift(_shift);
    switch (idstype) {
      case IDATA_ICUSTOM:
        if (custom_indi_name == "") {
          SetCustomIndicatorName("Examples\\DEMA");
        }
        break;
    }
  };
  IndiDEIndiMAParams(IndiDEIndiMAParams &_params, ENUM_TIMEFRAMES _tf) {
    THIS_REF = _params;
    tf = _tf;
  };
};

/**
 * Implements the Moving Average indicator.
 */
class Indi_DEMA : public Indicator<IndiDEIndiMAParams> {
 public:
  /**
   * Class constructor.
   */
  Indi_DEMA(IndiDEIndiMAParams &_p, IndicatorBase *_indi_src = NULL) : Indicator<IndiDEIndiMAParams>(_p, _indi_src) {}
  Indi_DEMA(ENUM_TIMEFRAMES _tf = PERIOD_CURRENT, int _shift = 0) : Indicator(INDI_DEMA, _tf, _shift) {}

  /**
   * Updates the indicator value.
   *
   * @docs
   * - https://www.mql5.com/en/docs/indicators/IDEMA
   */
  static double iDEMA(string _symbol, ENUM_TIMEFRAMES _tf, unsigned int _period, unsigned int _ma_shift,
                      ENUM_APPLIED_PRICE _applied_price, int _shift = 0, int _mode = 0, IndicatorBase *_obj = NULL) {
#ifdef __MQL5__
    int _handle = Object::IsValid(_obj) ? _obj.Get<int>(IndicatorState::INDICATOR_STATE_PROP_HANDLE) : NULL;
    double _res[];
    if (_handle == NULL || _handle == INVALID_HANDLE) {
      if ((_handle = ::iDEMA(_symbol, _tf, _period, _ma_shift, _applied_price)) == INVALID_HANDLE) {
        SetUserError(ERR_USER_INVALID_HANDLE);
        return EMPTY_VALUE;
      } else if (Object::IsValid(_obj)) {
        _obj.SetHandle(_handle);
      }
    }
    if (Terminal::IsVisualMode()) {
      // To avoid error 4806 (ERR_INDICATOR_DATA_NOT_FOUND),
      // we check the number of calculated data only in visual mode.
      int _bars_calc = BarsCalculated(_handle);
      if (GetLastError() > 0) {
        return EMPTY_VALUE;
      } else if (_bars_calc <= 2) {
        SetUserError(ERR_USER_INVALID_BUFF_NUM);
        return EMPTY_VALUE;
      }
    }
    if (CopyBuffer(_handle, _mode, _shift, 1, _res) < 0) {
      return ArraySize(_res) > 0 ? _res[0] : EMPTY_VALUE;
    }
    return _res[0];
#else
    Indi_Price *_indi_price = Indi_Price::GetCached(_symbol, _applied_price, _tf, _shift);
    // Note that _applied_price and Indi_Price mode indices are compatible.
    return Indi_DEMA::iDEMAOnIndicator(_indi_price.GetCache(), _indi_price, 0, _period, _ma_shift, _shift);
#endif
  }

  static double iDEMAOnIndicator(IndicatorCalculateCache<double> *cache, IndicatorBase *_indi, int indi_mode,
                                 unsigned int ma_period, unsigned int ma_shift, int shift) {
    return iDEMAOnArray(_indi.GetValueStorage(indi_mode), 0, ma_period, ma_shift, shift, cache);
  }

  static double iDEMAOnArray(ValueStorage<double> &price, int total, unsigned int ma_period, unsigned int ma_shift,
                             int shift, IndicatorCalculateCache<double> *cache = NULL, bool recalculate = false) {
    if (cache == NULL) {
      Print("iDEMAOnArray() cannot yet work without cache object!");
      DebugBreak();
      return 0.0f;
    }

    cache.SetPriceBuffer(price);

    if (!cache.HasBuffers()) {
      cache.AddBuffer<NativeValueStorage<double>>(3);  // 3 buffers.
    }

    if (recalculate) {
      // We don't want to continue calculations, but to recalculate previous one.
      cache.ResetPrevCalculated();
    }

    cache.SetPrevCalculated(Indi_DEMA::Calculate(cache.GetTotal(), cache.GetPrevCalculated(), 0, cache.GetPriceBuffer(),
                                                 ma_period, cache.GetBuffer<double>(0), cache.GetBuffer<double>(1),
                                                 cache.GetBuffer<double>(2)));

    return cache.GetTailValue<double>(0, ma_shift + shift);
  }

  static int Calculate(const int rates_total, const int prev_calculated, const int begin, ValueStorage<double> &price,
                       int InpPeriodEMA, ValueStorage<double> &DemaBuffer, ValueStorage<double> &Ema,
                       ValueStorage<double> &EmaOfEma) {
    if (rates_total < 2 * InpPeriodEMA - 2) return (0);

    int start;
    if (prev_calculated == 0)
      start = 0;
    else
      start = prev_calculated - 1;

    Indi_MA::ExponentialMAOnBuffer(rates_total, prev_calculated, 0, InpPeriodEMA, price, Ema);

    Indi_MA::ExponentialMAOnBuffer(rates_total, prev_calculated, InpPeriodEMA - 1, InpPeriodEMA, Ema, EmaOfEma);

    for (int i = start; i < rates_total && !IsStopped(); i++) DemaBuffer[i] = 2.0 * Ema[i].Get() - EmaOfEma[i].Get();

    return (rates_total);
  }

  /**
   * Returns the indicator's value.
   */
  virtual IndicatorDataEntryValue GetEntryValue(int _mode = 0, int _shift = -1) {
    double _value = EMPTY_VALUE;
    int _ishift = _shift >= 0 ? _shift : iparams.GetShift();

    switch (iparams.idstype) {
      case IDATA_BUILTIN:
        // We're getting DEMA from Price indicator.

        _value = Indi_DEMA::iDEMA(GetSymbol(), GetTf(), GetPeriod(), GetMAShift(), GetAppliedPrice(), _ishift, _mode,
                                  GetPointer(this));
        break;
      case IDATA_ICUSTOM:
        _value = iCustom(istate.handle, GetSymbol(), GetTf(), iparams.custom_indi_name, /*[*/ GetPeriod(), GetMAShift(),
                         GetAppliedPrice() /*]*/, _mode, _ishift);
        break;
      case IDATA_INDICATOR:
        // Calculating DEMA value from specified indicator.
        _value = Indi_DEMA::iDEMAOnIndicator(GetCache(), GetDataSource(), GetDataSourceMode(), GetPeriod(),
                                             GetMAShift(), _ishift);
        break;
    }
    return _value;
  }

  /**
   * Checks if indicator entry values are valid.
   */
  virtual bool IsValidEntry(IndicatorDataEntry &_entry) {
    return Indicator<IndiDEIndiMAParams>::IsValidEntry(_entry) && _entry.IsGt<double>(0) &&
           _entry.IsLt<double>(DBL_MAX);
  }

  /* Getters */

  /**
   * Get period value.
   *
   * Averaging period for the calculation of the moving average.
   */
  unsigned int GetPeriod() { return iparams.period; }

  /**
   * Get DEMA shift value.
   *
   * Indicators line offset relate to the chart by timeframe.
   */
  unsigned int GetMAShift() { return iparams.ma_shift; }

  /**
   * Get applied price value.
   *
   * The desired price base for calculations.
   */
  ENUM_APPLIED_PRICE GetAppliedPrice() { return iparams.applied_price; }

  /* Setters */

  /**
   * Set period value.
   *
   * Averaging period for the calculation of the moving average.
   */
  void SetPeriod(unsigned int _period) {
    istate.is_changed = true;
    iparams.period = _period;
  }

  /**
   * Set DEMA shift value.
   */
  void SetMAShift(int _ma_shift) {
    istate.is_changed = true;
    iparams.ma_shift = _ma_shift;
  }

  /**
   * Set applied price value.
   *
   * The desired price base for calculations.
   * @docs
   * - https://docs.mql4.com/constants/indicatorconstants/prices#enum_applied_price_enum
   * - https://www.mql5.com/en/docs/constants/indicatorconstants/prices#enum_applied_price_enum
   */
  void SetAppliedPrice(ENUM_APPLIED_PRICE _applied_price) {
    istate.is_changed = true;
    iparams.applied_price = _applied_price;
  }
};
#endif  // INDI_DEMA_MQH

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Indi_DEMA.mqh
////////////////////////////////////////////////////////////
/**
 * @file
 * Implements MA Cross Timeframe strategy.
 */

// Includes conditional compilation directives.


// Includes EA31337 framework.












// Inputs.
INPUT_GROUP("MA Cross Timeframe strategy: main");
input int Active_Timeframes = M15B + M30B + H1B + H2B + H3B + H4B + H6B +
                              H8B;        // Timeframes (M1=1,M2=2,M5=16,M15=256,M30=1024,H1=2048,H2=4096,H3,H4,H6,H8)
input ENUM_LOG_LEVEL Log_Level = V_INFO;  // Log level.
input bool Info_On_Chart = true;          // Display info on chart.

// Includes strategy.


// Defines.
#define ea_name "Strategy MA Cross Timeframe"
#define ea_version "2.000"
#define ea_desc "Strategy based on the moving average price indicators implementing another timeframe cross signal."
#define ea_link "https://github.com/EA31337/Strategy-MA_Cross_Timeframe"
#define ea_author "EA31337 Ltd"

// Properties.
#property version ea_version
#ifdef __MQL4__
#property description ea_name
#property description ea_desc
#endif
#property link ea_link
#property copyright "Copyright 2016-2023, EA31337 Ltd"

// Class variables.
EA *ea;

/* EA event handler functions */

/**
 * Implements "Init" event handler function.
 *
 * Invoked once on EA startup.
 */
int OnInit() {
  bool _result = true;
  EAParams ea_params(__FILE__, Log_Level);
  ea = new EA(ea_params);
  _result &= ea.StrategyAdd<Stg_MA_Cross_Timeframe>(Active_Timeframes);
  return (_result ? INIT_SUCCEEDED : INIT_FAILED);
}

/**
 * Implements "Tick" event handler function (EA only).
 *
 * Invoked when a new tick for a symbol is received, to the chart of which the Expert Advisor is attached.
 */
void OnTick() {
  ea.ProcessTick();
  if (!ea.GetTerminal().IsOptimization()) {
    ea.UpdateInfoOnChart();
  }
}

/**
 * Implements "Deinit" event handler function.
 *
 * Invoked once on EA exit.
 */
void OnDeinit(const int reason) { Object::Delete(ea); }

////////////////////////////////////////////////////////////
// üèÅ ŸÜŸáÿßŸäÿ©: Stg_MA_Cross_Timeframe.mq5
////////////////////////////////////////////////////////////
